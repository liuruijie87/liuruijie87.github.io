<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++对象模型（4） -- 函数语义学]]></title>
    <url>%2F2019%2F08%2F11%2FC-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%884%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、普通成员函数调用方式1234567891011121314151617181920212223242526272829303132class MYACLS&#123;public: int m_i; void myfunc(int abc) &#123; m_i += abc; &#125;&#125;;//编译器视角void _ZN6MYACLS6myfuncEi(MYACLS *const this, int abc) //编译器会额外安插一个this指针，一般会扔到参数的开头&#123; this-&gt;m_i + abc;&#125;void gmyfunc(MYACLS *ptmp,int abc)&#123; ptmp-&gt;m_i += abc;&#125;int main()&#123; MYACLS myacls; myacls.myfunc(18); //调用成员函数 gmyfunc(&amp;myacls, 18); //调用全局函数 printf(&quot;MYACLS::myfunc的地址=%p\n&quot;, &amp;MYACLS::myfunc); //可以发现多次打印成员函数的地址，都不会改变，编译的时候已经确定好了 return 1;&#125; （1）c++语言设计的时候有一个要求：要求对普通成员函数的调用不应该比全局函数效率差。基于这种设计要求，编译器内部实际上是将对成员函数myfunc()的调用转换成了对全局函数的调用。 （2）成员函数有独立的内存地址，是跟着类走的，并且成员函数的地址是在编译的时候就确定好的。 （3）编译器额外增加了一个叫this的形参，是个指针，指向的其实就是生成的对象。 （4）常规成员变量的存取，都通过this形参来进行，比如上述 this-&gt;m_i + abc。 二、虚成员函数、静态成员函数调用方式虚成员函数（虚函数）调用方式1234567891011121314151617181920212223242526272829303132class MYACLS&#123;public: virtual void myvirfunc() &#123; printf(&quot;myvirfunc()被调用,this = %p\n&quot;, this); myvirfunc2(); //走虚函数表指针调用 MYACLS::myvirfunc2(); //直接调用虚函数，效率更高。这种写法压制了虚拟机制，不再通过查询虚函数表来调用 //这种用类名::虚函数名()明确调用虚函数的方式等价于直接调用一个普通函数； &#125; virtual void myvirfunc2() &#123; printf(&quot;myvirfunc2()被调用,this = %p\n&quot;, this); &#125;&#125;;int main()&#123; MYACLS myacls; myacls.myvirfunc(); //用对象调用虚函数。 MYACLS *pmyacls = new MYACLS(); pmyacls-&gt;myvirfunc(); //用指针调用虚函数 //编译器视角 //(*pmyacls-&gt;vptr[0])(pmyacls); //a)vptr，编译器给生成的虚函数表指针，指向虚函数表 //b)[0] 虚函数表中第一项。代表myvirfunc()地址 //c)传递一个参数进去，就是this，也是编译器给加的 //d)*就得到了虚函数的地址； //printf(&quot;MYACLS::myvirfunc2虚函数的地址为%p&quot;, &amp;MYACLS::myvirfunc2); //地址也是在编译阶段确定的，多次打印不会变&#125; （1）用对象调用虚函数，就像调用普通成员函数一样,不需要通过虚函数表。 （2）用指针调用虚函数，要通过虚函数表指针查找虚函数表，通过虚函数表在好到虚函数的入口地址，完成对虚函数的调用。 静态成员函数调用方式1234567891011121314151617181920212223242526272829303132333435363738class MYACLS&#123;public: int m_i; void myfunc(int abc) &#123; //m_i += abc; //这里需要用到this指针，而this指针为空，则会报告异常 mystfunc(); &#125; //静态成员函数 static int m_si; static void mystfunc() //不需要this参数 &#123; printf(&quot;mystfunc()被调用\n&quot;); m_si = 1; &#125;&#125;;int main()&#123; MYACLS myacls; MYACLS *pmyacls = new MYACLS(); myacls.mystfunc(); pmyacls-&gt;mystfunc(); MYACLS::mystfunc(); ((MYACLS *)0)-&gt;mystfunc(); //能够正常调用静态成员函数 ((MYACLS *)0)-&gt;myfunc(12); //有些成员函数希望支持独立于类对象之外的存取操作,归为类所有，跟静态成员函数看似相似 myacls.myfunc(12); //此时如果要存取非静态成员变量，就会出错。 pmyacls-&gt;myfunc(12); printf(&quot;MYACLS::mystfunc()地址 = %p\n&quot;, MYACLS::mystfunc); delete pmyacls; return 1;&#125; （1）静态成员函数没有this指针，这点最重要。 （2）无法直接存取类中普通的非静态成员变量，因为非静态成员变量是通过this指针来操作的。 （3）静态成员函数不能在后面使用const，也不能设置为virtual。 （4）可以用类对象调用，但不非一定要用类对象调用。 （5）静态成员函数等同于非成员函数，有的需要提供回调函数的这种场合，可以将静态成员函数作为回调函数； 三、静态、动态类型，绑定，多态实现深谈静态类型和动态类型 （1）静态类型：对象定义时的类型，编译期间就确定好的。 （2）动态类型：对象目前所指向的类型（运行的时候才决定的类型）。 （3）一般只有指针或者引用才有动态类型的说法。而且一般都是指父类的指针或者引用。另外，动态类型在执行过程中可以改变。 仔细看如下代码分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Base&#123;public: void myfunc() //普通成员函数 &#123; cout &lt;&lt; &quot;Base::myfunc()&quot; &lt;&lt; endl; &#125; virtual void myvirfunc(int value = 1) &#123; cout &lt;&lt; &quot;Base::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl; &#125;&#125;;class Derive :public Base&#123;public: void myfunc() //普通成员函数 &#123; cout &lt;&lt; &quot;Derive::myfunc()&quot; &lt;&lt; endl; &#125; virtual void myvirfunc(int value = 2) &#123; cout &lt;&lt; &quot;Derive::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl; &#125;&#125;;class Derive2 :public Base&#123;public:&#125;;class A&#123;public: virtual void myvirfunc() &#123;&#125;&#125;;int main()&#123; Base base; //base的静态类型是Base，没有动态类型，因为不是指针不是引用 Derive derive; //derive的静态类型是Derive，没有动态类型，因为不是指针不是引用 Base *pbase; //pbase的静态类型依旧是Base * ,至少目前没有动态类型，因为它没有指向任何对象 Base *pbase2 = new Derive(); //pbase2的静态类型依旧是Base * ，动态类型是Derive Base *pbase3 = new Derive2(); //pbase3的静态类型依旧是Base *，动态类型是Derive2 pbase = pbase2; //pbase的动态类型Derive pbase = pbase3; //pbase的动态类型改变为Derive2&#125; 静态绑定和动态绑定 （1）静态绑定：绑定的是静态类型，所对应的函数或者属性依赖于对象的静态类型，发生在编译期 （2）动态绑定：绑定的是动态类型，所对应的函数或者属性依赖于对象的动态类型，发生在运行期 （3）普通成员函数是静态绑定，而虚函数是动态绑定。缺省参数一般是静态绑定。 代码分析： 123456789101112131415161718192021222324252627282930313233class Base&#123;public: void myfunc() //普通成员函数 &#123; cout &lt;&lt; &quot;Base::myfunc()&quot; &lt;&lt; endl; &#125; virtual void myvirfunc(int value = 1) &#123; cout &lt;&lt; &quot;Base::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl; &#125;&#125;;class Derive :public Base&#123;public: void myfunc() //普通成员函数 &#123; cout &lt;&lt; &quot;Derive::myfunc()&quot; &lt;&lt; endl; &#125; virtual void myvirfunc(int value = 2) &#123; cout &lt;&lt; &quot;Derive::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl; &#125;&#125;;int main()&#123; Derive derive; Derive *pderive = &amp;derive; pderive-&gt;myfunc(); //Derive::myfunc() Base *pbase = &amp;derive; pbase-&gt;myfunc(); ////Base::myfunc() &#125; 普通成员函数是静态绑定，换句话说，myfunc()是普通成员函数。这里到底调用父类的myfunc还是子类的myfunc取决于调用者的静态类型。 因为这里pbase的静态类型是Base，所以调用的是Base里的myfunc()；pderive的静态类型是Derive，所以调用的是Derive的myfunc()。 结论：为了避免混淆，不应该在子类中重新定义一个继承来的非虚函数。 再看如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041class Base&#123;public: void myfunc() //普通成员函数 &#123; cout &lt;&lt; &quot;Base::myfunc()&quot; &lt;&lt; endl; &#125; virtual void myvirfunc(int value = 1) //缺省参数的值为1 &#123; cout &lt;&lt; &quot;Base::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl; &#125;&#125;;class Derive :public Base&#123;public: void myfunc() //普通成员函数 &#123; cout &lt;&lt; &quot;Derive::myfunc()&quot; &lt;&lt; endl; &#125; virtual void myvirfunc(int value = 2) //缺省参数的值为2 &#123; cout &lt;&lt; &quot;Derive::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl; &#125;&#125;;int main()&#123; Derive derive; Derive *pderive = &amp;derive; Base *pbase = &amp;derive; pderive-&gt;myvirfunc(); //执行Derive的myvirfunc(); --- Derive::myvirfunc() pbase-&gt;myvirfunc(); //pbase动态类型是Derive，而虚函数是动态绑定，参照是它的动态类型；--- Derive::myvirfunc() //缺省value参数打印出来的居然是1：Derive::myvirfunc(),value = 1 //这就始于函数参数缺省值的静态绑定，所以缺省参数绑定到了父类函数的缺省参数上去了 Base &amp;yinbase = derive; //引用，效果和指针一样 yinbase.myvirfunc(); //Derive::myvirfunc(),value = 1 pbase = &amp;base; pbase-&gt;myvirfunc(); //----Base::myvirfunc(); Base::myvirfunc(),value = 1&#125; 虚函数是动态绑定,换句话说，myvirfunc()是虚函数，这里到底执行哪个myvivfunc()取决于调用者的动态类型。 这里pbase的动态类型分别Derive，Base，所以调用的也分别是Derive和Base的myvirfunc()，pderive的动态类型是Derive，所以调用的是Derive的myvirfunc()。 从上面代码中可以看出，虚函数的参数缺省值是静态绑定，所以不要重新定义虚函数的缺省参数的值。 c++中的多态性的体现 多态性这个概念，分两方面谈： a)从代码实现上 b)从表现形式上 有一个观点是肯定的：多态，必须是存在虚函数，没有虚函数，绝不可能存在多态，有虚函数并且调用虚函数。 （1）从代码实现上来看，当我们调用一个虚函数时，走的是不是通过查询虚函数表来找到虚函数入口地址，然后去执行虚函数，如果走的是这个途径，那就是多态，如果不走这个途径，它就不是多态。看代码分析： 12345678910111213141516171819class A&#123;public: virtual void myvirfunc() &#123;&#125;&#125;;int main()&#123; A *pa = new A(); pa-&gt;myvirfunc(); //是多态 A a; a.myvirfunc(); //这个就不是多态 A *pa1 = &amp;a; pa1-&gt;myvirfunc(); //这个也是多态 return 1;&#125; （2）从表现形式上来看(通过代码来体现) a)有继承关系，有父类有子类，父类中必须有虚函数(这意味着子类中一定有虚函数)，子类重写父类的虚函数。 b)父类指针或者引用指向子类对象。 c)当以父类指针或者引用调用子类中重写了的虚函数时，我们就能看出来多态的表现了，因为调用的是子类的虚函数。 代码分析： 12345678910111213141516171819202122232425class Base&#123;public: virtual void myvirfunc() &#123; cout &lt;&lt; &quot;Base::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl; &#125;&#125;;class Derive :public Base&#123;public: virtual void myvirfunc() &#123; cout &lt;&lt; &quot;Derive::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl; &#125;&#125;; int main()&#123; Derive derive; Base *pbase = &amp;derive; pbase-&gt;myvirfunc(); //多态实现 return 1;&#125; 四、多继承下的第二基类问题探讨 先给出一个继承关系，稍后做具体分析。 123456789101112131415161718192021222324252627282930313233343536373839class Base&#123;public: virtual void f() &#123; cout &lt;&lt; &quot;Base::f()&quot; &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; &quot;Base::g()&quot; &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; &quot;Base::h()&quot; &lt;&lt; endl; &#125; virtual ~Base() &#123; int abc; abc = 1; &#125;&#125;;class Base2&#123;public: virtual void hBase2() &#123; cout &lt;&lt; &quot;Base2::hBase2()&quot; &lt;&lt; endl; &#125; virtual ~Base2() &#123; int abc; abc = 1; &#125;&#125;;class Derive :public Base,public Base2 &#123;public: virtual void i() &#123; cout &lt;&lt; &quot;Derive::i()&quot; &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; &quot;Derive::g()&quot; &lt;&lt; endl; &#125; void myselffunc() &#123;&#125; //只属于Derive的函数 virtual ~Derive() &#123; int abc; abc = 1; &#125; &#125;; 多重继承的复杂性往往体现在后边这个基类上，先来看使用后面这个基类的情况： 12345Base2 *pb2 = new Derive();//编译器视角Derive *temp = new Derive();Base2 *pb2 = (Base2 *)((char *)temp + sizeof(Base));delete pb2; 现在，我们考虑如何成功删除用第二基类指针new出来的继承类对象。注意，我们要删除的实际是整个Derive()对象，要能够保证Derive()对象的析构函数被正常调用，那么编译器会调用Base2的析构函数，还是调用Derive的析构函数呢？执行delte pb2时，系统的动作会是什么？ 事实上，这里分为以下几种情况： （1）如果Base2里没有析构函数,编译器会直接删除以pb2开头的这段内存，一定报异常，因为这段内存压根就不是new起始的内存。 （2）如果Base2里有一个析构函数，但整个析构函数是个普通析构函数（非虚析构函数），那么当delte pb2，这个析构函数就会被系统调用,但是delete的仍旧是pb2开头这段内存，所以一定报异常。因为这段内存压根就不是new起始的内存。（析构函数如果不是虚函数，编译器会实施静态绑定，静态绑定意味着你delete Base2指针时，删除的内存开始地址就是pb2的当前位置，所以肯定是错误的）。 （3）如果Base2里是一个虚析构函数，则delete的时候，编译器会自动按～Dervice() –&gt; ～Base2() –&gt; ～Base()的顺序调用，此时就是把整个Derive()对象的内存都释放了。 （4）Derive里就就算没有虚析构函数，因为Base2里有虚析构函数，编译器也会为此给Derive生成虚析构函数，为了调用～Base2()和～Base()虚析构函数。 由上述结论知，凡是涉及到继承的，所有类都加上虚析构函数，以防异常。 另外，Derive类的第二个虚函数表中发现了thunk字样，一般它用在多重继承中（从第二个虚函数表开始可能就 会有），用于this指针调整。它其实是一段汇编代码，这段代码干两个事情： (1)调整this指针（this指针调整的目的就是让对象指针正确的指向对象首地址，从而能正确的调用对象的成员函数或者说正确确定数据成员的存储位置） (2)调用Derive析构函数 五、虚基类带虚函数的成员分布以及继承开销123456789101112131415161718192021class Base&#123;public: virtual void f() &#123;&#125; virtual ~Base() &#123;&#125; int m_basei;&#125;;class Derive :public virtual Base&#123;public: virtual ~Derive()&#123;&#125; int m_derivei;&#125;;int main()&#123; cout &lt;&lt; sizeof(Derive) &lt;&lt; endl; // 16 Derive dobj; dobj.m_basei = 2; // 13-16字节 dobj.m_derivei = 5; // 5-8字节&#125; 由此可以看出，此种情况下的数据分布应该是：虚基类表指针（1-4字节）、子类数据成员（5-8字节）、虚函数表指针（9-12字节）、基类数据成员（13-16字节）。 一般来说， （1）随着继承深度的增加，开销或者说执行时间也会增加。 （2）多重继承一般也会导致开销增加。 （3）虚函数也会导致开销增加。 六、指向成员函数的指针以及vcall探讨指向普通成员函数的指针 成员函数地址是在编译时就确定好的。但是，要想调用成员函数，是需要通过对象来调用的。所有常规（非静态）成员函数，要想调用，都需要一个对象来调用它。并且，通过成员函数指针对常规的成员函数调用的成本，和通过普通的函数指针来调用静态成员函数，成本上差不多。 1234567891011121314151617181920212223242526272829303132333435363738class A&#123;public: void myfunc1(int tempvalue1) &#123; cout &lt;&lt; &quot;tempvalue1 = &quot; &lt;&lt; tempvalue1 &lt;&lt; endl; &#125; void myfunc2(int tempvalue2) &#123; cout &lt;&lt; &quot;tempvalue2 = &quot; &lt;&lt; tempvalue2 &lt;&lt; endl; &#125; static void mysfunc(int tempvalue) &#123; cout &lt;&lt; &quot;A::mysfunc()静态成员函数--tempvalue = &quot; &lt;&lt; tempvalue &lt;&lt; endl; &#125;&#125;;int main()&#123; A mya; void (A::*pmypoint)(int tempvalue) = &amp;A::myfunc1; //定义一个成员函数指针并给初值 pmypoint = &amp;A::myfunc2; //给成员函数指针赋值 (mya.*pmypoint)(15); //通过成员函数指针来调用成员函数，必须要通过对象的介入才能调用 A *pmya = new A(); (pmya-&gt;*pmypoint)(20); //用对象指针介入来使用成员函数指针来调用成员函数 //编译器视角 //pmypoint(&amp;mya, 15); //pmypoint(pmya, 20); void(*pmyspoint)(int tempvalue) = &amp;A::mysfunc; //一个普通的函数指针，而不是成员函数指针 pmyspoint(80); return 1;&#125; 指向虚成员函数的指针及vcall理解 vcall(vcall trunk) = virtual call：虚调用。它代表一段要执行的代码的地址，这段代码引导编译器去执行正确的虚函数，或者我们直接把vcall看成虚函数表，如果这么看待的话，那么vcall{0}代表的就是虚函数表里的第一个函数，vcall{4}就代表虚函数表里的第二个虚函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243class A&#123;public: void myfunc1(int tempvalue1) &#123; cout &lt;&lt; &quot;tempvalue1 = &quot; &lt;&lt; tempvalue1 &lt;&lt; endl; &#125; void myfunc2(int tempvalue2) &#123; cout &lt;&lt; &quot;tempvalue2 = &quot; &lt;&lt; tempvalue2 &lt;&lt; endl; &#125; static void mysfunc(int tempvalue) &#123; cout &lt;&lt; &quot;A::mysfunc()静态成员函数--tempvalue = &quot; &lt;&lt; tempvalue &lt;&lt; endl; &#125; virtual void myvirfuncPrev(int tempvalue) &#123; cout &lt;&lt; &quot;A::myvirfuncPrev()虚成员函数--tempvalue = &quot; &lt;&lt; tempvalue &lt;&lt; endl; &#125; virtual void myvirfunc(int tempvalue) &#123; cout &lt;&lt; &quot;A::myvirfunc()虚成员函数--tempvalue = &quot; &lt;&lt; tempvalue &lt;&lt; endl; &#125;&#125;; void func()&#123; void (A::*pmyvirfunc)(int tempvalue) = &amp;A::myvirfunc; //成员函数指针 -- vcall(vcall trunk)地址（虚函数） A *pvaobj = new A; pvaobj-&gt;myvirfunc(190); (pvaobj-&gt;*pmyvirfunc)(190); printf(&quot;%p\n&quot;, &amp;A::myvirfunc); pmyvirfunc = &amp;A::myfunc2; //真正的成员函数地址 (pvaobj-&gt;*pmyvirfunc)(33); delete pvaobj; &#125; 完善理解：&amp;A::myvirfunc,打印出来的是一个地址，这个地址中有一段代码，这个代码中记录的是该虚函数在虚函数表中的一个偏移值，有了这个偏移值，再有了具体的对象指针，我们就能够知道调用的是哪个虚函数表里边的哪个虚函数了。 成员函数指针里，保存的可能是一个vcall(vcall trunk)地址（如果指针指向的是虚函数）,要么也可能是一个真正的成员函数地址（指针指向的不是虚函数）。如果是一个vcall地址，那vcall能够引导编译器找出正确的虚函数表中的虚函数地址进行调用。 inline函数介绍及其扩展细节inline函数介绍 使用inline之后，编译器内部会有一个比较复杂的测试算法来评估这个inline函数的复杂度,可能会统计这个inline函数中，赋值次数，内部函数调用，虚函数调用等次数（权重）。 （1）开发者写inline只是对编译器的一个建议，但如果编译器评估这个inline函数复杂度过高，这个inline建议就被编译器忽略。 （2）如果inline被编译器采纳，那么inline函数的扩展，就要在调用这个inline函数的那个点上进行，此时可能带来额外的问题比如：参数求值，可能导致临时对象的生成和管理。 inline扩展细节 见代码的注释部分： 12345678910111213141516inline int myfunc(int testv)&#123; return testv * (5 + 4) * testv;&#125;void func()&#123; int i = myfunc(12 + 15); //编译器会先求值，然后用实参再替换形参 int a = 80; int i = myfunc(a + 15); //编译器会先计算a和15的和值，然后再替换掉形参&#125;int main()&#123; _nmsp1::func(); return 1;&#125;]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL源码剖析（4）]]></title>
    <url>%2F2019%2F08%2F10%2FSTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面的话 前一篇博文介绍了序列式容器，接下来介绍关联式容器。 概览 所谓关联式容器，即每个元素都有一个键值（key）和一个实值（value）。当元素被插入到关联式容器中时，容器的内部结构便按照其键值大小，以某种特定规则将这个元素放置于适当位置。关联式容器没有头尾（只有最大元素和最小元素），所以不会有push_back(), push_front(), pop_back(), pop_front(), begin(), end()这些操作行为。 STL中的关联式容器分为set和map两大类，以及这两大类的衍生体multiset和multimap。这些容器的底层实现机制都是红黑树。红黑树也是一个独立的容器，但是并不开放给外界使用。此外，SGI STL还提供了一个不在标准规格之列的关联式容器：hashtable,以及以hashtable为底层机制的hash_set,hash_map,hash_multiset,hash_multimap。 set （1）set里面元素的键值就是实值，实值就是键值，所有元素都会根据元素的键值自动被排序，并且set不允许两个元素有相同的键值。 （2）我们不能通过set的迭代器改变set的元素值，因为set的元素值就是其键值，关系到set元素的排列规则，如果任意改变set的元素值，会破坏set组织。因此，set::iterator 被定义为const_iterator，杜绝写入操作。 （3）set拥有与list相同的某些性质：当用户对它进行元素新增或删除操作时，操作之前的所有迭代器（除了被删除元素的迭代器）在操作之后都依然有效。 （4）set是以红黑树为底层机制，因为红黑树是一种平衡二叉搜索树，自动排序效果不错。而且对于set所开放的各种接口操作，红黑树也都提供了，所以几乎所有的set操作行为，都只是调用红黑树的操作行为而已。 map （1）map的所有元素都是pair，同时拥有实值（value）和键值（key）。pair的第一元素被视为键值，第二元素被视为实值。它的所有元素都会根据元素的键值自动被排序，并且map不允许两个元素拥有相同的键值。 （2）我们不能通过map的迭代器改变map里元素的键值，因为键值关系到map元素的排列规则，任意改变map元素键值将会严重破坏map组织，但是可以改变元素的实值，因为map元素的实值并不影响map元素的排列规则。 （3）map拥有与list相同的某些性质：当用户对它进行元素新增或删除操作时，操作之前的所有迭代器（除了被删除元素的迭代器）在操作之后都依然有效。 （4）map也是以红黑树为底层机制，因为红黑树是一种平衡二叉搜索树，自动排序效果不错。而且对于map所开放的各种接口操作，红黑树也都提供了，所以几乎所有的map操作行为，都只是调用红黑树的操作行为而已。 multiset和multimap （1）multiset的特性以及用法和set完全相同，唯一的差别在于它允许键值重复，因此它的插入操作采用的是底层机制红黑树的insert_equal()而非insert_unique()。 （2）multimap的特性以及用法和map完全相同，唯一的差别在于它允许键值重复，因此它的插入操作采用的是底层机制红黑树的insert_equal()而非insert_unique()。 hash_set （1）hash_set以hashtable为底层机制，由于hash_set所提供的操作接口，hashtable都提供了，所以几乎所有的hash_set操作行为都只是转调用hashtable的操作行为而已。 （2）红黑树有自动排序功能，而hashtable没有，反映到表层就是，set的元素有自动排序功能而hash_set没有。 （3）hash_set跟set一样，元素的键值就是实值，实值就是键值。 hash_map （1）hash_map也是以hashtable为底层机制，由于hash_map所提供的操作接口，hashtable都提供了，所以几乎所有的hash_map操作行为都只是转调用hashtable的操作行为而已。 （2）红黑树有自动排序功能，而hashtable没有，反映到表层就是，map的元素有自动排序功能而hash_map没有。 （3）hash_map跟map一样，每一个元素同时拥有一个实值和一个键值。 hash_multiset和hash_multimap （1）hash_multiset的特性与multiset完全相同，唯一差别就在于它的底层机制是hashtable。因此，hash_multiset的元素不会自动排序。 （2）hash_multiset和hash_set实现上的唯一差别在于，前者的元素插入操作采用底层机制hashtable的insert_equal(),后者则是采用insert_unique()。 （3）hash_multimap的特性与multimap完全相同，唯一差别就在于它的底层机制是hashtable。因此，hash_multimap的元素不会自动排序。 （4）hash_multimap和hash_map实现上的唯一差别在于，前者的元素插入操作采用底层机制hashtable的insert_equal(),后者则是采用insert_unique()。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象模型（3） -- 数据语义学]]></title>
    <url>%2F2019%2F08%2F09%2FC-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、数据成员绑定时机12345678910111213typedef string mytype;//定义一个类class A&#123;public: void myfunc(mytype tmpvalue) //mytype = string &#123; m_value = tmpvalue; //出错，是把一个string类型给一个整型 &#125; typedef int mytype;private: mytype m_value; //int &#125;; （1）编译器对成员函数的解析，是整个类定义完毕后才开始的。因为只有整个类定义完毕后，编译器才能看到类中的成员变量，才能根据实际的需要把出现该成员变量的场合做适当的解释（成员函数中解析成类中的变量类型，全局函数中解析成全局的变量类型）。 （2）对于成员函数参数，是在编译器第一次遇到整个类型mytype的时候被决定的。所以，mytype第一次遇到的时候，编译器只看到了typedef string mytype，没有看到类中的typedef int mytype。 （3）为了在类中尽早的看到类型mytype，所以这种类型定义语句typedef，一定要挪到类的最开头定义。（即上述代码中应该把typedef int mytype移到class A的开头处）当后边的成员函数第一次遇到这个类型mytype的时候，它就本着最近碰到的类型的原则来应用最近碰到的类型。 二、进程内存空间布局 不同的数据在内存中会有不同的保存时机，保存位置。当运行一个可执行文件时，操作系统就会把这个可执行文件加载到内存，此时进程有一个虚拟的地址空间（内存空间），分为：堆栈段、数据段、代码段等。从下面代码中可以看出些许规律。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int *ptest = new int(120);int g1;int g2;int g3 = 12;int g4 = 32;int g5;int g6 = 0;static int g7;static int g8=0;static int g9 = 10;void mygfunc()&#123; return;&#125;//定义一个类class MYACLS&#123;public: int m_i; static int m_si; //声明不是定义 int m_j; static int m_sj; int m_k; static int m_sk; //static void myclsfunc() &#123;&#125;&#125;;int MYACLS::m_sj = 0; //这才是定义；int main()&#123; int i = 7;; printf(&quot;i地址=%p\n&quot;, &amp;i); //i地址=00AFFB94 printf(&quot;ptest地址=%p\n&quot;, &amp;ptest); //ptest地址=00F9B300 printf(&quot;g1地址=%p\n&quot;, &amp;g1); //g1地址=00F9B2EC printf(&quot;g2地址=%p\n&quot;, &amp;g2); //g2地址=00F9B2F0 printf(&quot;g3地址=%p\n&quot;, &amp;g3); //g3地址=00F9B000 printf(&quot;g4地址=%p\n&quot;, &amp;g4); //g4地址=00F9B004 printf(&quot;g5地址=%p\n&quot;, &amp;g5); //g5地址=00F9B2F4 printf(&quot;g6地址=%p\n&quot;, &amp;g6); //g6地址=00F9B2F8 printf(&quot;g7地址=%p\n&quot;, &amp;g7); //g7地址=00F9B304 printf(&quot;g8地址=%p\n&quot;, &amp;g8); //g8地址=00F9B308 printf(&quot;g9地址=%p\n&quot;, &amp;g9); //g9地址=00F9B008 printf(&quot;MYACLS::m_sj地址=%p\n&quot;, &amp;(MYACLS::m_sj)); //MYACLS::m_sj地址=00F9B2FC printf(&quot;mygfunc()地址=%p\n&quot;, mygfunc); //mygfunc()地址=00F91433 printf(&quot;main()地址=%p\n&quot;, main); //main()地址=00F9132A cout &lt;&lt; (void*)mygfunc &lt;&lt; endl; //00F91433 return 1;&#125; 从上述代码的打印结果来看，不同类型的数据在内存中的存储位置是不同的，同一类型的数据是连续存储的。 三、类中成员变量的布局 （1）普通成员变量的存储顺序是按照在类中的定义顺序从上到下来的。比较晚出现的成员变量在内存中有更高的地址。类定义中pubic,private,protected的数量，不影响类对象的sizeof。 （2）某些因素会导致成员变量之间排列不连续，就是边界调整（字节对齐），调整的目的是提高效率，编译器自动调整。调整方式：往成员之间填补一些字节，使用类对象的sizoef字节数凑成一个4的整数倍，8的整数倍。 （3）为了统一字节对齐问题，引入一个概念叫一字节对齐(不对齐)：#pragma pack(1)。把这个语句放到程序最开始处即可。 （4）有虚函数时，编译器往类定义中增加vptr虚函数表指针（内部的数据成员）。 （5）成员变量偏移值，就是这个成员变量的地址，离对象首地址偏移多少。 四、类中成员变量的存取 （1）静态成员变量，可以当做一个全局量，但是它只在类的空间内可见。引用时用类名::静态成员变量名。静态成员变量只有一个实体，保存在可执行文件的数据段。 （2）非静态成员变量（普通的成员变量）存放在类的对象中。存取通过类对象（类对象指针）来操作。例如：对于普通成员的访问，编译器是把类对象的首地址加上成员变量的偏移值。 五、单一继承下的数据成员布局 （1）一个子类对象，所包含的内容，是他自己的成员，加上他父类的成员的总和。从偏移值看，父类成员先出现，然后才是孩子类成员。 （2）引入继承关系后，可能会带来内存空间的额外增加（字节对齐）。所以不能用memcpy内存拷贝把父类对象的内容直接往子类对象里拷贝。 六、带有虚函数的类中数据成员布局单个类带虚函数的数据成员布局 类中引入虚函数时，会有额外的成本付出： 1)编译的时候，编译器会产生虚函数表。 2)对象中会产生虚函数表指针vptr，用以指向虚函数表。 3)增加或者扩展构造函数，增加给虚函数表指针vptr赋值的代码，让vptr指向虚函数表。 4)如果多重继承，比如你继承了2个父类，每个父类都有虚函数的话，每个父类都会有vptr，那继承时，子类就会把这两根vptr都继承过来，如果子类还有自己额外的虚函数的话，子类与第一个基类共用一个vptr。 5)析构函数中也被扩展增加了虚函数表指针vptr相关的赋值代码，这个赋值代码似乎和构造函数中代码相同。 单一继承父类带虚函数的数据成员布局 代码如下： 1234567891011121314151617181920212223242526272829303132333435class Base&#123;public: int m_bi; virtual void mybvirfunc() &#123;&#125;&#125;;class MYACLS :public Base&#123;public: int m_i; int m_j; MYACLS() &#123; int abc = 1; //方便加断点 &#125; ~MYACLS() &#123; int def = 0;//方便加断点 &#125;&#125;;int main()&#123; cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl; //16 printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi); //MYACLS::m_bi = 4 printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i); //MYACLS::m_i = 8 printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j); //MYACLS::m_j = 12 MYACLS myobj; myobj.m_i = 3; myobj.m_j = 6; myobj.m_bi = 9; return 1;&#125; 从打印结果可以看出，当父类中有虚函数的时候，指向父类虚函数表的虚函数表指针会占用内存开头的四个字节，紧接着是父类的成员变量，最后才是子类的成员变量。 单一继承父类不带虚函数的数据成员布局12345678910111213141516171819202122232425262728293031323334class Base&#123;public: int m_bi;&#125;;class MYACLS :public Base&#123;public: int m_i; int m_j; MYACLS() &#123; int abc = 1; //方便加断点 &#125; ~MYACLS() &#123; int def = 0;//方便加断点 &#125;&#125;;int main()&#123; cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl; //12 printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi); //MYACLS::m_bi = 0 printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i); //MYACLS::m_i = 4 printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j); //MYACLS::m_j = 8 MYACLS myobj; myobj.m_i = 3; myobj.m_j = 6; myobj.m_bi = 9; return 1;&#125; 从打印结果可以看出，如果父类中没有虚函数，则父类的成员变量就放到了内存开头处，之后是子类的成员变量。 但是如果子类中有虚函数而父类中没有，内存布局又会发生变化，即数据在内存空间中的分布分别是：父类成员、子类的虚函数表指针、子类成员。代码及打印结果如下： 1234567891011121314151617181920212223242526272829303132333435class Base&#123;public: int m_bi;&#125;;class MYACLS :public Base&#123;public: int m_i; int m_j; virtual void myvirfunc() &#123;&#125; MYACLS() &#123; int abc = 1; //方便加断点 &#125; ~MYACLS() &#123; int def = 0;//方便加断点 &#125;&#125;;int main()&#123; cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl; //16 printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi); //MYACLS::m_bi = 0 printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i); //MYACLS::m_i = 8 printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j); //MYACLS::m_j = 12 MYACLS myobj; myobj.m_i = 3; myobj.m_j = 6; myobj.m_bi = 9; return 1;&#125; 如果子类和父类中都有虚函数，则子类和父类共用一个虚函数表指针，即它俩的地址一样，都在内存的开头处，代码如下： 123456789101112131415161718192021222324252627282930313233343536class Base&#123;public: int m_bi; virtual void mybvirfunc() &#123;&#125;&#125;;class MYACLS :public Base&#123;public: int m_i; int m_j; virtual void myvirfunc() &#123;&#125; MYACLS() &#123; int abc = 1; //方便加断点 &#125; ~MYACLS() &#123; int def = 0;//方便加断点 &#125;&#125;;int main()&#123; cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl; //16 printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi); //MYACLS::m_bi = 4 printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i); //MYACLS::m_i = 8 printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j); //MYACLS::m_j = 12 MYACLS myobj; myobj.m_i = 3; myobj.m_j = 6; myobj.m_bi = 9; return 1;&#125; 总结：不管是父类还是子类，只要含有虚函数，则虚函数指针就位于对应的所有数据成员的前面（父类指针对应父类成员，子类指针对应子类成员），如果父类和子类都含有虚函数，则它俩的虚函数表指针共用一块内存，位于内存空间的开头处。 多重继承且父类都带虚函数的数据成员布局1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Base1&#123;public: int m_bi; virtual void mybvirfunc() &#123;&#125; Base1() &#123; printf(&quot;Base1::Base1()的this指针是：%p!\n&quot;, this); &#125;&#125;;class Base2&#123;public: int m_b2i; virtual void mybvirfunc2() &#123;&#125; Base2() &#123; printf(&quot;Base2::Base2()的this指针是：%p!\n&quot;, this); &#125;&#125;;class MYACLS :public Base1,public Base2&#123;public: int m_i; int m_j; virtual void myvirfunc() &#123;&#125; //虚函数 MYACLS() &#123; int abc = 1; //方便加断点 printf(&quot;MYACLS::MYACLS()的this指针是：%p!\n&quot;, this); &#125; ~MYACLS() &#123; int def = 0;//方便加断点 &#125;&#125;;int main()&#123; cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl; //24 printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi); //MYACLS::m_bi = 4 printf(&quot;MYACLS::m_b2i = %d\n&quot;, &amp;MYACLS::m_b2i); //MYACLS::m_b2i = 4 printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i); //MYACLS::m_i = 16 printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j); //MYACLS::m_j = 20 MYACLS myobj; //Base1::Base1()的this指针是：004FFC24! //Base2::Base2()的this指针是：004FFC2C! //MYACLS::MYACLS()的this指针是：004FFC24! myobj.m_i = 3; myobj.m_j = 6; myobj.m_bi = 9; myobj.m_b2i = 12; MYACLS *pmyobj = new MYACLS(); //Base1::Base1()的this指针是：008F11D8! //Base2::Base2()的this指针是：008F11E0! //MYACLS::MYACLS()的this指针是：008F11D8! pmyobj-&gt;m_i = 3; pmyobj-&gt;m_j = 6; pmyobj-&gt;m_bi = 9; pmyobj-&gt;m_b2i = 12; return 1;&#125; （1）通过this指针打印，我们看到访问Base1成员不用跳 ，访问Base2成员要this指针要偏移（跳过）8字节。 （2）我们看到偏移值，m_bi和m_b2i偏移都是4。 （3）this指针，加上偏移值就的能够访问对应的成员变量，比如m_b2i = this指针+偏移值。 结论：我们要访问一个类对象中的成员，成员的定位是通过：this指针（编译器会自动调整）以及该成员的偏移值，这两个因素来定义。这种this指针偏移的调整都需要编译器介入来处理完成。 虚基类相关1234567891011121314151617181920212223242526272829class Grand //爷爷类&#123;public:&#125;;class A1 : virtual public Grand&#123;public:&#125;;class A2 : virtual public Grand&#123;public:&#125;;class C1 :public A1, public A2&#123;public: int m_c1;&#125;;int main()&#123; cout &lt;&lt; sizeof(Grand) &lt;&lt; endl; // 1 cout &lt;&lt; sizeof(A1) &lt;&lt; endl; // 4 cout &lt;&lt; sizeof(A2) &lt;&lt; endl; // 4 cout &lt;&lt; sizeof(C1) &lt;&lt; endl; // 12 return 1;&#125; （1）虚基类就是让Grand类只被继承一次，防止二义性问题。 （2）有虚基类，就有虚基类表vbtable(virtual base table)、虚基类表指针vbptr(virtual base table pointer)。 （3）空类sizeof(Grand)=1好理解。虚继承之后，A1,A2里就会被编译器插入一个虚基类表指针，这个指针，有点成员变量的感觉。A1,A2里因为有了虚基类表指针，因此占用了4个字节。 1234567891011121314151617181920212223242526272829303132333435363738class Grand //爷爷类&#123;public: int m_grand;&#125;;class A1 : virtual public Grand&#123;public: int m_a1;&#125;;class A2 : virtual public Grand&#123;public: int m_a2;&#125;;class C1 :public A1, public A2&#123;public: int m_c1;&#125;;int main()&#123; cout &lt;&lt; sizeof(Grand) &lt;&lt; endl; // 1 cout &lt;&lt; sizeof(A1) &lt;&lt; endl; // 4 cout &lt;&lt; sizeof(A2) &lt;&lt; endl; // 4 cout &lt;&lt; sizeof(C1) &lt;&lt; endl; // 12 //内存分布情况 C1 c; c.m_grand = 2; // 21-24字节 c.m_a1 = 3; // 5-8字节 c.m_a2 = 4; // 13-16字节 c.m_c1 = 5; // 17-20字节 return 1;&#125; 根据内存分析可以看出：1-4字节和9-12字节应该存放的就是两个虚基类表指针，其中1-4字节是vbptr1（继承自A1），9-12字节是vbptr2（继承自A2）。其余的数据分布如上述程序中所示，需要注意的是：爷爷类里的成员分布在内存的最后。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Grand //爷爷类&#123;public: int m_grand;&#125;;class Grand2 //爷爷类&#123;public: int m_grand2;&#125;;class A1 : virtual public Grand,virtual public Grand2&#123;public: int m_a1;&#125;;class A2 : virtual public Grand&#123;public: int m_a2;&#125;;class C1 :public A1, public A2&#123;public: int m_c1;&#125;;int main()&#123; cout &lt;&lt; sizeof(Grand) &lt;&lt; endl; // 4 cout &lt;&lt; sizeof(A1) &lt;&lt; endl; // 16（3个int数据+1个虚基类表指针） cout &lt;&lt; sizeof(A2) &lt;&lt; endl; // 12（2个int数据+1个虚基类表指针） cout &lt;&lt; sizeof(C1) &lt;&lt; endl; // 28 //内存分布情况 C1 c; c.m_a1 = 1; // 5-8字节 c.m_a2 = 2; // 13-16字节 c.m_c1 = 3; // 17-20字节 c.m_grand = 4; // 21-24字节 c.m_grand2 = 5; // 25-28字节 return 1;&#125; 由此，可以判断出，一个类同时虚继承多个父类，只会产生一个虚基类指针（A1）。1-4字节放的是A1的虚基类指针，9-12字节放的是A2的虚基类指针。其他的数据分布如程序所示。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象模型（2） -- 虚函数]]></title>
    <url>%2F2019%2F08%2F06%2FC-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%882%2F</url>
    <content type="text"><![CDATA[一、虚函数表指针位置分析 一个类若有虚函数，这个类就会产生一个虚函数表。当类创建对象的时候，对象内就会维护一个虚函数表指针，该指针(vptr)会指向这个虚函数表的开始地址。接下来借助代码分析一下虚函数表指针的位置。 12345678910111213141516171819202122232425class A&#123;public: int i; //4字节 virtual void testfunc() &#123;&#125; //虚函数，vptr4字节。&#125;;int main()&#123; A aobj; int ilen = sizeof(aobj); cout &lt;&lt; ilen &lt;&lt; endl; //8字节 char *p1 = reinterpret_cast&lt;char *&gt;(&amp;aobj); //类型转换，硬转 &amp;aobj这是对象aobj的首地址。 char *p2 = reinterpret_cast&lt;char *&gt;(&amp;(aobj.i)); if (p1 == p2) //说明aobj.i和aobj的位置相同，说明i在对象aobj内存布局的上边。虚函数表指针vptr在下边 &#123; cout &lt;&lt; &quot;虚函数表指针位于对象内存的末尾&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;虚函数表指针位于对象内存的开头&quot; &lt;&lt; endl; &#125; return 1; &#125; 通过测试，我们发现虚函数表指针在对象内存的开头处。 二、继承关系作用下虚函数的手工调用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//父类class Base&#123;public: virtual void f() &#123; cout &lt;&lt; &quot;Base::f()&quot; &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; &quot;Base::g()&quot; &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; &quot;Base::h()&quot; &lt;&lt; endl; &#125;&#125;;class Derive :public Base &#123; virtual void g() &#123; cout &lt;&lt; &quot;Derive::g()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; // cout &lt;&lt; sizeof(Base) &lt;&lt; endl; cout &lt;&lt; sizeof(Derive) &lt;&lt; endl; Derive *d = new Derive(); //派生类指针。 long *pvptr = (long *)d; //指向对象的指针d转成了long *类型。 long *vptr = (long *)(*pvptr); //(*pvptr)表示pvptr指向的对象，也就是Derive本身。Derive对象是4字节的，代表的是虚函数表指针地址。 for (int i = 0; i &lt;= 4; i++) //循环5次，打印出虚函数的地址。 &#123; printf(&quot;vptr[%d] = 0x:%p\n&quot;, i, vptr[i]); &#125; //上述循环运行结果： //vptr[0] = 0x:00DF11A4 //vptr[1] = 0x:00DF1320 //vptr[2] = 0x:00DF1334 //vptr[3] = 0x:00000000 //vptr[4] = 0x:69726544 typedef void(*Func)(void); //定义一个函数指针类型 Func f = (Func)vptr[0]; //f就是函数指针变量，vptr[0]是指向第一个虚函数的。 Func g = (Func)vptr[1]; Func h = (Func)vptr[2]; /*Func i = (Func)vptr[3]; Func j = (Func)vptr[4];*/ f(); //Base::f() g(); //Derive::g() h(); //Base::h() //i(); Base *dpar = new Base(); //父类指针 long *pvptrpar = (long *)dpar; long *vptrpar = (long *)(*pvptrpar); for (int i = 0; i &lt;= 4; i++) //循环5次； &#123; printf(&quot;vptr Base[%d] = 0x:%p\n&quot;, i, vptrpar[i]); &#125; //上述循环运行结果： //vptr Base[0] = 0x:00DF11A4 //vptr Base[1] = 0x:00DF117C //vptr Base[2] = 0x:00DF1334 //vptr Base[3] = 0x:00000000 //vptr Base[4] = 0x:65736142 Func fpar = (Func)vptrpar[0]; Func gpar = (Func)vptrpar[1]; Func hpar = (Func)vptrpar[2]; cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; fpar(); //Base::f() gpar(); //Base::g() hpar(); //Base::h() return 1; &#125; 从上面的运行结果来看（注释中已标出），对于子类对象来说，子类中要是有和父类同名的虚函数，则子类中的虚函数就会把父类中的同名虚函数覆盖，同时虚函数表中对应的虚函数地址必然会发生变化（变成子类中虚函数的地址）。但是如果是父类对象，则还是会调用父类中的虚函数（即不会被覆盖）。 接着看下面的代码： 1234567891011121314151617181920212223242526typedef void(*Func)(void); //定义一个函数指针类型Derive derive;long *pvptrderive = (long *)(&amp;derive); long *vptrderive = (long *)(*pvptrderive); //0x00b09b6c &#123;project100.exe!void(* Derive::`vftable&apos;[4])()&#125; &#123;11538847&#125;Func f1 = (Func)vptrderive[0]; //0x00b0119f &#123;project100.exe!Base::f(void)&#125;Func f2 = (Func)vptrderive[1]; //0x00b0150f &#123;project100.exe!Derive::g(void)&#125;Func f3 = (Func)vptrderive[2]; //0x00b01325 &#123;project100.exe!Base::h(void)&#125;Func f4 = (Func)vptrderive[3]; //0x69726544Func f5 = (Func)vptrderive[4]; //0x3a3a6576Derive derive2 = derive; //调用拷贝构造函数long *pvptrderive2 = (long *)(&amp;derive2);long *vptrderive2 = (long *)(*pvptrderive2);Base base = derive; //直接用子类对象给父类对象值，子类中的属于父类那部分内容会被编译器自动区分（切割）出来并拷贝给了父类对象。 //所以Base base = derive;实际干了两个事情： //第一个事情：生成一个base对象 //第二个事情：用derive来初始化base对象的值。long *pvptrbase = (long *)(&amp;base);long *vptrbase = (long *)(*pvptrbase); //0x00b09b34 &#123;project100.exe!void(* Base::`vftable&apos;[4])()&#125; &#123;11538847&#125;Func fb1 = (Func)vptrbase[0]; //0x00b0119f &#123;project100.exe!Base::f(void)&#125;Func fb2 = (Func)vptrbase[1]; //0x00b01177 &#123;project100.exe!Base::g(void)&#125;Func fb3 = (Func)vptrbase[2]; //0x00b01325 &#123;project100.exe!Base::h(void)&#125;Func fb4 = (Func)vptrbase[3]; //0x00000000Func fb5 = (Func)vptrbase[4]; //0x65736142 可以看出，当用子类对象初始化父类对象的时候，编译器给咱们做了一个选择，显然derive的虚函数表指针值并没有覆盖base对象的虚函数表指针值。 总结： （1）一个类只有包含虚函数才会存在虚函数表，同属于一个类的对象共享虚函数表，但是有各自的vptr（虚函数表指针），当然所指向的地址（虚函数表首地址）相同。 （2）父类中有虚函数就等于子类中有虚函数。话句话来说，父类中有虚函数表，则子类中肯定有虚函数表。因为你是继承父类的。并且只要在父类中是虚函数，那么子类中即便不写virtual，也依旧是虚函数。但如果子类只继承自一个父类，则不管是父类还是子类，它们内部都只会有一个虚函数表。 （3）如果子类中完全没有新的虚函数，则我们可以认为子类的虚函数表和父类的虚函数表内容相同。但，仅仅是内容相同，这两个虚函数表在内存中处于不同位置，换句话来说，这是内容相同的两张表。 （4）虚函数表中每一项，保存着一个虚函数的首地址，但如果子类的虚函数表某项和父类的虚函数表某项代表同一个函数（这表示子类没有覆盖父类的虚函数），则该表项所执行的该函数的地址应该相同。 （5）超出虚函数表部分的内容不可知。 三、多重继承虚函数表分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//基类1class Base1&#123;public: virtual void f() &#123; cout &lt;&lt; &quot;base1::f()&quot; &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; &quot;base1::g()&quot; &lt;&lt; endl; &#125;&#125;;//基类2class Base2&#123;public: virtual void h() &#123; cout &lt;&lt; &quot;base2::h()&quot; &lt;&lt; endl; &#125; virtual void i() &#123; cout &lt;&lt; &quot;base2::i()&quot; &lt;&lt; endl; &#125;&#125;;//子类class Derived :public Base1, public Base2&#123;public: virtual void f() //覆盖父类1的虚函数 &#123; cout &lt;&lt; &quot;derived::f()&quot; &lt;&lt; endl; &#125; virtual void i() //覆盖父类2的虚函数 &#123; cout &lt;&lt; &quot;derived::i()&quot; &lt;&lt; endl; &#125; //如下三个我们自己的虚函数 virtual void mh() &#123; cout &lt;&lt; &quot;derived::mh()&quot; &lt;&lt; endl; &#125; virtual void mi() &#123; cout &lt;&lt; &quot;derived::mi()&quot; &lt;&lt; endl; &#125; virtual void mj() &#123; cout &lt;&lt; &quot;derived::mj()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; cout &lt;&lt; sizeof(Base1) &lt;&lt; endl; cout &lt;&lt; sizeof(Base2) &lt;&lt; endl; cout &lt;&lt; sizeof(Derived) &lt;&lt; endl; Derived ins; Base1 &amp;b1 = ins; //多态 Base2 &amp;b2 = ins; Derived &amp;d = ins; typedef void(*Func)(void); long *pderived1 = (long *)(&amp;ins); long *vptr1 = (long *)(*pderived1); //取第一个虚函数表指针。 long *pderived2 = pderived1 + 1; //跳过4字。 long *vptr2 = (long *)(*pderived2); //取第二个虚函数表指针。 Func f1 = (Func)vptr1[0]; //0x00ab15d7 &#123;project100.exe!Derived::f(void)&#125; Func f2 = (Func)vptr1[1]; //0x00ab15f0 &#123;project100.exe!Base1::g(void)&#125; Func f3 = (Func)vptr1[2]; //0x00ab15cd &#123;project100.exe!Derived::mh(void)&#125; Func f4 = (Func)vptr1[3]; //0x00ab15ff &#123;project100.exe!Derived::mi(void)&#125; Func f5 = (Func)vptr1[4]; //0x00ab15eb &#123;project100.exe!Derived::mj(void)&#125; Func f6 = (Func)vptr1[5]; //非正常 Func f7 = (Func)vptr1[6]; Func f8 = (Func)vptr1[7]; Func f11 = (Func)vptr2[0]; //0x00ab15af &#123;project100.exe!Base2::h(void)&#125; Func f22 = (Func)vptr2[1]; //0x00ab15b9 &#123;project100.exe!Derived::i(void)&#125; Func f33 = (Func)vptr2[2]; //非正常 Func f44 = (Func)vptr2[3]; b1.f(); b2.i(); d.f(); d.i(); d.mh(); d.g(); cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl; f1(); f2(); f3(); f4(); f5(); cout &lt;&lt; &quot;-------------&quot; &lt;&lt; endl; f11(); f22(); return 1; &#125; （1）一个对象，如果它的类有多个基类则有多个虚函数表指针（注意是多个虚函数表指针，而不是多个虚函数表）。 （2）在多继承中，对应各个基类的vptr按继承顺序依次放置在类的内存空间中，且子类与第一个基类共用一个vptr(第二个基类有自己的vptr); （3）如上程序中，子类对象ins有两个虚函数表指针，vptr1,vptr2。类Derived有两个虚函数表，因为它继承自两个基类。 （4）子类和第一个基类公用一个vptr（因为vptr指向一个虚函数表，所以也可以说子类和第一个基类共用一个虚函数表vtbl),因为我们注意到了类Derived的虚函数表1里边的5个函数，而g()正好是base1里边的函数。 （5）子类中的虚函数覆盖了父类中的同名虚函数。比如derived::f(),derived::i(); 四、vptr、vtbl创建时机 （1）vptr（虚函数表指针）跟着对象走，所以对象什么时候创建出来，vptr就什么时候创建出来。即运行的时候。实际上，对于这种有虚函数的类，在编译的时候，编译器会往相关的构造函数中增加为vptr赋值的代码，这是在编译期间编译器为构造函数增加的。当程序运行的时候，遇到创建对象的代码，执行对象的构造函数，那么这个构造函数里有给对象的vptr(成员变量)赋值的语句，自然这个对象的vptr就被赋值了。 （2）虚函数表是编译器在编译期间（不是运行期间）就为每个类确定好了对应的虚函数表vtbl的内容。然后也是在编译期间在相应的类构造函数中添加给vptr赋值的代码，这样程序运行的时候，当运行到创建类对象的代码时，会调用类的构造函数，执行到类的构造函数中的给vptr赋值的代码，这样这个类对象的vptr(虚函数表指针)就有值了。 五、普通类包含虚函数时引发的虚函数调用问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class X&#123;public: int x; int y; int z; //X() :x(0), y(0), z(0) X() &#123; //编译器角度 伪码； //vptr = vtbl; //下边的memset会把vptr（虚函数表指针）清0 memset(this, 0, sizeof(X)); cout &lt;&lt; &quot;构造函数被执行&quot; &lt;&lt; endl; &#125; //X(const X &amp;tm) :x(tm.x), y(tm.y), z(tm.z) X(const X &amp;tm) &#123; memcpy(this, &amp;tm, sizeof(X)); cout &lt;&lt; &quot;拷贝构造函数被执行&quot; &lt;&lt; endl; &#125; virtual ~X() &#123; cout &lt;&lt; &quot;析构函数被执行&quot; &lt;&lt; endl; &#125; virtual void virfunc() &#123; cout &lt;&lt; &quot;虚函数virfunc()被执行&quot; &lt;&lt; endl; &#125; void ptfunc() &#123; cout &lt;&lt; &quot;普通函数ptfunc()被执行&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; //X x0; //调用构造函数 ///*x0.x = 100; //x0.y = 200; //x0.z = 300;*/ //x0.virfunc(); //虚函数表指针为null居然可以成功调用虚函数； //X x1(x0); //调用拷贝构造函数 //cout &lt;&lt; &quot;x1.x=&quot; &lt;&lt; x1.x &lt;&lt; &quot; x1.y=&quot; &lt;&lt; x1.y &lt;&lt; &quot; x1.z=&quot; &lt;&lt; x1.z &lt;&lt; endl; //X *px0 = new X(); //px0-&gt;ptfunc(); //正常调用 //px0-&gt;virfunc(); //无法正常调用 //delete px0; //无法正常调用 //new出来的对象，虚函数变得无法正常执行了； int i = 9; printf(&quot;i的地址 = %p\n&quot;, &amp;i); X x0; printf(&quot;ptfunc()的地址=%p\n&quot;, &amp;X::ptfunc); //打印正常的成员函数地址。 //long *pvptrpar = (long *)(&amp;x0); //long *vptrpar = (long *)(*pvptrpar); //printf(&quot;virfunc的地址 = %p\n&quot;, vptrpar[1]);//虚函数virfunc地址 x0.ptfunc(); x0.virfunc(); //不叫多态，属于静态联编，我们推断：这个函数ptfunc()和virfunc()函数，是在编译的就确定好的； X *pX0 = new X(); pX0-&gt;ptfunc(); pX0-&gt;virfunc(); //通过虚函数表指针，找虚函数表，然后从虚函数表中找到virfunc虚函数的地址并调用。这就是多态 //更明白：虚函数，多态，这种概念专门给指针或者引用用的； X &amp;xy = *pX0; xy.virfunc(); X &amp;xy2 = x0; xy2.virfunc(); return 1;&#125; （1）如果一个普通类中包含了虚函数，那么在构造函数中使用如上所示的memset或者拷贝构造函数中使用如上所示的memcpy方法，那么就会出现程序崩溃的情形。 （2）某些情况下，编译器会往类内部增加一些我们看不见但真实存在的成员变量（隐藏成员变量），比如你类中增加了虚函数，系统默认往类对象中增加虚函数表指针，这个虚函数表指针就是隐藏的成员变量。有了这种变量的类，就不是普通的类了。同时，这种隐藏的成员变量的增加(使用)或者赋值的时机，往往都是在执行构造函数或者拷贝构造函数的函数体之前进行。那么你如果使用memset,memcpy，很可能把编译器给隐藏变量的值你就给清空了，要么覆盖了。 （3）静态联编是指：我们编译的时候就能确定调用哪个函数。把调用语句和被调用函数绑定到一起。动态联编是在程序运行时，根据时机情况，动态的把调用语句和被调用函数绑定到一起，动态联编一般旨有在多态和虚函数情况下才存在。 （4）对多态，虚函数，父类，子类。虚函数主要解决的问题父类指针指向子类对象这种情况。如果一个类中只有虚函数，没有继承，那么虚函数和普通函数没有区别，就算虚函数表指针被置空，仍然可通过对象正常调用，因为这是静态联编，不是多态。但是如果用new出来的对象调用，就会失败，因为虚函数表指针为空，找不到虚函数表。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象模型（1） -- 对象]]></title>
    <url>%2F2019%2F08%2F04%2FC-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、类对象所占用的空间 （1）一个空类所占用空间是一个字节，如果有成员变量，就是成员变量占用的内存。为什么空类还要占一个字节的内存？这是因为创建了一个对象就要占用一个字节的地址，就像买房子一样，空房子也是占面积的。 （2）类的成员函数不占用类对象的内存空间，而成员变量占用对象的内存空间。 （3）成员变量是包含在每个对象中的，是占用对象字节的，有多少个对象就有多少个成员变量。而对于成员函数，每个类只诞生一个（跟着类走），而不管你用这个类产生了多少个该类的对象。 二、对象结构的发展和演化 （1）非静态的成员变量(普通成员变量)跟着类对象走（存在对象内部），也就是每个类对象都有自己的成员变量。 （2）静态成员变量跟对象没有什么关系，所以肯定不会保存在对象内部，是保存在对象外面（表示所占用的内存空间和类对象无关）的，所以不计算在类对象sizeof()内。 （3）成员函数：不管静态的还是非静态，全部都保存在类对象之外。所以不管几个成员函数，不管是否是静态的成员函数，对象的sizeof的大小都是不增加的。 （4）虚函数：不管有几个虚函数，sizeof()都是多了4个字节。类里只要有一个虚函数（或者说至少有一个虚函数），这个类就会产生一个指向虚函数的指针。有两个虚函数，那么这个类就会产生两个指向虚函数的指针。而类本身指向虚函数的指针（一个或者一堆）要有地方存放，存放在一个表格里，这个表格我们就称为“虚函数表(virtual table【vtbl】)”。这个虚函数表一般是保存在可执行文件中的，在程序执行的时候载入到内存中来。 （5）虚函数表是基于类的，跟着类走的。对于类对象，这四个字节的增加，其实是因为虚函数的存在；因为有了虚函数的存在，导致系统往类对象中添加了一个指针，这个指针正好指向这个虚函数表，很多资料上把这个指针叫vptr；这个vptr的值由系统在适当的时机赋值（比如构造函数中通过增加额外的代码来给值）。 （6）如果有多个数据成员，那么为了提高访问速度，某些编译器可能会将数据成员之间的内存占用比例进行调整(内存字节对齐)。 （7）不管什么类型指针char *p,int *q;,该指针占用的内存大小是固定的。 三、this指针调整：多重继承 （1）派生类对象是包含基类子对象的。 （2）如果派生类只从一个基类继承的话，那么这个派生类对象的地址和基类子对象的地址相同。 （3）如果派生类对象同时继承多个基类，那么就要注意：第一个基类子对象的开始地址和派生类对象的开始地址相同。后续这些基类子对象的开始地址和派生类对象的开始地址相差多少呢？那就得把前边那些基类子对象所占用的内存空间累加。 （4）调用哪个子类的成员函数，这个this指针就会被编译器自动调整到对象内存布局中对应该子类对象的起始地址那去。 四、构造函数语义 传统认识认为：如果我们自己没定义任何构造函数，那么编译器就会为我们隐式自动定义一个默认的构造函数，我们称这种构造函数为：“合成的默认构造函数”。 事实是：“合成的默认构造函数”，只有在必要的时候，编译器才会为我们合成出来，而不是必然或者必须为我们合成出来。那么编译器会在哪些必要的时候帮助我们把默认的构造函数合成出来呢？ （1）该类没有任何构造函数，但包含一个类类型的成员,而该对象所属于的类有一个缺省的构造函数。这个时候，编译器就会为该类生成一个 “合成默认的构造函数”，合成的目的是为了调用类类型成员所属类里的默认构造函数。 （2）父类带缺省构造函数，子类没有任何构造函数，那因为父类这个缺省的构造函数要被调用，所以编译器会为这个子类合成出一个默认构造函数。合成的目的是为了调用这个父类的构造函数。换句话说，编译器合成了默认的构造函数，并在其中安插代码，调用其父类的默认构造函数。 （3）如果一个类含有虚函数，但没有任何构造函数时，因为虚函数的存在，编译器会给我们生成一个基于该类的虚函数表vftable。此外编译器给我们合成了一个构造函数，调用了父类的构造函数，并且在其中安插代码，把类的虚函数表地址赋给类对象的虚函数表指针（赋值语句/代码）。我们可以把虚函数表指针看成是我们表面上看不见的一个类的成员函数。 （4）当我们有自己的默认构造函数时，编译器会根据需要扩充我们自己写的构造函数代码，比如调用父类构造函数，给对象的虚函数表指针赋值。 （5）如果一个类带有虚基类，编译器也会为它合成一个默认构造函数。虚基类：通过两个直接基类（虚基类）继承同一个间接基类。所以一般是三层 ，有爷爷Grand，有两个爹A,A2，有孙子C。有虚基类结构，编译器为子类和父类都产生了“合成的默认构造函数”。 五、拷贝构造函数语义 传统上，大家认为：如果我们没有定义一个自己的拷贝构造函数，编译器会帮助我们合成 一个拷贝构造函数。 事实上，这个合成的拷贝构造函数，也是在必要的时候才会被编译器合成出来。那编译器在什么情况下会帮助我们合成出拷贝构造函数来呢？这个编译器合成出来的拷贝构造函数又要干什么事情呢？ （1）如果一个类A没有拷贝构造函数，但是含有一个类类型CTB的成员变量m_ctb。该类型CTB含有拷贝构造函数，那么当代码中有涉及到类A的拷贝构造时，编译器就会为类A合成一个拷贝构造函数。编译器合成的拷贝构造函数往往都是干一些特殊的事情。如果只是一些类成员变量值的拷贝这些事，编译器是不用专门合成出拷贝构造函数来干的，编译器内部就干了，即成员变量初始化手法，比如int这种简单类型，直接就按值拷贝过去,编译器不需要合成拷贝构造函数的情况下就帮助我们把这个事情办了。再如类A中有类类型ASon成员变量asubobj，也会递归似的去拷贝类ASon的每个成员变量。 （2）如果一个类CTBSon没有拷贝构造函数，但是它有一个父类CTB，父类有拷贝构造函数，当代码中有涉及到类CTBSon的拷贝构造时，编译器会为CTBSon合成一个拷贝构造函数，调用父类的拷贝构造函数。 （3）如果一个类CTBSon没有拷贝构造函数，但是该类声明了或者继承了虚函数，当代码中有涉及到类CTBSon的拷贝构造时，编译器会为CTBSon合成一个拷贝构造函数 ,往这个拷贝构造函数里插入语句。这个语句的含义是设定类对象的虚函数表指针值。 （4）如果一个类没有拷贝构造函数，但是该类含有虚基类，当代码中有涉及到类的拷贝构造时，编译器会为该类合成一个拷贝构造函数。 六、程序转化语义 程序转化语义主要是理解编译器如何将人类写的代码解析成编译器理解的代码。为此，从两个角度来分析。下面的代码帮助更好的理解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class X&#123;public: int m_i; X(const X &amp;tmpx) &#123; m_i = tmpx.m_i; cout &lt;&lt; &quot;拷贝构造函数被调用&quot; &lt;&lt; endl; &#125; X() &#123; m_i = 0; cout &lt;&lt; &quot;构造函数被调用&quot; &lt;&lt; endl; &#125; ~X() &#123; cout &lt;&lt; &quot;析构函数被调用&quot; &lt;&lt; endl; &#125; void functest() &#123; cout &lt;&lt; &quot;functest()被调用&quot; &lt;&lt; endl; &#125;&#125;;//参数初始化对比//人类角度void func(X tmpx)&#123; return;&#125;//老编译器看func(老编译器角度)void func(X &amp;tmpx)&#123; return;&#125;//返回值初始化对比//人类视角X func()&#123; X x0; //.... return x0; //系统产生临时对象并把x0的内容拷贝构造给了临时对象。&#125;//编译器角度的funcvoid func(X &amp;extra)&#123; X x0; //从编译器角度，这行不调用X的构造函数 //... //... extra.X::X(x0); return;&#125; 我们写的代码，编译器会对代码进行拆分，拆分成编译器更容易理解和实现的代码。看一看编译器是如何解析这些代码的。 （1）定义时初始化对象 12345678910//程序员视角X x0;x0.m_i = 15;X x1 = x0; X x2(x0);X x3 = (x0);//切换到编译器角度，编译器会拆分成两个步骤(编译器视角)X x100; //步骤一：定义一个对象，为对象分配内存。从编译器视角来看，这句是不调用X类的构造函数。x100.X::X(x0); //步骤二：直接调用对象的拷贝构造函数去了； （2）参数的初始化 12345678//程序员视角/现代编译器func(x0);//老编译器视角X tmpobj; //编译器产生一个临时对象tmpobj.X::X(x0); //调用拷贝构造函数func(tmpobj); //用临时对象调用functmpobj.X::~X(); //func()被调用完成后，本析构被调用。 （3）返回值初始化 123456789101112131415161718192021222324252627//程序员角度X my = func();//编译器对上述代码的理解(编译器角度)X my; //不会调用X的构造函数func(my);//利用返回值调用成员函数//人类视角func().functest();//切换到编译器视角X my; //不会调用X的构造函数(func(my), my).functest(); //逗号表达式：先计算表达式1，再计算表达式2，整个逗号表达式的结果是表达式2的值；//利用函数指针调用成员函数//程序员视角X(*pf)(); //定义个函数指针pf = func;pf().functest();//编译器视角X my; //不调用构造函数void (*pf)(X &amp;);pf = func;pf(my);my.functest(); 七、拷贝构造续与深浅拷贝 （1）当编译器面临用一个类对象作为另外一个类对象初值的情况，各个编译器表现不同。但是所有编译器都为了提高效率而努力。我们也没有办法确定我们自己使用的编译器是否一定会调用拷贝构造函数。 （2）拷贝构造函数不是必须有的，如果只有一些简单的成员变量类型，int,double，你会发现你根本不需要拷贝构造函数，编译器内部本身就支持成员变量的bitwise(按位)copy，即按位拷贝。 （3）当需要处理很复杂的成员变量类型的时候。因为我们增加了自己的拷贝构造函数，导致编译器本身的bitwise拷贝能力失效，它会调用我们自己的拷贝构造函数，因此如果你增加了自己的拷贝构造函数后，就要对各个成员变量的值的初始化负责了。 （4）我们自己创建内存，把目标对象的内存内容拷贝过来，叫深拷贝，例如下面的程序。相反，上述编译器做的拷贝叫浅拷贝。（注意：涉及到指针的时候，必须用深拷贝，不能浅拷贝，否则指针所指的内存会被析构两次，导致错误） 12345678910111213class X&#123;public: int m_i; int *p_mi; X(const X&amp; tmpx) &#123; p_mi = new int(100); //自己申请内存 memcpy(p_mi, tmpx.p_mi, sizeof(int)); //拷贝 m_i = tmpx.m_i; cout &lt;&lt; &quot;拷贝构造函数被调用&quot; &lt;&lt; endl; &#125;&#125;; 八、初始化列表 （1）必须使用初始化列表的情况 （a）这个成员是个引用 （b）是个const类型成员 （c）如果这个类是继承一个基类，并且基类中有构造函数，这个构造函数里边还有参数。 （d）如果成员变量类型是某个类类型，而这个类的构造函数带参数时。 （2）使用初始化列表的优势。除了必须用初始化列表的场合，我们用初始化列表还有什么其他目的？ 有，就是提高程序运行效率。对于类类型成员变量放到初始化列表中能够比较明显的看到效率的提升，但是如果是个简单类型的成员变量比如int m_test,其实放在初始化列表或者放在函数体里效率差别不大。（提醒：成员变量初始化尽量放在初始化列表里，显得高端，大气上档次） （3）初始化列表中的代码可以看作是被编译器安插到构造函数体中的，只是这些代码有些特殊。这些代码是在任何用户自己的构造函数体代码之前被执行的。所以要区分开构造函数中的用户代码和编译器插入的初始化所属的代码。 （4）初始化列表中变量的初始化顺序是变量的定义顺序，而不是在初始化列表中的顺序。不建议在初始化列表中进行两个都在初始化列表中出现的成员之间的初始化（例如：m1和m2都在初始化列表中，不建议用m1来初始化m2，或用m2初始化m1）。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL源码剖析（3）]]></title>
    <url>%2F2019%2F07%2F30%2FSTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面的话 前一篇博文介绍了迭代器，接下来介绍一下STL的大部头–容器。这一篇首先介绍序列式容器。 容器概览与分类 STL的容器是将运用最广的一些数据结构实现出来。众所周知，常用的数据结构不外乎 array, list, tree, stack, queue, hash table, set, map 等。根据数据在容器中的排列特性，这些数据结构分为序列式和关联式两种，因此容器也分为序列式容器和关联式容器。序列式容器有：array, vector, heap, priority-queue, list, slist, deque, stack, queue。关联式容器有：rb-tree, set, map, multiset, multimap, hashtable, hash-set, hash-map, hash-multiset, hash_multimap。 其中，heap是以vector为底层来实现的，priority-queue又是以heap为底层实现。而stack和queue都是以deque为原型通过配接器配接而来。关联式容器中的 set map multiset multimap 都是以 rb-tree 为底层实现, hash-set hash-map hash-multiset hash_multimap又都是以 hashtable 为底层实现。 需要注意的是，序列式容器都可序，但未必有序。接下来分别介绍各容器。 vectorvector概述 vector 的数据安排以及操作方式与 array 非常相似。两者唯一的差别在于空间的运用的灵活性。array 是静态空间，一旦配置了就不能改变，要换一个大（小）一点的空间，首先得配置一块新空间，然后从旧址一一搬往新址，再把原来的空间释放。vector 是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。因此使用 vector，我们再也不必因为害怕空间不足而一开始就要求一个大块头 array 了。 vector的迭代器 vector 维护的是一个连续的线性空间，所以不论其元素型别为何，普通指针都可以作为 vector 的迭代器而满足所有必要条件。因此 vector 的迭代器是普通指针。vector 支持随机存取，而普通指针也正有这样的能力，所以 vector 提供的是 random access iterators。 vector的数据结构 vector的数据结构比较简单，是线性连续空间。它内部维护有三个迭代器（指针）：start表示目前使用空间的头，finish表示目前使用空间的尾，end_of_storage表示目前可用空间的尾。 当我们以push_back()将新元素插入于vector尾端时，该函数首先检查是否还有备用空间，如果有就直接在备用空间上构造元素，并调整迭代器 finish，使 vector 变大。如果没有备用空间了，就扩充空间，即动态增加大小，这并不是在原空间之后接续新空间（因为无法保证原空间之后有可供配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对 vector 的任何操作，一旦引起空间重新配置，指向原 vector 的所有迭代器就都失效了。 listlist概述 list是一个链表，是由一个一个节点组成的，每一个节点结构内部有两个指针，分别指向前一个节点和后一个节点，还有一个数据域来存放节点数据。list的好处是每次插入或删除一个元素，就配置或释放一个元素空间。因此，list对空间的利用率很高，一点也不浪费。而且，对于任何位置的元素插入或元素移除，list永远是常数时间。 list的迭代器 list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在存储空间中连续存在。list迭代器必须有能力指向list的节点，并且有能力进行正确的递增、递减、取值、成员存取等操作。也就是说，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取用的是节点的成员。 由于STL的list是一个双向链表。迭代器必须具备前移、后移的能力，所以list提供的是bidirectional iterators。list在插入和接合操作的时候都不会造成原有的list迭代器失效，在删除操作的时候只有指向被删元素的那个迭代器失效，其他迭代器不受任何影响。 list的数据结构 list不仅是一个双向链表，而且还是一个环状双向链表，所以它只需要一个指针，便可完整表现整个链表。如果让该指针（注意：此指针并非前面所说的节点内部的指针，这里的指针是指向每个节点的指针）指向刻意置于尾端的一个空白节点，便能符合STL对于“前闭后开”区间的要求，成为list迭代器。list作为双向链表，在头部和尾部都可以插入数据。 dequedeque概述 deque是一种双向开口的连续线性空间。所谓双向开口，意思就是可以在头尾两端分别做元素的插入和删除操作。deque和vector的不同主要有两点：（1）vector是单向开口的空间，虽然也能在头部插入元素，但是效率极差，而deque可以在常数时间内对头部进行插入或移除操作。（2）deque没有容量的概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。而vector是因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间。 deque表面上看起来是连续空间，其实它内部是将一段一段连续空间通过中控器的操作接合起来，一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，使人们使用起来感觉像是在操作一段连续空间。它还提供了随机存取接口，避免了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器结构。 deque采用一块所谓的map作为主控，这里的map其实是一小块连续空间，其中每个元素都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的存储空间主体。通过看源码，可以发现map其实是一个指针，所指之物又是一个指针，指向另一块空间。 deque的迭代器 deque的迭代器首先必须能够指出缓冲区在哪里，其次它必须能够判断自己是否已经处于所在缓冲区的边缘，如果是，一旦前进或后退时就必须跳跃至下一个或上一个缓冲区。因此，deque的迭代器应该包括四个指针：cur指向该迭代器所指缓冲区中的当前元素，first指向该迭代器所指缓冲区的头部，last指向该迭代器所指缓冲区的尾部，node指向管控中心，用来找到迭代器所指的缓冲区。 deque的数据结构 deque除了维护一个先前说过的指向map的指针外，也维护start,finish两个迭代器，分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素的下一位置。此外，它当然也必须记住目前的map大小。因为一旦map所提供的节点不足，就必须重新配置更大的一块map。 stack和queuestack stack是一种先进后出的数据结构，它只有一个出口。stack允许新增元素、移除元素、取得顶端元素。但除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不允许有遍历行为。STL中以deque作为缺省情况下的stack底部结构。 stack所有元素的进出都必须符合先进后出的条件，只有stack顶端的元素，才有机会被外界取用。stack不提供走访功能，也不提供迭代器。另外，除了deque外，list也可以作为stack的底部容器。 queue queue是一种先进先出的数据结构。他有两个出口，允许新增元素、移除元素、从最底端加入元素、取得最顶端的元素。但是除了最底端加入、最顶端取出外，没有其他任何办法可以存取queue的其他元素。即queue不允许有遍历行为，queue也没有迭代器。STL默认将deque作为queue的底部容器，当然list也可以作为queue的底部容器。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL源码剖析（2）]]></title>
    <url>%2F2019%2F07%2F28%2FSTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面的话 上一篇博文写了STL的分配器，这一篇着重介绍一下迭代器。 迭代器介绍 我们都知道，STL中将容器和算法分离开来，彼此独立设计，以达到泛化的效果，而在使用的时候又需要将这两种东西撮合到一起，实现这个撮合功能的就是迭代器。也就是说迭代器是介于容器与算法之间的一种东西，它可以把实现某个算法所需要的容器里面的信息传递给算法，从而达到一种“桥梁”的效果。 迭代器可以看作是一种“智能指针”。它是一种行为类似指针的对象，而指针的各种行为中最常见的也是最重要的便是内容提取和成员访问，因此，迭代器最重要的编程工作就是对 operator✳ 和 operator-&gt;进行重载。关于这一点，其实跟真证的智能指针（share_ptr等）没有区别。既然迭代器实现的功能和指针一样，那为什么不直接用指针来代替迭代器呢？何必还要多此一举。这是因为，指针只能在连续空间上前进和后退，而不能随意的跳转，例如在双向链表的每一个节点中，都有两个指针，分别指向前一个元素和后一个元素，除此之外每个节点中还有另外的空间来存储数据，当指针+1的时候，它只能在该节点的连续空间上移动，而当设计好相应功能的迭代器+1的时候，可以直接跳到下一个节点，也就是说，迭代器可以实现跨区域跳转，这就是它与指针之间最大的不同。 迭代器的相应型别 我们发现，在算法中运用迭代器时，会用到迭代器的相应型别，什么是相应型别？迭代器所指之物的型别就是其中的一种。常用迭代器的相应型别有五种，分别是：value type; difference type; reference type; pointer type; iterator_category.接下来分别介绍这五种相应型别。 value type 所谓 value type，就是指迭代器所指对象的型别，任何一个打算与 STL 算法有完美搭配的类，都应该定义自己的 value type 内嵌型别。 difference type difference type 用来表示两个迭代器之间的距离，因此它也可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其最大容量，如果一个泛型算法提供计数功能，例如 STL 的 count(), 其传回值就必须使用迭代器的 difference type。 reference type 在 C++ 中，函数要传回左值，都是以传引用的方式进行，所以当 p 是个可修改值的迭代器时，如果其 value type 是 T,那么 ✳p 的型别不应该是 T，应该是 T&amp;.同理，如果 p 是一个不可修改值的迭代器，其 value type 是 T，那么 ✳p 的型别不应该是 const T,而应该是 const T&amp;。这里讨论的 ✳p 的型别，即所谓的 reference type。 pointer type 指针和引用有着非常密切的关系。如果传回一个左值，令它代表 p 所指之物是可能的，那么传回一个左值，令它代表 p 所指之物的地址也一定可以。也就是说，我们能够传回一个指针，指向迭代器所指之物。 iterator_category 这个型别表明了迭代器的类别。根据移动特性和施行操作，迭代器被分为五类：input iterator（只读，即这种迭代器所指的对象不允许外界改变）；output iterator（只写，即该迭代器所指的对象只能被外界改变，不能读取）；forward iterator（单向读写）；bidirectional iterator（双向读写）；random access iterator（随机读写）。 以上五种迭代器的类别，前三种支持 operator++，第四种再加上 operator–，第五种则涵盖所有指针算术能力，包括 p+n, p-n, p[n], p1-p2, p1&lt;p2。在设计算法时，应该尽量对迭代器的类型做一个明确的规定，这样才能在不同情况下提供最大的效率。假设有个算法可接受 forward iterator ,你给它传一个 random access iteator 进去，它当然也会接受，因为一个 random access iteator 必然是一个 forward iteator,但是从效率上来讲，这并不是最佳的方案。 Traits编程技法 traits用来提取对象的型别，对应的模板参数不管是泛化版本还是特化版本，通通都能准确的萃取出来。如果传进来的参数 I 定义有自己的 value type，那么通过 traits,萃取出来的 value type 就是 I::value type。如果是特化版本，例如 T✳，则萃取出来的 value type 就是 T。特别注意，const T✳，萃取出来后也是 T 而非 const T,这是因为我们的本意就是声明一个临时变量，使之与迭代器的 value type 相同，而如果声明一个无法赋值的变量，没有什么作用，因此，对于 const 类型的变量，萃取出来的 value type就会变成 non-const类型。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL源码剖析（1）]]></title>
    <url>%2F2019%2F07%2F26%2FSTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面的话 近段时间看了侯捷老师的《STL源码剖析》，看第一遍的时候一头雾水，反复多看几遍，似乎明白了一些。因此将学到的知识做一个记录，也算是记录自己的学习过程。本系列博客主要记录一些宏观理解性的东西，具体的代码实现还是要仔细品味原书。 概览 STL即C++标准模板库，主要由六大部件组成，分别是：分配器、容器、迭代器、算法、仿函数、配接器。这六大部件之间的交互关系表现为：容器通过分配器取得数据存储空间，算法通过迭代器存取容器的内容，仿函数可以协助算法完成不同的策略变化，配接器可以修饰或套接仿函数、迭代器、容器等。 在讲述这些主要部件之前，先来了解一下面向对象编程和泛型编程，面向对象编程（Object-Oriented programming，简称OOP）企图将数据和处理数据的方法放到一起，例如，在C++的类中，一般会有成员变量和处理成员变量的成员函数，在需要使用的时候创建一个对象，然后以对象来调用它们。而泛型编程（Generic Programming,简称GP）是将数据和处理方法分离开来，这里的处理方法通常是全局函数，例如STL中的算法和容器，两者互不影响，需要的时候通过迭代器来传递信息。 好了，接下来就从这六大部件出发，了解STL的内部关系。这篇博文主要记录分配器的重点。 分配器（allocators） allocator主要是用来管理存储空间，它当中的 allocate() 调用 operator new() 来分配空间，其中 operator new() 中又调用了C语言中的 malloc() 函数，而 deallocate() 则调用了operator delete(),其中，operator delete() 又调用了 free() 来释放内存。以上谈的这种分配器是标准规范下的实现方法。而SGI STL有一种默认的分配器 alloc ，它的每一个容器都已经指定其缺省的空间分配器为 alloc，例如下面的 vector 声明： template &lt;class T, class Alloc = alloc&gt; class vector{…}; 这其中就是缺省使用的 alloc 为分配器。由于调用 malloc() 只会寻找整片比较大的空间，对于一些小型区块，可能造成内存浪费的问题,因此，SGI设计了双级分配器，第一级分配器直接使用 malloc() 和 free()，第二级分配器则视情况采用不同的策略：当配置区块超过128字节时，视之为 “足够大”，便调用第一级分配器 ，当分配区块小于128字节时，视之为 “过小”，为了降低额外负担（合理利用资源），就使用第二级分配器。 而第二级分配器的具体实现是以内存池管理的形式，每次配置一块大内存，然后维护对应的自由链表（可增加，也可删减），下次如果再有相同大小的内存需求，就直接从自由链表中取出，如果使用方释放了小块内存，则由分配器回收到对应的链表中。为了方便管理，SGI的第二级分配器会主动将任何小额区块的内存需求上调至8的倍数（例如使用者需要30字节，就自动调整为32字节），并维护16个自由链表，各自管理的大小分别为：8，16，24，32，40，56，64，72，80，88，96，104，112，128字节的小额区块（例如：第一个链表节点就管理空间内所有大小为8字节的小区快，第二个节点管理所有大小为16字节的小区快，以此类推）。 因此，整个的内存分配释放过程即可归纳为如下流程：分配器拥有标准接口函数 allocate()，此函数首先判断区块的大小，大于128字节就调用第一级分配器，小于128字节就检查对应的自由链表。如果自由链表内有可用的区块，就直接拿来用，如果没有可用的区块，就将区块大小上调至8的倍数，然后重新填充空间。 在释放的时候，同样由分配器的标准接口函数 deallocate() 首先判断区块大小，大于128字节就调用第一级分配器，小于128字节就找出对应的自由链表，将区块回收。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2019%2F07%2F13%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[写博客的想法是怎么产生的前两天在B站上偶然看见一个免费搭建个人博客的教程，于是产生了兴趣。尝试去搜索了一下，竟然发现有好多搭建博客的方法，实在是感觉自己好low，不过，总归现在发现还不算太晚（强行安慰。。）于是按照搜索的几种方法都进行了尝试，最终选择了用 hexo 配合 github 搭建了第一个属于自己的个人博客（正是此博客）。虽然现在看起来有点low，但是基本功能还算齐全，其他华丽的功能有待开发。 写博客的目的博客站点搭建好了，当然也要开始养成写博客的习惯了。之前在网上搜索一些问题的时候总是能看到各种大佬级别的博客，都写得特别好，虽然我也有过写博客的想法，但是一直没有付诸行动，这次搭建了自己的站点，再不写点就说不过去了，总不能就光秃秃的一个页面，什么内容也没有吧。所以借着这次机会，总算能治一治我的拖延症了。至于本博客的目的，就当是记录自己的生活，学习过程。如果能帮到别人，那自然是更好。 博客内容对于博客内容，我初步打算分为以下几个类别：生活、技术、读书笔记等。生活类的文章主要谈一些我所经历过的值得记录的事情以及感想；技术方面主要就是在学习过程中的一些积累（这方面可能会写的比较多一点）。读书笔记则会在我每读完一本书的时候做一些总结，方便以后查阅（主要是指技术书籍）。当然后续还有其他有趣的版块分类，我也会加进去。 期待的样子 我所期待的博客当然是不仅能够连贯地记录自己的生活，而且能够利用自己的知识帮助更多的人。然而，道理我们都懂，一口吃不成胖子，而且万事开头难，所以要一步一步来，努力把它打造成自己喜欢的样子。]]></content>
      <categories>
        <category>生活杂谈</category>
      </categories>
      <tags>
        <tag>生活杂谈</tag>
      </tags>
  </entry>
</search>
