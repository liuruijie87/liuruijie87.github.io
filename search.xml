<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法积累]]></title>
    <url>%2F2019%2F11%2F20%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[#贪心算法 ##思想 假设一个问题比较复杂，暂时找不到全局最优解，那么我们可以考虑把原问题拆成几个小问题（分而治之思想），分别求每个小问题的最优解，再把这些“局部最优解”叠起来，就“当作”整个问题的最优解了。 使用贪心算法的前提： 1、原问题复杂度过高； 2、求全局最优解的数学模型难以建立； 3、求全局最优解的计算量过大； 4、没有太大必要一定要求出全局最优解，“比较优”就可以。]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识点]]></title>
    <url>%2F2019%2F11%2F12%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[#进程 1、进程就是一个程序的执行过程。 2、只有进程从内核态转移到用户态时，才可能发生抢占，进程在内核态下运行是不会被抢占的。 3、多线程是指操作系统在单个进程内支持多个并发执行路径的能力。 4、进程中所有线程共享该进程的状态和资源，它们驻留在同一块地址空间中，并且可以访问到相同的数据。当一个线程改变了内存中的一个数据项时，其他线程在访问该数据项时能看到变化后的结果。 5、在大多数操作系统中，独立进程间的通信通常需要内核的介入，以提供保护和通信所需要的机制。但是由于在同一个进程中的线程共享内存和文件，它们无需调用内核就可以通信。 6、进程的终止会导致进程中所有线程的终止。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[effective C++（2）]]></title>
    <url>%2F2019%2F09%2F30%2Feffective%20C%2B%2B%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.如果你打算在一个内含引用的类内支持赋值操作，你必须自己定义拷贝赋值操作符。 2.如果某个基类将拷贝赋值操作符声明为private，编译器就会拒绝为其子类生成一个拷贝赋值操作符。 3.当子类对象经由一个基类指针被删除，而该基类带着一个非虚析构函数，则在实际执行的时候，对象的子类部分没被销毁。将基类的析构函数声明为虚函数之后，子类的析构函数也自动成为虚析构函数，在主函数中基类指针指向的是派生类对象，当delete释放指针所指向的存储空间时，会执行派生类的析构函数，派生类的析构函数执行完之后会紧接着执行基类的析构函数，以释放从基类继承过来的成员变量所消耗的资源。 4.auto_ptrs有个不寻常的性质，若通过拷贝构造或拷贝赋值运算符复制它们，它们会变成null，而复制所得的指针将取得资源的唯一拥有权。 5.应该尽量延后变量的定义，直到能够给它初值实参为止，因为这样不仅能够避免构造和析构非必要对象，还可以避免毫无意义的默认构造行为。 6.将大多数inline限制在小型、频繁调用的函数身上。 7.public继承意味着“is a”的关系，虚函数意味着接口必须被继承，非虚函数意味着接口和实现都必须被继承。 8.private继承使得基类所有成员在子类中的访问权限变为private。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++零碎知识点]]></title>
    <url>%2F2019%2F09%2F28%2FC%2B%2B%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1、逗号表达式是将括号中所有表达式的值算出来，但是只使用最后一个表达式的值。 2、构造函数是可以私有化的，但一般不会这样做，因为私有化的构造函数不能被new到，并且类不能通过该私有构造函数初始化（可以调用静态方法初始化）。 3、一个类中可以有任意个构造函数（可以函数重载），但只能有一个析构函数。无论何时，只要类的对象被创建，就会执行构造函数。 4、类的静态数据成员只能在类内声明，类外定义和初始化。因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。const的静态成员可以在类内初始化，是因为它既然是const的，那后面的程序就不会再去试图初始化了。 5、当用#include“file.h”时，先搜索当前工作目录，如果没有，再去搜索标准库，库没有再搜索资源库；当用#include&lt;file.h&gt;时，编译器先从标准库开始搜索，如果没再搜索资源库目录，若还未找到则搜索当前工作目录。 6、字符数组的复制要用strcpy()函数,不能直接用赋值操作符赋值。不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。 7、数组名就是数组首元素的地址，在用scanf函数输入的时候，不用加&amp;。 8、定义数组时可以对第一维的长度不指定，但第二维的长度不能省去。 9、C++运算符是有优先级的，一般是算术运算符&gt;关系运算符&gt;逻辑运算符&gt;条件运算符，所以运算符顺序是!（一元算术运算符）&gt; !=（关系运算符）&gt; &amp;&amp;（逻辑运算符）&gt; ?:（条件运算符） 10、内存对齐的3大规则: （1）对于结构体的各个成员，第一个成员的偏移量是0，排列在后面的成员其当前偏移量必须是当前成员类型的整数倍。 （2）结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍。 （3）如程序中有#pragma pack(n)预编译指令，则所有成员对齐以n字节为准(即偏移量是n的整数倍)，不再考虑当前类型以及最大结构体内类型。 11、✳是scanf函数中的一种修饰符，表示忽略该输入项，使用方法为：放在%与格式d（或者s，c等）之间，如：scanf(“%x%✳d%o”,&amp;x,&amp;y); 并且，scanf不能指明浮点数的精度。 12、子类实现父类虚函数叫重写，不叫重载。父类有纯虚函数，子类可以不实现，此时子类仍是抽象类。 13、继承类构造函数中，成员初始化列表同时出现对虚基类和非虚基类构造函数的调用时，虚基类的构造函数先于非虚基类的构造函数执行。 14、C语言中&amp;&amp;是一种双目运算符，表示与运算，而当左边所给表达式或变量为0时，不再计算右侧，整个表达式为零。 15、C语言中有数字三种表示：十进制、八进制(0开头)、十六进制(0x开头)。 16、内联函数是指用inline关键字修饰的函数。在类内定义的函数被默认成内联函数。内联函数从源代码层看，有函数的结构，而在编译后，却不具备函数的性质。内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处。编译时，类似宏替换，使用函数体替换调用处的函数名。一般在代码中用inline修饰，但是能否形成内联函数，需要看编译器对该函数定义的具体处理。 17、结构化程序由三种基本结构组成，三种基本结构组成的算法只能完成符合结构化的任务。 18、字符数组整体输入输出只是库函数里面用循环来完成一个一个元素的输入输出的，宏观上看上去就成了整体输入输出了。本质上说，与整型数组单个元素输入输出并没有区别，差别在于整型数组并不知道什么位置终止，需要人为地控制输入输出终止的条件，字符数组则很简单，输出默认’\0’终止，输入则默认空白字符或者换行。 19、read是UNIX或类UNIX系统中的系统函数，而fread才是C库里面的库函数。 20、在类定义时，无法使用构造函数，因而无法完成对象的初始化，类还没有定义完，不能初始化对象。只有在定义类对象时才会调用构造函数。 21、一般成员变量需要在类内进行初始化。静态成员变量必须在类外初始化，int型静态成员常量在类中初始化。 22、由于类的构造次序是由基类到派生类，所以在构造函数中调用虚函数，这个虚函数不会呈现出多态；相反，类的析构是从派生类到基类，当调用继承层次中某一层次的类的析构函数时往往意味着其派生类部分已经析构掉，所以也不会呈现出多态。（effeetive c++ 条款9）。 23、虚函数可以声明为inline，因为加上inline只是我们对编译器的一种建议，是否为inline还得看编译器的选择。相反，内联函数不能为虚函数，因为函数的内联属性是在编译器确定的，是静态行为，而虚函数的性质是在运行期确定的，是动态行为，二者是矛盾的，所以要想作为内联函数，就不要将它写成虚函数。 24、在C中使用malloc时不需要强制类型转换，因为在C中从void※到其他类型的指针是自动隐式转换的；在C++中使用malloc时必须要强制类型转换，否则会报错，因为C++是不支持void※类型隐式转换为其他类型的，但在c++中一般用new而不用malloc。malloc有一个参数。 25、宏定义不做语法检查。预处理是在编译之前的处理，而编译的工作之一便是语法检查，所以预处理不做语法检查。 26、C++中引入友元函数，是为在该类中提供一个对外（除了他自己意外）访问的窗口;这个友元函数不属于该类的成员函数，他是定义在类外的普通函数，只是在类中声明该函数可以直接访问类中的private或者protected成员。 27、使用友元函数注意的要点： 1）类中通过使用关键字friend来修饰友元函数，但该函数并不是类的成员函数，其声明可以放在类的私有部分，也可放在共有部分。友元函数的定义在类体外实现，不需要加类限定。 2）一个类中的成员函数可以是另外一个类的友元函数，而且一个函数可以是多个类友元函数。 3）友元函数可以访问类中的私有成员和其他数据，但是访问不可直接使用数据成员，需要通过对对象进行引用。 4）友元函数在调用上同一般函数一样，不必通过对对象进行引用。 28、程序占用三种类型的内存：静态内存、栈内存、堆内存； 静态内存：用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。 栈内存：用来保存定义在函数内的非static对象。 堆内存：在程序运行时分配。 分配在静态内存或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。动态对象的生存周期由程序（用户）来控制。 29、数组指针和指针数组的区别： 指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身的大小决定，每一个元素都是一个指针，在32 位系统下任何类型的指针永远是占4 个字节。它是“储存指针的数组”的简称。 数组指针：首先它是一个指针，它指向一个数组。在32位系统下任何类型的指针永远是占4个字节，至于它指向的数组占多少字节，不知道，具体要看数组大小。它是“指向数组的指针”的简称。 30、C语言中实数常数的科学表示法规定格式为：“实数e整数”或“实数E整数”，其中幂是整数，不能写成实数。e(或E)前后的实数和整数都不能省略掉。C语言规定。0开头的是八进制数，0x(0x)开头的是十六进制数。而八进制数数字是0～7，出现8是错误的。实数的小数点前后的数字都可以不写。]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>C++知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[effective C++（1）]]></title>
    <url>%2F2019%2F09%2F17%2Feffective%20C%2B%2B%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[01.C++总体来说包含四大部分内容，分别是：C语言部分（没有模板、异常、重载等概念）；面向对象部分（类、封装、继承、多态、虚函数等）；泛型编程部分（模板技术）；STL（容器、算法、迭代器等）。 02.对单纯常量，尽量以const对象或enums代替#define，因为宏定义是预处理器干的活，宏定义的记号名称有可能未被编译器看到，也许在编译器开始处理源码之前它就被预处理器移走了，因此编译会出错。而如果使用const等定义一个常量，编译器是一定会看到的，当然就会进入记号表内。 03.对于class专属常量，为了将常量的作用域限制于class内，必须让该常量成为class的一个成员。而为确保此常量至多只有一份实体，必须让它成为一个static成员。如下： 12345678class A&#123;private: static const int Num = 5; //常量声明式 int scores[Num]; ... &#125;;const int A::Num; //Num的定义 上面程序中，在声明的时候已经给常量做了初始化，对于class的static类型的专属常量，只要不取它们的地址，或者不需要用到定义式，则不提供定义式也可以，因为在声明的时候已经给了初值，所以在定义式中不可以再设初值。 04.对于形似函数的宏，最好用inline函数替换#define。 05.const修饰指针的时候，如果const出现在星号左边，表示被指物是常量，如果出现在星号右边，表示指针自身是常量，如果出现在星号两边，表示被指物和指针两者都是常量。注意：当被指物是常量时，const写在类型前和类型后都可以。 06.声明STL的迭代器为const和声明指针为const是一样的操作，但是声明迭代器所指物为const需要用const_iterator。 07.non-const成员函数可以调用const成员函数，反之则不行。 08.确保对象在使用之前已经被初始化，读取未初始化的值会导致不明确的行为。 09.对于大多数类型而言，比起先调用默认构造函数后再调用拷贝赋值操作符，单只调用一次拷贝构造函数是比较高效的。对于内置类型来说，其初始化和赋值的成本相同，但为了一致性，最好也通过初始值列表来初始化。 10.如果成员变量是const或引用，则必须初始化，不能被赋值。 11.成员变量的初始化顺序是以其声明顺序被初始化的，并且父类的变量先初始化，再子类。 12.如果某编译单元内的某个全局static对象的初始化使用了另一编译单元内的某个全局static对象，它所用到的这个对象可能尚未被初始化，因为C++对“定义于不同编译单元内的全局static对象”的初始化次序并无明确定义。为解决此问题，可以用一个函数来代替这个全局对象。如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//有问题的代码class FileSystem&#123;public: ... std::size_t num() const; ...&#125;;extern FileSystem tfs; //给客户使用的对象class Directory&#123;public: Directory(params); ...&#125;;Directory::Directory(params)&#123; ... std::size dis = tfs.num(); //使用tfs对象 ...&#125;Directory tempDir(params);//修改后的代码class FileSystem&#123;public: ... std::size_t num() const; ...&#125;;FileSystem&amp; tfs() //用该函数替换tfs对象&#123; static FileSystem fs; return fs;&#125;class Directory&#123;public: Directory(params); ...&#125;;Directory::Directory(params)&#123; ... std::size dis = tfs().num(); //改用tfs() ...&#125;Directory&amp; tempDir() //用该函数替换tempDir对象&#123; static Directory td; return td;&#125;]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四年的青春，我们的故事还在继续]]></title>
    <url>%2F2019%2F08%2F14%2F%E6%88%91%E4%BB%AC%E7%9A%84%E6%95%85%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[今天学会了插入图片，让我来试一波吧，哈哈哈哈哈…… 初次约会，多多关照 一起吃火锅 一起看灯展 一起去海滩 一起去海滩+1 一起去海滩+2 毕业了… 一起逛北京]]></content>
      <categories>
        <category>生活杂谈</category>
      </categories>
      <tags>
        <tag>生活杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象模型（5） -- 对象构造语义学]]></title>
    <url>%2F2019%2F08%2F13%2FC%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%885%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、继承体系下的对象构造步骤及虚函数调用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class A&#123;public: A() &#123; printf(&quot;A this = %p\n&quot;, this); cout &lt;&lt; &quot;A::A()&quot; &lt;&lt; endl; &#125; virtual ~A() &#123;&#125; virtual void myvirfunc() &#123;&#125; virtual void myvirfunc2() &#123;&#125;&#125;;class B:public A&#123;public: B() &#123; printf(&quot;B this = %p\n&quot;, this); cout &lt;&lt; &quot;B::B()&quot; &lt;&lt; endl; &#125; virtual ~B() &#123;&#125; virtual void myvirfunc() &#123;&#125; virtual void myvirfunc2() &#123;&#125;&#125;;class C:public B&#123;public: C():m_c(11) &#123; myvirfunc(); //构造函数中，这里没有走虚函数表，而是直接通过虚函数地址，直接调用这个虚函数（静态方式调用） myvirfunc1(); //虚函数中再调虚函数，走虚函数表 printf(&quot;C this = %p\n&quot;, this); cout &lt;&lt; &quot;C::C()&quot; &lt;&lt; endl; &#125; virtual ~C() &#123;&#125; virtual void myvirfunc() &#123;&#125; virtual void myvirfunc1() &#123; myvirfunc2(); &#125; virtual void myvirfunc2() &#123;&#125; int m_c;&#125;;int main()&#123; C cobj; C *mycobj = new C(); mycobj-&gt;myvirfunc(); //代码实现上的多态 return 1;&#125; （1）继承关系为：C继承于B，B继承于A。当定义一个对象的时候，构造函数的调用顺序为：类A的构造函数、类B的构造函数、类C的构造函数。 （2）当类中有虚函数，并且在构造函数中调用时，如果被调用虚函数里面没有虚函数，则不是走虚函数表调用，而是直接通过虚函数地址静态调用。如果被调用虚函数里面再调用其他虚函数，则就会走虚函数表调用。 二、对象拷贝、析构函数对象的拷贝行为 （1）如果我们不写自己的拷贝构造函数和拷贝赋值运算符，编译器也会有默认的对象拷贝和对象赋值行为。 （2）当我们提供自己的拷贝赋值运算符和拷贝构造函数时，我们就接管了系统默认的拷贝行为，此时，我们有责任在拷贝赋值运算符和拷贝构造函数中写适当的代码，来完成对象的拷贝或者赋值的任务。 （3）要想禁止对象的默认拷贝构造和赋值，只要把拷贝构造函数和拷贝赋值运算符私有起来，只声明，不需要写函数体。 析构函数 编译器会给我们生成一个析构函数的情况： （1）如果继承一个基类，基类中带析构函数，那么编译器就会给我们合成出一个析构函数来调用基类中的析构函数。 （2）如果类成员是一个类类型成员，并且这个成员带析构函数，编译器也会合成出一个析构函数，这个析构函数存在的意义是要调用这个类类型成员所在类的析构函数。 如果我们有自己的析构函数，那么编译器就会在适当的情况下扩展我们的析构函数代码： （1）如果类成员是一个类类型成员，并且这个成员带析构函数，编译器就扩展这个类的析构函数代码，即先执行了本类的析构函数代码，再执行类类型的析构函数代码。 （2）如果继承一个基类，基类中带析构函数，那么编译器就会扩展我们类的析构函数来调用基类中的析构函数。 三、局部类对象、全局类对象的构造和析构函数 （1）对于局部类对象，只要出了对象的作用域，编译器总会在适当的地方插入调用对象析构函数的代码。因此局部对象应该现用现定义，这样可以减少某些情况下的开销（如果在开头处定义对象，而程序还没有运行到使用对象的时候就已经退出，此时就算没有用到对象，编译器也会调用局部类对象的析构函数，这会增加不必要的开销）。 （2）全局变量是放在数据段里的，在编译阶段就会把空间分配出来（全局变量的地址在编译期间就确定好的）。全局对象，在不给初值的情况下，编译器默认会把全局对象所在内存全部清0。 （3）全局对象构造和析构的步骤： a)全局对象获得地址（编译时确定好的，内存也是编译时分配好的，内存时运行期间一直存在） b)把全局对象的内存内容清0（也叫静态初始化） c)调用全局对象所对应的类的构造函数 d)main(){……} e)调用全局对象所对应类的析构函数 （4）全局对象在main函数执行之前就被构造完毕，可以在main函数中直接使用，在main函数执行完毕后才被析构掉。 12345678910111213141516171819class A&#123;public: A() &#123; cout &lt;&lt; &quot;A::A()&quot; &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;A::~A()&quot; &lt;&lt; endl; &#125; int m_i;&#125;;A g_aobj; //全局对象int main()&#123; A aobj; //局部对象 return 1;&#125; 四、局部静态对象的构造和析构123456789101112131415161718192021222324252627class A&#123;public: A() &#123; cout &lt;&lt; &quot;A::A()&quot; &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;A::~A()&quot; &lt;&lt; endl; &#125; int m_i;&#125;;const A &amp;myfunc()&#123; //局部静态对象 static A s_aobj1; printf(&quot;s_aobj1的地址是%p\n&quot;, &amp;s_aobj1); return s_aobj1;&#125;int main()&#123; myfunc(); myfunc(); return 1; &#125; （1）如果我们不调用myfunc()函数，那么根本不会触发A的构造函数。 （2）局部静态对象，内存地址是在编译期间就确定好的。 （3）静态局部变量刚开始也被初始化为0。 （4）局部静态对象的析构，是在main函数执行结束后才被调用的。（前提是这个静态局部对象被构造过） （5）不管myfunc()函数被调用几次，s_aobj1这种静态局部对象只会被构造1次。（只调用一次构造函数） 五、new和delete （1）new类对象时加不加括号的差别：如果是个空类，那么加不加括号没有区别（现实中，不可能光写一个空类）。如果类中有成员变量，则带括号的初始化会把一些和成员变量有关的内存清0，但不是整个对象的内存全部清0。当类中有构造函数，两种写法都会调用类的构造函数。 （2）new干了两个事：一个是调用operator new(malloc)，一个是调用了类A的构造函数。delete也干了两个事：一个是调用了类A的析构函数，一个是调用operator delete(free)。 六、临时对象拷贝构造函数相关的临时对象1234567891011121314151617181920212223242526272829303132class A&#123;public: A() &#123; cout &lt;&lt; &quot;A::A()构造函数被执行&quot; &lt;&lt; endl; &#125; A(const A&amp; tmpobj) &#123; cout &lt;&lt; &quot;A::A()拷贝构造函数被执行&quot; &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;A::~A()析构函数被执行&quot; &lt;&lt; endl; &#125;&#125;;A operator+(const A&amp; obj1, const A&amp; obj2)&#123; A tmpobj; return tmpobj; //此时编译器产生临时对象，把tmpobj对象的内容通过调用拷贝构造函数把tmpobj的内容拷贝构造给这个临时对象，然后返回的是这个临时对象。&#125;int main()&#123; A myobj1; A myobj2; A resultobj = myobj1 + myobj2; //这个从operator+里返回的临时对象直接构造到了resultobj里； return 1; &#125; 拷贝赋值运算符相关的临时对象class A { public: A() { cout &lt;&lt; &quot;A::A()构造函数被执行&quot; &lt;&lt; endl; } A(const A&amp; tmpobj) { cout &lt;&lt; &quot;A::A()拷贝构造函数被执行&quot; &lt;&lt; endl; } A &amp; operator=(const A&amp; tmpaobj) { cout &lt;&lt; &quot;A::operator()拷贝赋值运算符被执行&quot; &lt;&lt; endl; return *this; } ~A() { cout &lt;&lt; &quot;A::~A()析构函数被执行&quot; &lt;&lt; endl; } }; A operator+(const A&amp; obj1, const A&amp; obj2) { A tmpobj; return tmpobj; //编译器产生临时对象，把tmpobj对象的内容通过调用拷贝构造函数 把tmpobj的内容拷贝构造给这个临时对象,然后返回的是这个临时对象。 } int main() { A myobj1; A myobj2; A resultobj; resultobj = myobj1 + myobj2; //调用拷贝赋值运算符 //A resultobj = myobj1 + myobj2; //调用拷贝构造函数 return 1; }直接运算产生的临时对象class A { public: A() { cout &lt;&lt; &quot;A::A()构造函数被执行&quot; &lt;&lt; endl; } A(const A&amp; tmpobj) { cout &lt;&lt; &quot;A::A()拷贝构造函数被执行&quot; &lt;&lt; endl; m_i = tmpobj.m_i; } A &amp; operator=(const A&amp; tmpaobj) { cout &lt;&lt; &quot;A::operator()拷贝赋值运算符被执行&quot; &lt;&lt; endl; return *this; } ~A() { cout &lt;&lt; &quot;A::~A()析构函数被执行&quot; &lt;&lt; endl; } int m_i; }; A operator+(const A&amp; obj1, const A&amp; obj2) { A tmpobj; tmpobj.m_i = obj1.m_i + obj2.m_i; return tmpobj; //编译器产生临时对象，把tmpobj对象的内容通过调用拷贝构造函数 把tmpobj的内容拷贝构造给这个临时对象，然后返回的是这个临时对象。 } int main() { A myobj1; myobj1.m_i = 1; A myobj2; myobj2.m_i = 2; A resultobj = myobj1 +myobj2; //临时对象被接住，不会被立即析构 myobj1 + myobj2; //产生了临时对象，然后该临时对象立即被析构； printf(&quot;(myobj1 + myobj2).m_i = %d\n&quot;, (myobj1 + myobj2).m_i); //临时对象的析构是整行语句的最后一步，这样就能保证printf打印出来一个有效值。 编译器要往必要的地方，帮助我们插入 A tmpobja1 = (myobj1 + myobj1);这样的代码，来产生临时对象供编译器完成我们程序开发者代码要实现的意图。 return 1; }]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象模型（4） -- 函数语义学]]></title>
    <url>%2F2019%2F08%2F11%2FC%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%884%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、普通成员函数调用方式1234567891011121314151617181920212223242526272829303132class MYACLS&#123;public: int m_i; void myfunc(int abc) &#123; m_i += abc; &#125;&#125;;//编译器视角void _ZN6MYACLS6myfuncEi(MYACLS *const this, int abc) //编译器会额外安插一个this指针，一般会扔到参数的开头&#123; this-&gt;m_i + abc;&#125;void gmyfunc(MYACLS *ptmp,int abc)&#123; ptmp-&gt;m_i += abc;&#125;int main()&#123; MYACLS myacls; myacls.myfunc(18); //调用成员函数 gmyfunc(&amp;myacls, 18); //调用全局函数 printf(&quot;MYACLS::myfunc的地址=%p\n&quot;, &amp;MYACLS::myfunc); //可以发现多次打印成员函数的地址，都不会改变，编译的时候已经确定好了 return 1;&#125; （1）c++语言设计的时候有一个要求：要求对普通成员函数的调用不应该比全局函数效率差。基于这种设计要求，编译器内部实际上是将对成员函数myfunc()的调用转换成了对全局函数的调用。 （2）成员函数有独立的内存地址，是跟着类走的，并且成员函数的地址是在编译的时候就确定好的。 （3）编译器额外增加了一个叫this的形参，是个指针，指向的其实就是生成的对象。 （4）常规成员变量的存取，都通过this形参来进行，比如上述 this-&gt;m_i + abc。 二、虚成员函数、静态成员函数调用方式虚成员函数（虚函数）调用方式1234567891011121314151617181920212223242526272829303132class MYACLS&#123;public: virtual void myvirfunc() &#123; printf(&quot;myvirfunc()被调用,this = %p\n&quot;, this); myvirfunc2(); //走虚函数表指针调用 MYACLS::myvirfunc2(); //直接调用虚函数，效率更高。这种写法压制了虚拟机制，不再通过查询虚函数表来调用 //这种用类名::虚函数名()明确调用虚函数的方式等价于直接调用一个普通函数； &#125; virtual void myvirfunc2() &#123; printf(&quot;myvirfunc2()被调用,this = %p\n&quot;, this); &#125;&#125;;int main()&#123; MYACLS myacls; myacls.myvirfunc(); //用对象调用虚函数。 MYACLS *pmyacls = new MYACLS(); pmyacls-&gt;myvirfunc(); //用指针调用虚函数 //编译器视角 //(*pmyacls-&gt;vptr[0])(pmyacls); //a)vptr，编译器给生成的虚函数表指针，指向虚函数表 //b)[0] 虚函数表中第一项。代表myvirfunc()地址 //c)传递一个参数进去，就是this，也是编译器给加的 //d)*就得到了虚函数的地址； //printf(&quot;MYACLS::myvirfunc2虚函数的地址为%p&quot;, &amp;MYACLS::myvirfunc2); //地址也是在编译阶段确定的，多次打印不会变&#125; （1）用对象调用虚函数，就像调用普通成员函数一样,不需要通过虚函数表。 （2）用指针调用虚函数，要通过虚函数表指针查找虚函数表，通过虚函数表在好到虚函数的入口地址，完成对虚函数的调用。 静态成员函数调用方式1234567891011121314151617181920212223242526272829303132333435363738class MYACLS&#123;public: int m_i; void myfunc(int abc) &#123; //m_i += abc; //这里需要用到this指针，而this指针为空，则会报告异常 mystfunc(); &#125; //静态成员函数 static int m_si; static void mystfunc() //不需要this参数 &#123; printf(&quot;mystfunc()被调用\n&quot;); m_si = 1; &#125;&#125;;int main()&#123; MYACLS myacls; MYACLS *pmyacls = new MYACLS(); myacls.mystfunc(); pmyacls-&gt;mystfunc(); MYACLS::mystfunc(); ((MYACLS *)0)-&gt;mystfunc(); //能够正常调用静态成员函数 ((MYACLS *)0)-&gt;myfunc(12); //有些成员函数希望支持独立于类对象之外的存取操作,归为类所有，跟静态成员函数看似相似 myacls.myfunc(12); //此时如果要存取非静态成员变量，就会出错。 pmyacls-&gt;myfunc(12); printf(&quot;MYACLS::mystfunc()地址 = %p\n&quot;, MYACLS::mystfunc); delete pmyacls; return 1;&#125; （1）静态成员函数没有this指针，这点最重要。 （2）无法直接存取类中普通的非静态成员变量，因为非静态成员变量是通过this指针来操作的。 （3）静态成员函数不能在后面使用const，也不能设置为virtual。 （4）可以用类对象调用，但不非一定要用类对象调用。 （5）静态成员函数等同于非成员函数，有的需要提供回调函数的这种场合，可以将静态成员函数作为回调函数； 三、静态、动态类型，绑定，多态实现深谈静态类型和动态类型 （1）静态类型：对象定义时的类型，编译期间就确定好的。 （2）动态类型：对象目前所指向的类型（运行的时候才决定的类型）。 （3）一般只有指针或者引用才有动态类型的说法。而且一般都是指父类的指针或者引用。另外，动态类型在执行过程中可以改变。 仔细看如下代码分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Base&#123;public: void myfunc() //普通成员函数 &#123; cout &lt;&lt; &quot;Base::myfunc()&quot; &lt;&lt; endl; &#125; virtual void myvirfunc(int value = 1) &#123; cout &lt;&lt; &quot;Base::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl; &#125;&#125;;class Derive :public Base&#123;public: void myfunc() //普通成员函数 &#123; cout &lt;&lt; &quot;Derive::myfunc()&quot; &lt;&lt; endl; &#125; virtual void myvirfunc(int value = 2) &#123; cout &lt;&lt; &quot;Derive::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl; &#125;&#125;;class Derive2 :public Base&#123;public:&#125;;class A&#123;public: virtual void myvirfunc() &#123;&#125;&#125;;int main()&#123; Base base; //base的静态类型是Base，没有动态类型，因为不是指针不是引用 Derive derive; //derive的静态类型是Derive，没有动态类型，因为不是指针不是引用 Base *pbase; //pbase的静态类型依旧是Base * ,至少目前没有动态类型，因为它没有指向任何对象 Base *pbase2 = new Derive(); //pbase2的静态类型依旧是Base * ，动态类型是Derive Base *pbase3 = new Derive2(); //pbase3的静态类型依旧是Base *，动态类型是Derive2 pbase = pbase2; //pbase的动态类型Derive pbase = pbase3; //pbase的动态类型改变为Derive2&#125; 静态绑定和动态绑定 （1）静态绑定：绑定的是静态类型，所对应的函数或者属性依赖于对象的静态类型，发生在编译期 （2）动态绑定：绑定的是动态类型，所对应的函数或者属性依赖于对象的动态类型，发生在运行期 （3）普通成员函数是静态绑定，而虚函数是动态绑定。缺省参数一般是静态绑定。 代码分析： 123456789101112131415161718192021222324252627282930313233class Base&#123;public: void myfunc() //普通成员函数 &#123; cout &lt;&lt; &quot;Base::myfunc()&quot; &lt;&lt; endl; &#125; virtual void myvirfunc(int value = 1) &#123; cout &lt;&lt; &quot;Base::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl; &#125;&#125;;class Derive :public Base&#123;public: void myfunc() //普通成员函数 &#123; cout &lt;&lt; &quot;Derive::myfunc()&quot; &lt;&lt; endl; &#125; virtual void myvirfunc(int value = 2) &#123; cout &lt;&lt; &quot;Derive::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl; &#125;&#125;;int main()&#123; Derive derive; Derive *pderive = &amp;derive; pderive-&gt;myfunc(); //Derive::myfunc() Base *pbase = &amp;derive; pbase-&gt;myfunc(); ////Base::myfunc() &#125; 普通成员函数是静态绑定，换句话说，myfunc()是普通成员函数。这里到底调用父类的myfunc还是子类的myfunc取决于调用者的静态类型。 因为这里pbase的静态类型是Base，所以调用的是Base里的myfunc()；pderive的静态类型是Derive，所以调用的是Derive的myfunc()。 结论：为了避免混淆，不应该在子类中重新定义一个继承来的非虚函数。 再看如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041class Base&#123;public: void myfunc() //普通成员函数 &#123; cout &lt;&lt; &quot;Base::myfunc()&quot; &lt;&lt; endl; &#125; virtual void myvirfunc(int value = 1) //缺省参数的值为1 &#123; cout &lt;&lt; &quot;Base::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl; &#125;&#125;;class Derive :public Base&#123;public: void myfunc() //普通成员函数 &#123; cout &lt;&lt; &quot;Derive::myfunc()&quot; &lt;&lt; endl; &#125; virtual void myvirfunc(int value = 2) //缺省参数的值为2 &#123; cout &lt;&lt; &quot;Derive::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl; &#125;&#125;;int main()&#123; Derive derive; Derive *pderive = &amp;derive; Base *pbase = &amp;derive; pderive-&gt;myvirfunc(); //执行Derive的myvirfunc(); --- Derive::myvirfunc() pbase-&gt;myvirfunc(); //pbase动态类型是Derive，而虚函数是动态绑定，参照是它的动态类型；--- Derive::myvirfunc() //缺省value参数打印出来的居然是1：Derive::myvirfunc(),value = 1 //这就始于函数参数缺省值的静态绑定，所以缺省参数绑定到了父类函数的缺省参数上去了 Base &amp;yinbase = derive; //引用，效果和指针一样 yinbase.myvirfunc(); //Derive::myvirfunc(),value = 1 pbase = &amp;base; pbase-&gt;myvirfunc(); //----Base::myvirfunc(); Base::myvirfunc(),value = 1&#125; 虚函数是动态绑定,换句话说，myvirfunc()是虚函数，这里到底执行哪个myvivfunc()取决于调用者的动态类型。 这里pbase的动态类型分别Derive，Base，所以调用的也分别是Derive和Base的myvirfunc()，pderive的动态类型是Derive，所以调用的是Derive的myvirfunc()。 从上面代码中可以看出，虚函数的参数缺省值是静态绑定，所以不要重新定义虚函数的缺省参数的值。 c++中的多态性的体现 多态性这个概念，分两方面谈： a)从代码实现上 b)从表现形式上 有一个观点是肯定的：多态，必须是存在虚函数，没有虚函数，绝不可能存在多态，有虚函数并且调用虚函数。 （1）从代码实现上来看，当我们调用一个虚函数时，走的是不是通过查询虚函数表来找到虚函数入口地址，然后去执行虚函数，如果走的是这个途径，那就是多态，如果不走这个途径，它就不是多态。看代码分析： 12345678910111213141516171819class A&#123;public: virtual void myvirfunc() &#123;&#125;&#125;;int main()&#123; A *pa = new A(); pa-&gt;myvirfunc(); //是多态 A a; a.myvirfunc(); //这个就不是多态 A *pa1 = &amp;a; pa1-&gt;myvirfunc(); //这个也是多态 return 1;&#125; （2）从表现形式上来看(通过代码来体现) a)有继承关系，有父类有子类，父类中必须有虚函数(这意味着子类中一定有虚函数)，子类重写父类的虚函数。 b)父类指针或者引用指向子类对象。 c)当以父类指针或者引用调用子类中重写了的虚函数时，我们就能看出来多态的表现了，因为调用的是子类的虚函数。 代码分析： 12345678910111213141516171819202122232425class Base&#123;public: virtual void myvirfunc() &#123; cout &lt;&lt; &quot;Base::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl; &#125;&#125;;class Derive :public Base&#123;public: virtual void myvirfunc() &#123; cout &lt;&lt; &quot;Derive::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl; &#125;&#125;; int main()&#123; Derive derive; Base *pbase = &amp;derive; pbase-&gt;myvirfunc(); //多态实现 return 1;&#125; 四、多继承下的第二基类问题探讨 先给出一个继承关系，稍后做具体分析。 123456789101112131415161718192021222324252627282930313233343536373839class Base&#123;public: virtual void f() &#123; cout &lt;&lt; &quot;Base::f()&quot; &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; &quot;Base::g()&quot; &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; &quot;Base::h()&quot; &lt;&lt; endl; &#125; virtual ~Base() &#123; int abc; abc = 1; &#125;&#125;;class Base2&#123;public: virtual void hBase2() &#123; cout &lt;&lt; &quot;Base2::hBase2()&quot; &lt;&lt; endl; &#125; virtual ~Base2() &#123; int abc; abc = 1; &#125;&#125;;class Derive :public Base,public Base2 &#123;public: virtual void i() &#123; cout &lt;&lt; &quot;Derive::i()&quot; &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; &quot;Derive::g()&quot; &lt;&lt; endl; &#125; void myselffunc() &#123;&#125; //只属于Derive的函数 virtual ~Derive() &#123; int abc; abc = 1; &#125; &#125;; 多重继承的复杂性往往体现在后边这个基类上，先来看使用后面这个基类的情况： 12345Base2 *pb2 = new Derive();//编译器视角Derive *temp = new Derive();Base2 *pb2 = (Base2 *)((char *)temp + sizeof(Base));delete pb2; 现在，我们考虑如何成功删除用第二基类指针new出来的继承类对象。注意，我们要删除的实际是整个Derive()对象，要能够保证Derive()对象的析构函数被正常调用，那么编译器会调用Base2的析构函数，还是调用Derive的析构函数呢？执行delte pb2时，系统的动作会是什么？ 事实上，这里分为以下几种情况： （1）如果Base2里没有析构函数,编译器会直接删除以pb2开头的这段内存，一定报异常，因为这段内存压根就不是new起始的内存。 （2）如果Base2里有一个析构函数，但整个析构函数是个普通析构函数（非虚析构函数），那么当delte pb2，这个析构函数就会被系统调用,但是delete的仍旧是pb2开头这段内存，所以一定报异常。因为这段内存压根就不是new起始的内存。（析构函数如果不是虚函数，编译器会实施静态绑定，静态绑定意味着你delete Base2指针时，删除的内存开始地址就是pb2的当前位置，所以肯定是错误的）。 （3）如果Base2里是一个虚析构函数，则delete的时候，编译器会自动按～Dervice() –&gt; ～Base2() –&gt; ～Base()的顺序调用，此时就是把整个Derive()对象的内存都释放了。 （4）Derive里就就算没有虚析构函数，因为Base2里有虚析构函数，编译器也会为此给Derive生成虚析构函数，为了调用～Base2()和～Base()虚析构函数。 由上述结论知，凡是涉及到继承的，所有类都加上虚析构函数，以防异常。 另外，Derive类的第二个虚函数表中发现了thunk字样，一般它用在多重继承中（从第二个虚函数表开始可能就 会有），用于this指针调整。它其实是一段汇编代码，这段代码干两个事情： (1)调整this指针（this指针调整的目的就是让对象指针正确的指向对象首地址，从而能正确的调用对象的成员函数或者说正确确定数据成员的存储位置） (2)调用Derive析构函数 五、虚基类带虚函数的成员分布以及继承开销123456789101112131415161718192021class Base&#123;public: virtual void f() &#123;&#125; virtual ~Base() &#123;&#125; int m_basei;&#125;;class Derive :public virtual Base&#123;public: virtual ~Derive()&#123;&#125; int m_derivei;&#125;;int main()&#123; cout &lt;&lt; sizeof(Derive) &lt;&lt; endl; // 16 Derive dobj; dobj.m_basei = 2; // 13-16字节 dobj.m_derivei = 5; // 5-8字节&#125; 由此可以看出，此种情况下的数据分布应该是：虚基类表指针（1-4字节）、子类数据成员（5-8字节）、虚函数表指针（9-12字节）、基类数据成员（13-16字节）。 一般来说， （1）随着继承深度的增加，开销或者说执行时间也会增加。 （2）多重继承一般也会导致开销增加。 （3）虚函数也会导致开销增加。 六、指向成员函数的指针以及vcall探讨指向普通成员函数的指针 成员函数地址是在编译时就确定好的。但是，要想调用成员函数，是需要通过对象来调用的。所有常规（非静态）成员函数，要想调用，都需要一个对象来调用它。并且，通过成员函数指针对常规的成员函数调用的成本，和通过普通的函数指针来调用静态成员函数，成本上差不多。 1234567891011121314151617181920212223242526272829303132333435363738class A&#123;public: void myfunc1(int tempvalue1) &#123; cout &lt;&lt; &quot;tempvalue1 = &quot; &lt;&lt; tempvalue1 &lt;&lt; endl; &#125; void myfunc2(int tempvalue2) &#123; cout &lt;&lt; &quot;tempvalue2 = &quot; &lt;&lt; tempvalue2 &lt;&lt; endl; &#125; static void mysfunc(int tempvalue) &#123; cout &lt;&lt; &quot;A::mysfunc()静态成员函数--tempvalue = &quot; &lt;&lt; tempvalue &lt;&lt; endl; &#125;&#125;;int main()&#123; A mya; void (A::*pmypoint)(int tempvalue) = &amp;A::myfunc1; //定义一个成员函数指针并给初值 pmypoint = &amp;A::myfunc2; //给成员函数指针赋值 (mya.*pmypoint)(15); //通过成员函数指针来调用成员函数，必须要通过对象的介入才能调用 A *pmya = new A(); (pmya-&gt;*pmypoint)(20); //用对象指针介入来使用成员函数指针来调用成员函数 //编译器视角 //pmypoint(&amp;mya, 15); //pmypoint(pmya, 20); void(*pmyspoint)(int tempvalue) = &amp;A::mysfunc; //一个普通的函数指针，而不是成员函数指针 pmyspoint(80); return 1;&#125; 指向虚成员函数的指针及vcall理解 vcall(vcall trunk) = virtual call：虚调用。它代表一段要执行的代码的地址，这段代码引导编译器去执行正确的虚函数，或者我们直接把vcall看成虚函数表，如果这么看待的话，那么vcall{0}代表的就是虚函数表里的第一个函数，vcall{4}就代表虚函数表里的第二个虚函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243class A&#123;public: void myfunc1(int tempvalue1) &#123; cout &lt;&lt; &quot;tempvalue1 = &quot; &lt;&lt; tempvalue1 &lt;&lt; endl; &#125; void myfunc2(int tempvalue2) &#123; cout &lt;&lt; &quot;tempvalue2 = &quot; &lt;&lt; tempvalue2 &lt;&lt; endl; &#125; static void mysfunc(int tempvalue) &#123; cout &lt;&lt; &quot;A::mysfunc()静态成员函数--tempvalue = &quot; &lt;&lt; tempvalue &lt;&lt; endl; &#125; virtual void myvirfuncPrev(int tempvalue) &#123; cout &lt;&lt; &quot;A::myvirfuncPrev()虚成员函数--tempvalue = &quot; &lt;&lt; tempvalue &lt;&lt; endl; &#125; virtual void myvirfunc(int tempvalue) &#123; cout &lt;&lt; &quot;A::myvirfunc()虚成员函数--tempvalue = &quot; &lt;&lt; tempvalue &lt;&lt; endl; &#125;&#125;; void func()&#123; void (A::*pmyvirfunc)(int tempvalue) = &amp;A::myvirfunc; //成员函数指针 -- vcall(vcall trunk)地址（虚函数） A *pvaobj = new A; pvaobj-&gt;myvirfunc(190); (pvaobj-&gt;*pmyvirfunc)(190); printf(&quot;%p\n&quot;, &amp;A::myvirfunc); pmyvirfunc = &amp;A::myfunc2; //真正的成员函数地址 (pvaobj-&gt;*pmyvirfunc)(33); delete pvaobj; &#125; 完善理解：&amp;A::myvirfunc,打印出来的是一个地址，这个地址中有一段代码，这个代码中记录的是该虚函数在虚函数表中的一个偏移值，有了这个偏移值，再有了具体的对象指针，我们就能够知道调用的是哪个虚函数表里边的哪个虚函数了。 成员函数指针里，保存的可能是一个vcall(vcall trunk)地址（如果指针指向的是虚函数）,要么也可能是一个真正的成员函数地址（指针指向的不是虚函数）。如果是一个vcall地址，那vcall能够引导编译器找出正确的虚函数表中的虚函数地址进行调用。 七、inline函数介绍及其扩展细节inline函数介绍 使用inline之后，编译器内部会有一个比较复杂的测试算法来评估这个inline函数的复杂度,可能会统计这个inline函数中，赋值次数，内部函数调用，虚函数调用等次数（权重）。 （1）开发者写inline只是对编译器的一个建议，但如果编译器评估这个inline函数复杂度过高，这个inline建议就被编译器忽略。 （2）如果inline被编译器采纳，那么inline函数的扩展，就要在调用这个inline函数的那个点上进行，此时可能带来额外的问题比如：参数求值，可能导致临时对象的生成和管理。 inline扩展细节 见代码的注释部分： 12345678910111213141516inline int myfunc(int testv)&#123; return testv * (5 + 4) * testv;&#125;void func()&#123; int i = myfunc(12 + 15); //编译器会先求值，然后用实参再替换形参 int a = 80; int i = myfunc(a + 15); //编译器会先计算a和15的和值，然后再替换掉形参&#125;int main()&#123; _nmsp1::func(); return 1;&#125;]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL源码剖析（4）]]></title>
    <url>%2F2019%2F08%2F10%2FSTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面的话 前一篇博文介绍了序列式容器，接下来介绍关联式容器。 概览 所谓关联式容器，即每个元素都有一个键值（key）和一个实值（value）。当元素被插入到关联式容器中时，容器的内部结构便按照其键值大小，以某种特定规则将这个元素放置于适当位置。关联式容器没有头尾（只有最大元素和最小元素），所以不会有push_back(), push_front(), pop_back(), pop_front(), begin(), end()这些操作行为。 STL中的关联式容器分为set和map两大类，以及这两大类的衍生体multiset和multimap。这些容器的底层实现机制都是红黑树。红黑树也是一个独立的容器，但是并不开放给外界使用。此外，SGI STL还提供了一个不在标准规格之列的关联式容器：hashtable,以及以hashtable为底层机制的hash_set,hash_map,hash_multiset,hash_multimap。 set （1）set里面元素的键值就是实值，实值就是键值，所有元素都会根据元素的键值自动被排序，并且set不允许两个元素有相同的键值。 （2）我们不能通过set的迭代器改变set的元素值，因为set的元素值就是其键值，关系到set元素的排列规则，如果任意改变set的元素值，会破坏set组织。因此，set::iterator 被定义为const_iterator，杜绝写入操作。 （3）set拥有与list相同的某些性质：当用户对它进行元素新增或删除操作时，操作之前的所有迭代器（除了被删除元素的迭代器）在操作之后都依然有效。 （4）set是以红黑树为底层机制，因为红黑树是一种平衡二叉搜索树，自动排序效果不错。而且对于set所开放的各种接口操作，红黑树也都提供了，所以几乎所有的set操作行为，都只是调用红黑树的操作行为而已。 map （1）map的所有元素都是pair，同时拥有实值（value）和键值（key）。pair的第一元素被视为键值，第二元素被视为实值。它的所有元素都会根据元素的键值自动被排序，并且map不允许两个元素拥有相同的键值。 （2）我们不能通过map的迭代器改变map里元素的键值，因为键值关系到map元素的排列规则，任意改变map元素键值将会严重破坏map组织，但是可以改变元素的实值，因为map元素的实值并不影响map元素的排列规则。 （3）map拥有与list相同的某些性质：当用户对它进行元素新增或删除操作时，操作之前的所有迭代器（除了被删除元素的迭代器）在操作之后都依然有效。 （4）map也是以红黑树为底层机制，因为红黑树是一种平衡二叉搜索树，自动排序效果不错。而且对于map所开放的各种接口操作，红黑树也都提供了，所以几乎所有的map操作行为，都只是调用红黑树的操作行为而已。 multiset和multimap （1）multiset的特性以及用法和set完全相同，唯一的差别在于它允许键值重复，因此它的插入操作采用的是底层机制红黑树的insert_equal()而非insert_unique()。 （2）multimap的特性以及用法和map完全相同，唯一的差别在于它允许键值重复，因此它的插入操作采用的是底层机制红黑树的insert_equal()而非insert_unique()。 hash_set （1）hash_set以hashtable为底层机制，由于hash_set所提供的操作接口，hashtable都提供了，所以几乎所有的hash_set操作行为都只是转调用hashtable的操作行为而已。 （2）红黑树有自动排序功能，而hashtable没有，反映到表层就是，set的元素有自动排序功能而hash_set没有。 （3）hash_set跟set一样，元素的键值就是实值，实值就是键值。 hash_map （1）hash_map也是以hashtable为底层机制，由于hash_map所提供的操作接口，hashtable都提供了，所以几乎所有的hash_map操作行为都只是转调用hashtable的操作行为而已。 （2）红黑树有自动排序功能，而hashtable没有，反映到表层就是，map的元素有自动排序功能而hash_map没有。 （3）hash_map跟map一样，每一个元素同时拥有一个实值和一个键值。 hash_multiset和hash_multimap （1）hash_multiset的特性与multiset完全相同，唯一差别就在于它的底层机制是hashtable。因此，hash_multiset的元素不会自动排序。 （2）hash_multiset和hash_set实现上的唯一差别在于，前者的元素插入操作采用底层机制hashtable的insert_equal(),后者则是采用insert_unique()。 （3）hash_multimap的特性与multimap完全相同，唯一差别就在于它的底层机制是hashtable。因此，hash_multimap的元素不会自动排序。 （4）hash_multimap和hash_map实现上的唯一差别在于，前者的元素插入操作采用底层机制hashtable的insert_equal(),后者则是采用insert_unique()。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象模型（3） -- 数据语义学]]></title>
    <url>%2F2019%2F08%2F09%2FC%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、数据成员绑定时机12345678910111213typedef string mytype;//定义一个类class A&#123;public: void myfunc(mytype tmpvalue) //mytype = string &#123; m_value = tmpvalue; //出错，是把一个string类型给一个整型 &#125; typedef int mytype;private: mytype m_value; //int &#125;; （1）编译器对成员函数的解析，是整个类定义完毕后才开始的。因为只有整个类定义完毕后，编译器才能看到类中的成员变量，才能根据实际的需要把出现该成员变量的场合做适当的解释（成员函数中解析成类中的变量类型，全局函数中解析成全局的变量类型）。 （2）对于成员函数参数，是在编译器第一次遇到整个类型mytype的时候被决定的。所以，mytype第一次遇到的时候，编译器只看到了typedef string mytype，没有看到类中的typedef int mytype。 （3）为了在类中尽早的看到类型mytype，所以这种类型定义语句typedef，一定要挪到类的最开头定义。（即上述代码中应该把typedef int mytype移到class A的开头处）当后边的成员函数第一次遇到这个类型mytype的时候，它就本着最近碰到的类型的原则来应用最近碰到的类型。 二、进程内存空间布局 不同的数据在内存中会有不同的保存时机，保存位置。当运行一个可执行文件时，操作系统就会把这个可执行文件加载到内存，此时进程有一个虚拟的地址空间（内存空间），分为：堆栈段、数据段、代码段等。从下面代码中可以看出些许规律。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int *ptest = new int(120);int g1;int g2;int g3 = 12;int g4 = 32;int g5;int g6 = 0;static int g7;static int g8=0;static int g9 = 10;void mygfunc()&#123; return;&#125;//定义一个类class MYACLS&#123;public: int m_i; static int m_si; //声明不是定义 int m_j; static int m_sj; int m_k; static int m_sk; //static void myclsfunc() &#123;&#125;&#125;;int MYACLS::m_sj = 0; //这才是定义；int main()&#123; int i = 7;; printf(&quot;i地址=%p\n&quot;, &amp;i); //i地址=00AFFB94 printf(&quot;ptest地址=%p\n&quot;, &amp;ptest); //ptest地址=00F9B300 printf(&quot;g1地址=%p\n&quot;, &amp;g1); //g1地址=00F9B2EC printf(&quot;g2地址=%p\n&quot;, &amp;g2); //g2地址=00F9B2F0 printf(&quot;g3地址=%p\n&quot;, &amp;g3); //g3地址=00F9B000 printf(&quot;g4地址=%p\n&quot;, &amp;g4); //g4地址=00F9B004 printf(&quot;g5地址=%p\n&quot;, &amp;g5); //g5地址=00F9B2F4 printf(&quot;g6地址=%p\n&quot;, &amp;g6); //g6地址=00F9B2F8 printf(&quot;g7地址=%p\n&quot;, &amp;g7); //g7地址=00F9B304 printf(&quot;g8地址=%p\n&quot;, &amp;g8); //g8地址=00F9B308 printf(&quot;g9地址=%p\n&quot;, &amp;g9); //g9地址=00F9B008 printf(&quot;MYACLS::m_sj地址=%p\n&quot;, &amp;(MYACLS::m_sj)); //MYACLS::m_sj地址=00F9B2FC printf(&quot;mygfunc()地址=%p\n&quot;, mygfunc); //mygfunc()地址=00F91433 printf(&quot;main()地址=%p\n&quot;, main); //main()地址=00F9132A cout &lt;&lt; (void*)mygfunc &lt;&lt; endl; //00F91433 return 1;&#125; 从上述代码的打印结果来看，不同类型的数据在内存中的存储位置是不同的，同一类型的数据是连续存储的。 三、类中成员变量的布局 （1）普通成员变量的存储顺序是按照在类中的定义顺序从上到下来的。比较晚出现的成员变量在内存中有更高的地址。类定义中pubic,private,protected的数量，不影响类对象的sizeof。 （2）某些因素会导致成员变量之间排列不连续，就是边界调整（字节对齐），调整的目的是提高效率，编译器自动调整。调整方式：往成员之间填补一些字节，使用类对象的sizoef字节数凑成一个4的整数倍，8的整数倍。 （3）为了统一字节对齐问题，引入一个概念叫一字节对齐(不对齐)：#pragma pack(1)。把这个语句放到程序最开始处即可。 （4）有虚函数时，编译器往类定义中增加vptr虚函数表指针（内部的数据成员）。 （5）成员变量偏移值，就是这个成员变量的地址，离对象首地址偏移多少。 四、类中成员变量的存取 （1）静态成员变量，可以当做一个全局量，但是它只在类的空间内可见。引用时用类名::静态成员变量名。静态成员变量只有一个实体，保存在可执行文件的数据段。 （2）非静态成员变量（普通的成员变量）存放在类的对象中。存取通过类对象（类对象指针）来操作。例如：对于普通成员的访问，编译器是把类对象的首地址加上成员变量的偏移值。 五、单一继承下的数据成员布局 （1）一个子类对象，所包含的内容，是他自己的成员，加上他父类的成员的总和。从偏移值看，父类成员先出现，然后才是孩子类成员。 （2）引入继承关系后，可能会带来内存空间的额外增加（字节对齐）。所以不能用memcpy内存拷贝把父类对象的内容直接往子类对象里拷贝。 六、带有虚函数的类中数据成员布局单个类带虚函数的数据成员布局 类中引入虚函数时，会有额外的成本付出： 1)编译的时候，编译器会产生虚函数表。 2)对象中会产生虚函数表指针vptr，用以指向虚函数表。 3)增加或者扩展构造函数，增加给虚函数表指针vptr赋值的代码，让vptr指向虚函数表。 4)如果多重继承，比如你继承了2个父类，每个父类都有虚函数的话，每个父类都会有vptr，那继承时，子类就会把这两根vptr都继承过来，如果子类还有自己额外的虚函数的话，子类与第一个基类共用一个vptr。 5)析构函数中也被扩展增加了虚函数表指针vptr相关的赋值代码，这个赋值代码似乎和构造函数中代码相同。 单一继承父类带虚函数的数据成员布局 代码如下： 1234567891011121314151617181920212223242526272829303132333435class Base&#123;public: int m_bi; virtual void mybvirfunc() &#123;&#125;&#125;;class MYACLS :public Base&#123;public: int m_i; int m_j; MYACLS() &#123; int abc = 1; //方便加断点 &#125; ~MYACLS() &#123; int def = 0;//方便加断点 &#125;&#125;;int main()&#123; cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl; //16 printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi); //MYACLS::m_bi = 4 printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i); //MYACLS::m_i = 8 printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j); //MYACLS::m_j = 12 MYACLS myobj; myobj.m_i = 3; myobj.m_j = 6; myobj.m_bi = 9; return 1;&#125; 从打印结果可以看出，当父类中有虚函数的时候，指向父类虚函数表的虚函数表指针会占用内存开头的四个字节，紧接着是父类的成员变量，最后才是子类的成员变量。 单一继承父类不带虚函数的数据成员布局12345678910111213141516171819202122232425262728293031323334class Base&#123;public: int m_bi;&#125;;class MYACLS :public Base&#123;public: int m_i; int m_j; MYACLS() &#123; int abc = 1; //方便加断点 &#125; ~MYACLS() &#123; int def = 0;//方便加断点 &#125;&#125;;int main()&#123; cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl; //12 printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi); //MYACLS::m_bi = 0 printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i); //MYACLS::m_i = 4 printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j); //MYACLS::m_j = 8 MYACLS myobj; myobj.m_i = 3; myobj.m_j = 6; myobj.m_bi = 9; return 1;&#125; 从打印结果可以看出，如果父类中没有虚函数，则父类的成员变量就放到了内存开头处，之后是子类的成员变量。 但是如果子类中有虚函数而父类中没有，内存布局又会发生变化，即数据在内存空间中的分布分别是：父类成员、子类的虚函数表指针、子类成员。代码及打印结果如下： 1234567891011121314151617181920212223242526272829303132333435class Base&#123;public: int m_bi;&#125;;class MYACLS :public Base&#123;public: int m_i; int m_j; virtual void myvirfunc() &#123;&#125; MYACLS() &#123; int abc = 1; //方便加断点 &#125; ~MYACLS() &#123; int def = 0;//方便加断点 &#125;&#125;;int main()&#123; cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl; //16 printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi); //MYACLS::m_bi = 0 printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i); //MYACLS::m_i = 8 printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j); //MYACLS::m_j = 12 MYACLS myobj; myobj.m_i = 3; myobj.m_j = 6; myobj.m_bi = 9; return 1;&#125; 如果子类和父类中都有虚函数，则子类和父类共用一个虚函数表指针，即它俩的地址一样，都在内存的开头处，代码如下： 123456789101112131415161718192021222324252627282930313233343536class Base&#123;public: int m_bi; virtual void mybvirfunc() &#123;&#125;&#125;;class MYACLS :public Base&#123;public: int m_i; int m_j; virtual void myvirfunc() &#123;&#125; MYACLS() &#123; int abc = 1; //方便加断点 &#125; ~MYACLS() &#123; int def = 0;//方便加断点 &#125;&#125;;int main()&#123; cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl; //16 printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi); //MYACLS::m_bi = 4 printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i); //MYACLS::m_i = 8 printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j); //MYACLS::m_j = 12 MYACLS myobj; myobj.m_i = 3; myobj.m_j = 6; myobj.m_bi = 9; return 1;&#125; 总结：不管是父类还是子类，只要含有虚函数，则虚函数指针就位于对应的所有数据成员的前面（父类指针对应父类成员，子类指针对应子类成员），如果父类和子类都含有虚函数，则它俩的虚函数表指针共用一块内存，位于内存空间的开头处。 多重继承且父类都带虚函数的数据成员布局1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Base1&#123;public: int m_bi; virtual void mybvirfunc() &#123;&#125; Base1() &#123; printf(&quot;Base1::Base1()的this指针是：%p!\n&quot;, this); &#125;&#125;;class Base2&#123;public: int m_b2i; virtual void mybvirfunc2() &#123;&#125; Base2() &#123; printf(&quot;Base2::Base2()的this指针是：%p!\n&quot;, this); &#125;&#125;;class MYACLS :public Base1,public Base2&#123;public: int m_i; int m_j; virtual void myvirfunc() &#123;&#125; //虚函数 MYACLS() &#123; int abc = 1; //方便加断点 printf(&quot;MYACLS::MYACLS()的this指针是：%p!\n&quot;, this); &#125; ~MYACLS() &#123; int def = 0;//方便加断点 &#125;&#125;;int main()&#123; cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl; //24 printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi); //MYACLS::m_bi = 4 printf(&quot;MYACLS::m_b2i = %d\n&quot;, &amp;MYACLS::m_b2i); //MYACLS::m_b2i = 4 printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i); //MYACLS::m_i = 16 printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j); //MYACLS::m_j = 20 MYACLS myobj; //Base1::Base1()的this指针是：004FFC24! //Base2::Base2()的this指针是：004FFC2C! //MYACLS::MYACLS()的this指针是：004FFC24! myobj.m_i = 3; myobj.m_j = 6; myobj.m_bi = 9; myobj.m_b2i = 12; MYACLS *pmyobj = new MYACLS(); //Base1::Base1()的this指针是：008F11D8! //Base2::Base2()的this指针是：008F11E0! //MYACLS::MYACLS()的this指针是：008F11D8! pmyobj-&gt;m_i = 3; pmyobj-&gt;m_j = 6; pmyobj-&gt;m_bi = 9; pmyobj-&gt;m_b2i = 12; return 1;&#125; （1）通过this指针打印，我们看到访问Base1成员不用跳 ，访问Base2成员要this指针要偏移（跳过）8字节。 （2）我们看到偏移值，m_bi和m_b2i偏移都是4。 （3）this指针，加上偏移值就的能够访问对应的成员变量，比如m_b2i = this指针+偏移值。 结论：我们要访问一个类对象中的成员，成员的定位是通过：this指针（编译器会自动调整）以及该成员的偏移值，这两个因素来定义。这种this指针偏移的调整都需要编译器介入来处理完成。 虚基类相关1234567891011121314151617181920212223242526272829class Grand //爷爷类&#123;public:&#125;;class A1 : virtual public Grand&#123;public:&#125;;class A2 : virtual public Grand&#123;public:&#125;;class C1 :public A1, public A2&#123;public: int m_c1;&#125;;int main()&#123; cout &lt;&lt; sizeof(Grand) &lt;&lt; endl; // 1 cout &lt;&lt; sizeof(A1) &lt;&lt; endl; // 4 cout &lt;&lt; sizeof(A2) &lt;&lt; endl; // 4 cout &lt;&lt; sizeof(C1) &lt;&lt; endl; // 12 return 1;&#125; （1）虚基类就是让Grand类只被继承一次，防止二义性问题。 （2）有虚基类，就有虚基类表vbtable(virtual base table)、虚基类表指针vbptr(virtual base table pointer)。 （3）空类sizeof(Grand)=1好理解。虚继承之后，A1,A2里就会被编译器插入一个虚基类表指针，这个指针，有点成员变量的感觉。A1,A2里因为有了虚基类表指针，因此占用了4个字节。 1234567891011121314151617181920212223242526272829303132333435363738class Grand //爷爷类&#123;public: int m_grand;&#125;;class A1 : virtual public Grand&#123;public: int m_a1;&#125;;class A2 : virtual public Grand&#123;public: int m_a2;&#125;;class C1 :public A1, public A2&#123;public: int m_c1;&#125;;int main()&#123; cout &lt;&lt; sizeof(Grand) &lt;&lt; endl; // 1 cout &lt;&lt; sizeof(A1) &lt;&lt; endl; // 4 cout &lt;&lt; sizeof(A2) &lt;&lt; endl; // 4 cout &lt;&lt; sizeof(C1) &lt;&lt; endl; // 12 //内存分布情况 C1 c; c.m_grand = 2; // 21-24字节 c.m_a1 = 3; // 5-8字节 c.m_a2 = 4; // 13-16字节 c.m_c1 = 5; // 17-20字节 return 1;&#125; 根据内存分析可以看出：1-4字节和9-12字节应该存放的就是两个虚基类表指针，其中1-4字节是vbptr1（继承自A1），9-12字节是vbptr2（继承自A2）。其余的数据分布如上述程序中所示，需要注意的是：爷爷类里的成员分布在内存的最后。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Grand //爷爷类&#123;public: int m_grand;&#125;;class Grand2 //爷爷类&#123;public: int m_grand2;&#125;;class A1 : virtual public Grand,virtual public Grand2&#123;public: int m_a1;&#125;;class A2 : virtual public Grand&#123;public: int m_a2;&#125;;class C1 :public A1, public A2&#123;public: int m_c1;&#125;;int main()&#123; cout &lt;&lt; sizeof(Grand) &lt;&lt; endl; // 4 cout &lt;&lt; sizeof(A1) &lt;&lt; endl; // 16（3个int数据+1个虚基类表指针） cout &lt;&lt; sizeof(A2) &lt;&lt; endl; // 12（2个int数据+1个虚基类表指针） cout &lt;&lt; sizeof(C1) &lt;&lt; endl; // 28 //内存分布情况 C1 c; c.m_a1 = 1; // 5-8字节 c.m_a2 = 2; // 13-16字节 c.m_c1 = 3; // 17-20字节 c.m_grand = 4; // 21-24字节 c.m_grand2 = 5; // 25-28字节 return 1;&#125; 由此，可以判断出，一个类同时虚继承多个父类，只会产生一个虚基类指针（A1）。1-4字节放的是A1的虚基类指针，9-12字节放的是A2的虚基类指针。其他的数据分布如程序所示。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象模型（2） -- 虚函数]]></title>
    <url>%2F2019%2F08%2F06%2FC%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%882)%2F</url>
    <content type="text"><![CDATA[一、虚函数表指针位置分析 一个类若有虚函数，这个类就会产生一个虚函数表。当类创建对象的时候，对象内就会维护一个虚函数表指针，该指针(vptr)会指向这个虚函数表的开始地址。接下来借助代码分析一下虚函数表指针的位置。 12345678910111213141516171819202122232425class A&#123;public: int i; //4字节 virtual void testfunc() &#123;&#125; //虚函数，vptr4字节。&#125;;int main()&#123; A aobj; int ilen = sizeof(aobj); cout &lt;&lt; ilen &lt;&lt; endl; //8字节 char *p1 = reinterpret_cast&lt;char *&gt;(&amp;aobj); //类型转换，硬转 &amp;aobj这是对象aobj的首地址。 char *p2 = reinterpret_cast&lt;char *&gt;(&amp;(aobj.i)); if (p1 == p2) //说明aobj.i和aobj的位置相同，说明i在对象aobj内存布局的上边。虚函数表指针vptr在下边 &#123; cout &lt;&lt; &quot;虚函数表指针位于对象内存的末尾&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;虚函数表指针位于对象内存的开头&quot; &lt;&lt; endl; &#125; return 1; &#125; 通过测试，我们发现虚函数表指针在对象内存的开头处。 二、继承关系作用下虚函数的手工调用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//父类class Base&#123;public: virtual void f() &#123; cout &lt;&lt; &quot;Base::f()&quot; &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; &quot;Base::g()&quot; &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; &quot;Base::h()&quot; &lt;&lt; endl; &#125;&#125;;class Derive :public Base &#123; virtual void g() &#123; cout &lt;&lt; &quot;Derive::g()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; // cout &lt;&lt; sizeof(Base) &lt;&lt; endl; cout &lt;&lt; sizeof(Derive) &lt;&lt; endl; Derive *d = new Derive(); //派生类指针。 long *pvptr = (long *)d; //指向对象的指针d转成了long *类型。 long *vptr = (long *)(*pvptr); //(*pvptr)表示pvptr指向的对象，也就是Derive本身。Derive对象是4字节的，代表的是虚函数表指针地址。 for (int i = 0; i &lt;= 4; i++) //循环5次，打印出虚函数的地址。 &#123; printf(&quot;vptr[%d] = 0x:%p\n&quot;, i, vptr[i]); &#125; //上述循环运行结果： //vptr[0] = 0x:00DF11A4 //vptr[1] = 0x:00DF1320 //vptr[2] = 0x:00DF1334 //vptr[3] = 0x:00000000 //vptr[4] = 0x:69726544 typedef void(*Func)(void); //定义一个函数指针类型 Func f = (Func)vptr[0]; //f就是函数指针变量，vptr[0]是指向第一个虚函数的。 Func g = (Func)vptr[1]; Func h = (Func)vptr[2]; /*Func i = (Func)vptr[3]; Func j = (Func)vptr[4];*/ f(); //Base::f() g(); //Derive::g() h(); //Base::h() //i(); Base *dpar = new Base(); //父类指针 long *pvptrpar = (long *)dpar; long *vptrpar = (long *)(*pvptrpar); for (int i = 0; i &lt;= 4; i++) //循环5次； &#123; printf(&quot;vptr Base[%d] = 0x:%p\n&quot;, i, vptrpar[i]); &#125; //上述循环运行结果： //vptr Base[0] = 0x:00DF11A4 //vptr Base[1] = 0x:00DF117C //vptr Base[2] = 0x:00DF1334 //vptr Base[3] = 0x:00000000 //vptr Base[4] = 0x:65736142 Func fpar = (Func)vptrpar[0]; Func gpar = (Func)vptrpar[1]; Func hpar = (Func)vptrpar[2]; cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; fpar(); //Base::f() gpar(); //Base::g() hpar(); //Base::h() return 1; &#125; 从上面的运行结果来看（注释中已标出），对于子类对象来说，子类中要是有和父类同名的虚函数，则子类中的虚函数就会把父类中的同名虚函数覆盖，同时虚函数表中对应的虚函数地址必然会发生变化（变成子类中虚函数的地址）。但是如果是父类对象，则还是会调用父类中的虚函数（即不会被覆盖）。 接着看下面的代码： 1234567891011121314151617181920212223242526typedef void(*Func)(void); //定义一个函数指针类型Derive derive;long *pvptrderive = (long *)(&amp;derive); long *vptrderive = (long *)(*pvptrderive); //0x00b09b6c &#123;project100.exe!void(* Derive::`vftable&apos;[4])()&#125; &#123;11538847&#125;Func f1 = (Func)vptrderive[0]; //0x00b0119f &#123;project100.exe!Base::f(void)&#125;Func f2 = (Func)vptrderive[1]; //0x00b0150f &#123;project100.exe!Derive::g(void)&#125;Func f3 = (Func)vptrderive[2]; //0x00b01325 &#123;project100.exe!Base::h(void)&#125;Func f4 = (Func)vptrderive[3]; //0x69726544Func f5 = (Func)vptrderive[4]; //0x3a3a6576Derive derive2 = derive; //调用拷贝构造函数long *pvptrderive2 = (long *)(&amp;derive2);long *vptrderive2 = (long *)(*pvptrderive2);Base base = derive; //直接用子类对象给父类对象值，子类中的属于父类那部分内容会被编译器自动区分（切割）出来并拷贝给了父类对象。 //所以Base base = derive;实际干了两个事情： //第一个事情：生成一个base对象 //第二个事情：用derive来初始化base对象的值。long *pvptrbase = (long *)(&amp;base);long *vptrbase = (long *)(*pvptrbase); //0x00b09b34 &#123;project100.exe!void(* Base::`vftable&apos;[4])()&#125; &#123;11538847&#125;Func fb1 = (Func)vptrbase[0]; //0x00b0119f &#123;project100.exe!Base::f(void)&#125;Func fb2 = (Func)vptrbase[1]; //0x00b01177 &#123;project100.exe!Base::g(void)&#125;Func fb3 = (Func)vptrbase[2]; //0x00b01325 &#123;project100.exe!Base::h(void)&#125;Func fb4 = (Func)vptrbase[3]; //0x00000000Func fb5 = (Func)vptrbase[4]; //0x65736142 可以看出，当用子类对象初始化父类对象的时候，编译器给咱们做了一个选择，显然derive的虚函数表指针值并没有覆盖base对象的虚函数表指针值。 总结： （1）一个类只有包含虚函数才会存在虚函数表，同属于一个类的对象共享虚函数表，但是有各自的vptr（虚函数表指针），当然所指向的地址（虚函数表首地址）相同。 （2）父类中有虚函数就等于子类中有虚函数。话句话来说，父类中有虚函数表，则子类中肯定有虚函数表。因为你是继承父类的。并且只要在父类中是虚函数，那么子类中即便不写virtual，也依旧是虚函数。但如果子类只继承自一个父类，则不管是父类还是子类，它们内部都只会有一个虚函数表。 （3）如果子类中完全没有新的虚函数，则我们可以认为子类的虚函数表和父类的虚函数表内容相同。但，仅仅是内容相同，这两个虚函数表在内存中处于不同位置，换句话来说，这是内容相同的两张表。 （4）虚函数表中每一项，保存着一个虚函数的首地址，但如果子类的虚函数表某项和父类的虚函数表某项代表同一个函数（这表示子类没有覆盖父类的虚函数），则该表项所执行的该函数的地址应该相同。 （5）超出虚函数表部分的内容不可知。 三、多重继承虚函数表分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//基类1class Base1&#123;public: virtual void f() &#123; cout &lt;&lt; &quot;base1::f()&quot; &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; &quot;base1::g()&quot; &lt;&lt; endl; &#125;&#125;;//基类2class Base2&#123;public: virtual void h() &#123; cout &lt;&lt; &quot;base2::h()&quot; &lt;&lt; endl; &#125; virtual void i() &#123; cout &lt;&lt; &quot;base2::i()&quot; &lt;&lt; endl; &#125;&#125;;//子类class Derived :public Base1, public Base2&#123;public: virtual void f() //覆盖父类1的虚函数 &#123; cout &lt;&lt; &quot;derived::f()&quot; &lt;&lt; endl; &#125; virtual void i() //覆盖父类2的虚函数 &#123; cout &lt;&lt; &quot;derived::i()&quot; &lt;&lt; endl; &#125; //如下三个我们自己的虚函数 virtual void mh() &#123; cout &lt;&lt; &quot;derived::mh()&quot; &lt;&lt; endl; &#125; virtual void mi() &#123; cout &lt;&lt; &quot;derived::mi()&quot; &lt;&lt; endl; &#125; virtual void mj() &#123; cout &lt;&lt; &quot;derived::mj()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; cout &lt;&lt; sizeof(Base1) &lt;&lt; endl; cout &lt;&lt; sizeof(Base2) &lt;&lt; endl; cout &lt;&lt; sizeof(Derived) &lt;&lt; endl; Derived ins; Base1 &amp;b1 = ins; //多态 Base2 &amp;b2 = ins; Derived &amp;d = ins; typedef void(*Func)(void); long *pderived1 = (long *)(&amp;ins); long *vptr1 = (long *)(*pderived1); //取第一个虚函数表指针。 long *pderived2 = pderived1 + 1; //跳过4字。 long *vptr2 = (long *)(*pderived2); //取第二个虚函数表指针。 Func f1 = (Func)vptr1[0]; //0x00ab15d7 &#123;project100.exe!Derived::f(void)&#125; Func f2 = (Func)vptr1[1]; //0x00ab15f0 &#123;project100.exe!Base1::g(void)&#125; Func f3 = (Func)vptr1[2]; //0x00ab15cd &#123;project100.exe!Derived::mh(void)&#125; Func f4 = (Func)vptr1[3]; //0x00ab15ff &#123;project100.exe!Derived::mi(void)&#125; Func f5 = (Func)vptr1[4]; //0x00ab15eb &#123;project100.exe!Derived::mj(void)&#125; Func f6 = (Func)vptr1[5]; //非正常 Func f7 = (Func)vptr1[6]; Func f8 = (Func)vptr1[7]; Func f11 = (Func)vptr2[0]; //0x00ab15af &#123;project100.exe!Base2::h(void)&#125; Func f22 = (Func)vptr2[1]; //0x00ab15b9 &#123;project100.exe!Derived::i(void)&#125; Func f33 = (Func)vptr2[2]; //非正常 Func f44 = (Func)vptr2[3]; b1.f(); b2.i(); d.f(); d.i(); d.mh(); d.g(); cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl; f1(); f2(); f3(); f4(); f5(); cout &lt;&lt; &quot;-------------&quot; &lt;&lt; endl; f11(); f22(); return 1; &#125; （1）一个对象，如果它的类有多个基类则有多个虚函数表指针（注意是多个虚函数表指针，而不是多个虚函数表）。 （2）在多继承中，对应各个基类的vptr按继承顺序依次放置在类的内存空间中，且子类与第一个基类共用一个vptr(第二个基类有自己的vptr); （3）如上程序中，子类对象ins有两个虚函数表指针，vptr1,vptr2。类Derived有两个虚函数表，因为它继承自两个基类。 （4）子类和第一个基类公用一个vptr（因为vptr指向一个虚函数表，所以也可以说子类和第一个基类共用一个虚函数表vtbl),因为我们注意到了类Derived的虚函数表1里边的5个函数，而g()正好是base1里边的函数。 （5）子类中的虚函数覆盖了父类中的同名虚函数。比如derived::f(),derived::i(); 四、vptr、vtbl创建时机 （1）vptr（虚函数表指针）跟着对象走，所以对象什么时候创建出来，vptr就什么时候创建出来。即运行的时候。实际上，对于这种有虚函数的类，在编译的时候，编译器会往相关的构造函数中增加为vptr赋值的代码，这是在编译期间编译器为构造函数增加的。当程序运行的时候，遇到创建对象的代码，执行对象的构造函数，那么这个构造函数里有给对象的vptr(成员变量)赋值的语句，自然这个对象的vptr就被赋值了。 （2）虚函数表是编译器在编译期间（不是运行期间）就为每个类确定好了对应的虚函数表vtbl的内容。然后也是在编译期间在相应的类构造函数中添加给vptr赋值的代码，这样程序运行的时候，当运行到创建类对象的代码时，会调用类的构造函数，执行到类的构造函数中的给vptr赋值的代码，这样这个类对象的vptr(虚函数表指针)就有值了。 五、普通类包含虚函数时引发的虚函数调用问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class X&#123;public: int x; int y; int z; //X() :x(0), y(0), z(0) X() &#123; //编译器角度 伪码； //vptr = vtbl; //下边的memset会把vptr（虚函数表指针）清0 memset(this, 0, sizeof(X)); cout &lt;&lt; &quot;构造函数被执行&quot; &lt;&lt; endl; &#125; //X(const X &amp;tm) :x(tm.x), y(tm.y), z(tm.z) X(const X &amp;tm) &#123; memcpy(this, &amp;tm, sizeof(X)); cout &lt;&lt; &quot;拷贝构造函数被执行&quot; &lt;&lt; endl; &#125; virtual ~X() &#123; cout &lt;&lt; &quot;析构函数被执行&quot; &lt;&lt; endl; &#125; virtual void virfunc() &#123; cout &lt;&lt; &quot;虚函数virfunc()被执行&quot; &lt;&lt; endl; &#125; void ptfunc() &#123; cout &lt;&lt; &quot;普通函数ptfunc()被执行&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; //X x0; //调用构造函数 ///*x0.x = 100; //x0.y = 200; //x0.z = 300;*/ //x0.virfunc(); //虚函数表指针为null居然可以成功调用虚函数； //X x1(x0); //调用拷贝构造函数 //cout &lt;&lt; &quot;x1.x=&quot; &lt;&lt; x1.x &lt;&lt; &quot; x1.y=&quot; &lt;&lt; x1.y &lt;&lt; &quot; x1.z=&quot; &lt;&lt; x1.z &lt;&lt; endl; //X *px0 = new X(); //px0-&gt;ptfunc(); //正常调用 //px0-&gt;virfunc(); //无法正常调用 //delete px0; //无法正常调用 //new出来的对象，虚函数变得无法正常执行了； int i = 9; printf(&quot;i的地址 = %p\n&quot;, &amp;i); X x0; printf(&quot;ptfunc()的地址=%p\n&quot;, &amp;X::ptfunc); //打印正常的成员函数地址。 //long *pvptrpar = (long *)(&amp;x0); //long *vptrpar = (long *)(*pvptrpar); //printf(&quot;virfunc的地址 = %p\n&quot;, vptrpar[1]);//虚函数virfunc地址 x0.ptfunc(); x0.virfunc(); //不叫多态，属于静态联编，我们推断：这个函数ptfunc()和virfunc()函数，是在编译的就确定好的； X *pX0 = new X(); pX0-&gt;ptfunc(); pX0-&gt;virfunc(); //通过虚函数表指针，找虚函数表，然后从虚函数表中找到virfunc虚函数的地址并调用。这就是多态 //更明白：虚函数，多态，这种概念专门给指针或者引用用的； X &amp;xy = *pX0; xy.virfunc(); X &amp;xy2 = x0; xy2.virfunc(); return 1;&#125; （1）如果一个普通类中包含了虚函数，那么在构造函数中使用如上所示的memset或者拷贝构造函数中使用如上所示的memcpy方法，那么就会出现程序崩溃的情形。 （2）某些情况下，编译器会往类内部增加一些我们看不见但真实存在的成员变量（隐藏成员变量），比如你类中增加了虚函数，系统默认往类对象中增加虚函数表指针，这个虚函数表指针就是隐藏的成员变量。有了这种变量的类，就不是普通的类了。同时，这种隐藏的成员变量的增加(使用)或者赋值的时机，往往都是在执行构造函数或者拷贝构造函数的函数体之前进行。那么你如果使用memset,memcpy，很可能把编译器给隐藏变量的值你就给清空了，要么覆盖了。 （3）静态联编是指：我们编译的时候就能确定调用哪个函数。把调用语句和被调用函数绑定到一起。动态联编是在程序运行时，根据时机情况，动态的把调用语句和被调用函数绑定到一起，动态联编一般旨有在多态和虚函数情况下才存在。 （4）对多态，虚函数，父类，子类。虚函数主要解决的问题父类指针指向子类对象这种情况。如果一个类中只有虚函数，没有继承，那么虚函数和普通函数没有区别，就算虚函数表指针被置空，仍然可通过对象正常调用，因为这是静态联编，不是多态。但是如果用new出来的对象调用，就会失败，因为虚函数表指针为空，找不到虚函数表。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象模型（1） -- 对象]]></title>
    <url>%2F2019%2F08%2F04%2FC%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、类对象所占用的空间 （1）一个空类所占用空间是一个字节，如果有成员变量，就是成员变量占用的内存。为什么空类还要占一个字节的内存？这是因为创建了一个对象就要占用一个字节的地址，就像买房子一样，空房子也是占面积的。 （2）类的成员函数不占用类对象的内存空间，而成员变量占用对象的内存空间。 （3）成员变量是包含在每个对象中的，是占用对象字节的，有多少个对象就有多少个成员变量。而对于成员函数，每个类只诞生一个（跟着类走），而不管你用这个类产生了多少个该类的对象。 二、对象结构的发展和演化 （1）非静态的成员变量(普通成员变量)跟着类对象走（存在对象内部），也就是每个类对象都有自己的成员变量。 （2）静态成员变量跟对象没有什么关系，所以肯定不会保存在对象内部，是保存在对象外面（表示所占用的内存空间和类对象无关）的，所以不计算在类对象sizeof()内。 （3）成员函数：不管静态的还是非静态，全部都保存在类对象之外。所以不管几个成员函数，不管是否是静态的成员函数，对象的sizeof的大小都是不增加的。 （4）虚函数：不管有几个虚函数，sizeof()都是多了4个字节。类里只要有一个虚函数（或者说至少有一个虚函数），这个类就会产生一个指向虚函数的指针。有两个虚函数，那么这个类就会产生两个指向虚函数的指针。而类本身指向虚函数的指针（一个或者一堆）要有地方存放，存放在一个表格里，这个表格我们就称为“虚函数表(virtual table【vtbl】)”。这个虚函数表一般是保存在可执行文件中的，在程序执行的时候载入到内存中来。 （5）虚函数表是基于类的，跟着类走的。对于类对象，这四个字节的增加，其实是因为虚函数的存在；因为有了虚函数的存在，导致系统往类对象中添加了一个指针，这个指针正好指向这个虚函数表，很多资料上把这个指针叫vptr；这个vptr的值由系统在适当的时机赋值（比如构造函数中通过增加额外的代码来给值）。 （6）如果有多个数据成员，那么为了提高访问速度，某些编译器可能会将数据成员之间的内存占用比例进行调整(内存字节对齐)。 （7）不管什么类型指针char *p,int *q;,该指针占用的内存大小是固定的。 三、this指针调整：多重继承 （1）派生类对象是包含基类子对象的。 （2）如果派生类只从一个基类继承的话，那么这个派生类对象的地址和基类子对象的地址相同。 （3）如果派生类对象同时继承多个基类，那么就要注意：第一个基类子对象的开始地址和派生类对象的开始地址相同。后续这些基类子对象的开始地址和派生类对象的开始地址相差多少呢？那就得把前边那些基类子对象所占用的内存空间累加。 （4）调用哪个子类的成员函数，这个this指针就会被编译器自动调整到对象内存布局中对应该子类对象的起始地址那去。 四、构造函数语义 传统认识认为：如果我们自己没定义任何构造函数，那么编译器就会为我们隐式自动定义一个默认的构造函数，我们称这种构造函数为：“合成的默认构造函数”。 事实是：“合成的默认构造函数”，只有在必要的时候，编译器才会为我们合成出来，而不是必然或者必须为我们合成出来。那么编译器会在哪些必要的时候帮助我们把默认的构造函数合成出来呢？ （1）该类没有任何构造函数，但包含一个类类型的成员,而该对象所属于的类有一个缺省的构造函数。这个时候，编译器就会为该类生成一个 “合成默认的构造函数”，合成的目的是为了调用类类型成员所属类里的默认构造函数。 （2）父类带缺省构造函数，子类没有任何构造函数，那因为父类这个缺省的构造函数要被调用，所以编译器会为这个子类合成出一个默认构造函数。合成的目的是为了调用这个父类的构造函数。换句话说，编译器合成了默认的构造函数，并在其中安插代码，调用其父类的默认构造函数。 （3）如果一个类含有虚函数，但没有任何构造函数时，因为虚函数的存在，编译器会给我们生成一个基于该类的虚函数表vftable。此外编译器给我们合成了一个构造函数，调用了父类的构造函数，并且在其中安插代码，把类的虚函数表地址赋给类对象的虚函数表指针（赋值语句/代码）。我们可以把虚函数表指针看成是我们表面上看不见的一个类的成员函数。 （4）当我们有自己的默认构造函数时，编译器会根据需要扩充我们自己写的构造函数代码，比如调用父类构造函数，给对象的虚函数表指针赋值。 （5）如果一个类带有虚基类，编译器也会为它合成一个默认构造函数。虚基类：通过两个直接基类（虚基类）继承同一个间接基类。所以一般是三层 ，有爷爷Grand，有两个爹A,A2，有孙子C。有虚基类结构，编译器为子类和父类都产生了“合成的默认构造函数”。 五、拷贝构造函数语义 传统上，大家认为：如果我们没有定义一个自己的拷贝构造函数，编译器会帮助我们合成 一个拷贝构造函数。 事实上，这个合成的拷贝构造函数，也是在必要的时候才会被编译器合成出来。那编译器在什么情况下会帮助我们合成出拷贝构造函数来呢？这个编译器合成出来的拷贝构造函数又要干什么事情呢？ （1）如果一个类A没有拷贝构造函数，但是含有一个类类型CTB的成员变量m_ctb。该类型CTB含有拷贝构造函数，那么当代码中有涉及到类A的拷贝构造时，编译器就会为类A合成一个拷贝构造函数。编译器合成的拷贝构造函数往往都是干一些特殊的事情。如果只是一些类成员变量值的拷贝这些事，编译器是不用专门合成出拷贝构造函数来干的，编译器内部就干了，即成员变量初始化手法，比如int这种简单类型，直接就按值拷贝过去,编译器不需要合成拷贝构造函数的情况下就帮助我们把这个事情办了。再如类A中有类类型ASon成员变量asubobj，也会递归似的去拷贝类ASon的每个成员变量。 （2）如果一个类CTBSon没有拷贝构造函数，但是它有一个父类CTB，父类有拷贝构造函数，当代码中有涉及到类CTBSon的拷贝构造时，编译器会为CTBSon合成一个拷贝构造函数，调用父类的拷贝构造函数。 （3）如果一个类CTBSon没有拷贝构造函数，但是该类声明了或者继承了虚函数，当代码中有涉及到类CTBSon的拷贝构造时，编译器会为CTBSon合成一个拷贝构造函数 ,往这个拷贝构造函数里插入语句。这个语句的含义是设定类对象的虚函数表指针值。 （4）如果一个类没有拷贝构造函数，但是该类含有虚基类，当代码中有涉及到类的拷贝构造时，编译器会为该类合成一个拷贝构造函数。 六、程序转化语义 程序转化语义主要是理解编译器如何将人类写的代码解析成编译器理解的代码。为此，从两个角度来分析。下面的代码帮助更好的理解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class X&#123;public: int m_i; X(const X &amp;tmpx) &#123; m_i = tmpx.m_i; cout &lt;&lt; &quot;拷贝构造函数被调用&quot; &lt;&lt; endl; &#125; X() &#123; m_i = 0; cout &lt;&lt; &quot;构造函数被调用&quot; &lt;&lt; endl; &#125; ~X() &#123; cout &lt;&lt; &quot;析构函数被调用&quot; &lt;&lt; endl; &#125; void functest() &#123; cout &lt;&lt; &quot;functest()被调用&quot; &lt;&lt; endl; &#125;&#125;;//参数初始化对比//人类角度void func(X tmpx)&#123; return;&#125;//老编译器看func(老编译器角度)void func(X &amp;tmpx)&#123; return;&#125;//返回值初始化对比//人类视角X func()&#123; X x0; //.... return x0; //系统产生临时对象并把x0的内容拷贝构造给了临时对象。&#125;//编译器角度的funcvoid func(X &amp;extra)&#123; X x0; //从编译器角度，这行不调用X的构造函数 //... //... extra.X::X(x0); return;&#125; 我们写的代码，编译器会对代码进行拆分，拆分成编译器更容易理解和实现的代码。看一看编译器是如何解析这些代码的。 （1）定义时初始化对象 12345678910//程序员视角X x0;x0.m_i = 15;X x1 = x0; X x2(x0);X x3 = (x0);//切换到编译器角度，编译器会拆分成两个步骤(编译器视角)X x100; //步骤一：定义一个对象，为对象分配内存。从编译器视角来看，这句是不调用X类的构造函数。x100.X::X(x0); //步骤二：直接调用对象的拷贝构造函数去了； （2）参数的初始化 12345678//程序员视角/现代编译器func(x0);//老编译器视角X tmpobj; //编译器产生一个临时对象tmpobj.X::X(x0); //调用拷贝构造函数func(tmpobj); //用临时对象调用functmpobj.X::~X(); //func()被调用完成后，本析构被调用。 （3）返回值初始化 123456789101112131415161718192021222324252627//程序员角度X my = func();//编译器对上述代码的理解(编译器角度)X my; //不会调用X的构造函数func(my);//利用返回值调用成员函数//人类视角func().functest();//切换到编译器视角X my; //不会调用X的构造函数(func(my), my).functest(); //逗号表达式：先计算表达式1，再计算表达式2，整个逗号表达式的结果是表达式2的值；//利用函数指针调用成员函数//程序员视角X(*pf)(); //定义个函数指针pf = func;pf().functest();//编译器视角X my; //不调用构造函数void (*pf)(X &amp;);pf = func;pf(my);my.functest(); 七、拷贝构造续与深浅拷贝 （1）当编译器面临用一个类对象作为另外一个类对象初值的情况，各个编译器表现不同。但是所有编译器都为了提高效率而努力。我们也没有办法确定我们自己使用的编译器是否一定会调用拷贝构造函数。 （2）拷贝构造函数不是必须有的，如果只有一些简单的成员变量类型，int,double，你会发现你根本不需要拷贝构造函数，编译器内部本身就支持成员变量的bitwise(按位)copy，即按位拷贝。 （3）当需要处理很复杂的成员变量类型的时候。因为我们增加了自己的拷贝构造函数，导致编译器本身的bitwise拷贝能力失效，它会调用我们自己的拷贝构造函数，因此如果你增加了自己的拷贝构造函数后，就要对各个成员变量的值的初始化负责了。 （4）我们自己创建内存，把目标对象的内存内容拷贝过来，叫深拷贝，例如下面的程序。相反，上述编译器做的拷贝叫浅拷贝。（注意：涉及到指针的时候，必须用深拷贝，不能浅拷贝，否则指针所指的内存会被析构两次，导致错误） 12345678910111213class X&#123;public: int m_i; int *p_mi; X(const X&amp; tmpx) &#123; p_mi = new int(100); //自己申请内存 memcpy(p_mi, tmpx.p_mi, sizeof(int)); //拷贝 m_i = tmpx.m_i; cout &lt;&lt; &quot;拷贝构造函数被调用&quot; &lt;&lt; endl; &#125;&#125;; 八、初始化列表 （1）必须使用初始化列表的情况 （a）这个成员是个引用 （b）是个const类型成员 （c）如果这个类是继承一个基类，并且基类中有构造函数，这个构造函数里边还有参数。 （d）如果成员变量类型是某个类类型，而这个类的构造函数带参数时。 （2）使用初始化列表的优势。除了必须用初始化列表的场合，我们用初始化列表还有什么其他目的？ 有，就是提高程序运行效率。对于类类型成员变量放到初始化列表中能够比较明显的看到效率的提升，但是如果是个简单类型的成员变量比如int m_test,其实放在初始化列表或者放在函数体里效率差别不大。（提醒：成员变量初始化尽量放在初始化列表里，显得高端，大气上档次） （3）初始化列表中的代码可以看作是被编译器安插到构造函数体中的，只是这些代码有些特殊。这些代码是在任何用户自己的构造函数体代码之前被执行的。所以要区分开构造函数中的用户代码和编译器插入的初始化所属的代码。 （4）初始化列表中变量的初始化顺序是变量的定义顺序，而不是在初始化列表中的顺序。不建议在初始化列表中进行两个都在初始化列表中出现的成员之间的初始化（例如：m1和m2都在初始化列表中，不建议用m1来初始化m2，或用m2初始化m1）。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL源码剖析（3）]]></title>
    <url>%2F2019%2F07%2F30%2FSTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面的话 前一篇博文介绍了迭代器，接下来介绍一下STL的大部头–容器。这一篇首先介绍序列式容器。 容器概览与分类 STL的容器是将运用最广的一些数据结构实现出来。众所周知，常用的数据结构不外乎 array, list, tree, stack, queue, hash table, set, map 等。根据数据在容器中的排列特性，这些数据结构分为序列式和关联式两种，因此容器也分为序列式容器和关联式容器。序列式容器有：array, vector, heap, priority-queue, list, slist, deque, stack, queue。关联式容器有：rb-tree, set, map, multiset, multimap, hashtable, hash-set, hash-map, hash-multiset, hash_multimap。 其中，heap是以vector为底层来实现的，priority-queue又是以heap为底层实现。而stack和queue都是以deque为原型通过配接器配接而来。关联式容器中的 set map multiset multimap 都是以 rb-tree 为底层实现, hash-set hash-map hash-multiset hash_multimap又都是以 hashtable 为底层实现。 需要注意的是，序列式容器都可序，但未必有序。接下来分别介绍各容器。 vectorvector概述 vector 的数据安排以及操作方式与 array 非常相似。两者唯一的差别在于空间的运用的灵活性。array 是静态空间，一旦配置了就不能改变，要换一个大（小）一点的空间，首先得配置一块新空间，然后从旧址一一搬往新址，再把原来的空间释放。vector 是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。因此使用 vector，我们再也不必因为害怕空间不足而一开始就要求一个大块头 array 了。 vector的迭代器 vector 维护的是一个连续的线性空间，所以不论其元素型别为何，普通指针都可以作为 vector 的迭代器而满足所有必要条件。因此 vector 的迭代器是普通指针。vector 支持随机存取，而普通指针也正有这样的能力，所以 vector 提供的是 random access iterators。 vector的数据结构 vector的数据结构比较简单，是线性连续空间。它内部维护有三个迭代器（指针）：start表示目前使用空间的头，finish表示目前使用空间的尾，end_of_storage表示目前可用空间的尾。 当我们以push_back()将新元素插入于vector尾端时，该函数首先检查是否还有备用空间，如果有就直接在备用空间上构造元素，并调整迭代器 finish，使 vector 变大。如果没有备用空间了，就扩充空间，即动态增加大小，这并不是在原空间之后接续新空间（因为无法保证原空间之后有可供配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对 vector 的任何操作，一旦引起空间重新配置，指向原 vector 的所有迭代器就都失效了。 listlist概述 list是一个链表，是由一个一个节点组成的，每一个节点结构内部有两个指针，分别指向前一个节点和后一个节点，还有一个数据域来存放节点数据。list的好处是每次插入或删除一个元素，就配置或释放一个元素空间。因此，list对空间的利用率很高，一点也不浪费。而且，对于任何位置的元素插入或元素移除，list永远是常数时间。 list的迭代器 list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在存储空间中连续存在。list迭代器必须有能力指向list的节点，并且有能力进行正确的递增、递减、取值、成员存取等操作。也就是说，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取用的是节点的成员。 由于STL的list是一个双向链表。迭代器必须具备前移、后移的能力，所以list提供的是bidirectional iterators。list在插入和接合操作的时候都不会造成原有的list迭代器失效，在删除操作的时候只有指向被删元素的那个迭代器失效，其他迭代器不受任何影响。 list的数据结构 list不仅是一个双向链表，而且还是一个环状双向链表，所以它只需要一个指针，便可完整表现整个链表。如果让该指针（注意：此指针并非前面所说的节点内部的指针，这里的指针是指向每个节点的指针）指向刻意置于尾端的一个空白节点，便能符合STL对于“前闭后开”区间的要求，成为list迭代器。list作为双向链表，在头部和尾部都可以插入数据。 dequedeque概述 deque是一种双向开口的连续线性空间。所谓双向开口，意思就是可以在头尾两端分别做元素的插入和删除操作。deque和vector的不同主要有两点：（1）vector是单向开口的空间，虽然也能在头部插入元素，但是效率极差，而deque可以在常数时间内对头部进行插入或移除操作。（2）deque没有容量的概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。而vector是因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间。 deque表面上看起来是连续空间，其实它内部是将一段一段连续空间通过中控器的操作接合起来，一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，使人们使用起来感觉像是在操作一段连续空间。它还提供了随机存取接口，避免了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器结构。 deque采用一块所谓的map作为主控，这里的map其实是一小块连续空间，其中每个元素都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的存储空间主体。通过看源码，可以发现map其实是一个指针，所指之物又是一个指针，指向另一块空间。 deque的迭代器 deque的迭代器首先必须能够指出缓冲区在哪里，其次它必须能够判断自己是否已经处于所在缓冲区的边缘，如果是，一旦前进或后退时就必须跳跃至下一个或上一个缓冲区。因此，deque的迭代器应该包括四个指针：cur指向该迭代器所指缓冲区中的当前元素，first指向该迭代器所指缓冲区的头部，last指向该迭代器所指缓冲区的尾部，node指向管控中心，用来找到迭代器所指的缓冲区。 deque的数据结构 deque除了维护一个先前说过的指向map的指针外，也维护start,finish两个迭代器，分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素的下一位置。此外，它当然也必须记住目前的map大小。因为一旦map所提供的节点不足，就必须重新配置更大的一块map。 stack和queuestack stack是一种先进后出的数据结构，它只有一个出口。stack允许新增元素、移除元素、取得顶端元素。但除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不允许有遍历行为。STL中以deque作为缺省情况下的stack底部结构。 stack所有元素的进出都必须符合先进后出的条件，只有stack顶端的元素，才有机会被外界取用。stack不提供走访功能，也不提供迭代器。另外，除了deque外，list也可以作为stack的底部容器。 queue queue是一种先进先出的数据结构。他有两个出口，允许新增元素、移除元素、从最底端加入元素、取得最顶端的元素。但是除了最底端加入、最顶端取出外，没有其他任何办法可以存取queue的其他元素。即queue不允许有遍历行为，queue也没有迭代器。STL默认将deque作为queue的底部容器，当然list也可以作为queue的底部容器。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL源码剖析（2）]]></title>
    <url>%2F2019%2F07%2F28%2FSTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面的话 上一篇博文写了STL的分配器，这一篇着重介绍一下迭代器。 迭代器介绍 我们都知道，STL中将容器和算法分离开来，彼此独立设计，以达到泛化的效果，而在使用的时候又需要将这两种东西撮合到一起，实现这个撮合功能的就是迭代器。也就是说迭代器是介于容器与算法之间的一种东西，它可以把实现某个算法所需要的容器里面的信息传递给算法，从而达到一种“桥梁”的效果。 迭代器可以看作是一种“智能指针”。它是一种行为类似指针的对象，而指针的各种行为中最常见的也是最重要的便是内容提取和成员访问，因此，迭代器最重要的编程工作就是对 operator✳ 和 operator-&gt;进行重载。关于这一点，其实跟真证的智能指针（share_ptr等）没有区别。既然迭代器实现的功能和指针一样，那为什么不直接用指针来代替迭代器呢？何必还要多此一举。这是因为，指针只能在连续空间上前进和后退，而不能随意的跳转，例如在双向链表的每一个节点中，都有两个指针，分别指向前一个元素和后一个元素，除此之外每个节点中还有另外的空间来存储数据，当指针+1的时候，它只能在该节点的连续空间上移动，而当设计好相应功能的迭代器+1的时候，可以直接跳到下一个节点，也就是说，迭代器可以实现跨区域跳转，这就是它与指针之间最大的不同。 迭代器的相应型别 我们发现，在算法中运用迭代器时，会用到迭代器的相应型别，什么是相应型别？迭代器所指之物的型别就是其中的一种。常用迭代器的相应型别有五种，分别是：value type; difference type; reference type; pointer type; iterator_category.接下来分别介绍这五种相应型别。 value type 所谓 value type，就是指迭代器所指对象的型别，任何一个打算与 STL 算法有完美搭配的类，都应该定义自己的 value type 内嵌型别。 difference type difference type 用来表示两个迭代器之间的距离，因此它也可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其最大容量，如果一个泛型算法提供计数功能，例如 STL 的 count(), 其传回值就必须使用迭代器的 difference type。 reference type 在 C++ 中，函数要传回左值，都是以传引用的方式进行，所以当 p 是个可修改值的迭代器时，如果其 value type 是 T,那么 ✳p 的型别不应该是 T，应该是 T&amp;.同理，如果 p 是一个不可修改值的迭代器，其 value type 是 T，那么 ✳p 的型别不应该是 const T,而应该是 const T&amp;。这里讨论的 ✳p 的型别，即所谓的 reference type。 pointer type 指针和引用有着非常密切的关系。如果传回一个左值，令它代表 p 所指之物是可能的，那么传回一个左值，令它代表 p 所指之物的地址也一定可以。也就是说，我们能够传回一个指针，指向迭代器所指之物。 iterator_category 这个型别表明了迭代器的类别。根据移动特性和施行操作，迭代器被分为五类：input iterator（只读，即这种迭代器所指的对象不允许外界改变）；output iterator（只写，即该迭代器所指的对象只能被外界改变，不能读取）；forward iterator（单向读写）；bidirectional iterator（双向读写）；random access iterator（随机读写）。 以上五种迭代器的类别，前三种支持 operator++，第四种再加上 operator–，第五种则涵盖所有指针算术能力，包括 p+n, p-n, p[n], p1-p2, p1&lt;p2。在设计算法时，应该尽量对迭代器的类型做一个明确的规定，这样才能在不同情况下提供最大的效率。假设有个算法可接受 forward iterator ,你给它传一个 random access iteator 进去，它当然也会接受，因为一个 random access iteator 必然是一个 forward iteator,但是从效率上来讲，这并不是最佳的方案。 Traits编程技法 traits用来提取对象的型别，对应的模板参数不管是泛化版本还是特化版本，通通都能准确的萃取出来。如果传进来的参数 I 定义有自己的 value type，那么通过 traits,萃取出来的 value type 就是 I::value type。如果是特化版本，例如 T✳，则萃取出来的 value type 就是 T。特别注意，const T✳，萃取出来后也是 T 而非 const T,这是因为我们的本意就是声明一个临时变量，使之与迭代器的 value type 相同，而如果声明一个无法赋值的变量，没有什么作用，因此，对于 const 类型的变量，萃取出来的 value type就会变成 non-const类型。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL源码剖析（1）]]></title>
    <url>%2F2019%2F07%2F26%2FSTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面的话 近段时间看了侯捷老师的《STL源码剖析》，看第一遍的时候一头雾水，反复多看几遍，似乎明白了一些。因此将学到的知识做一个记录，也算是记录自己的学习过程。本系列博客主要记录一些宏观理解性的东西，具体的代码实现还是要仔细品味原书。 概览 STL即C++标准模板库，主要由六大部件组成，分别是：分配器、容器、迭代器、算法、仿函数、配接器。这六大部件之间的交互关系表现为：容器通过分配器取得数据存储空间，算法通过迭代器存取容器的内容，仿函数可以协助算法完成不同的策略变化，配接器可以修饰或套接仿函数、迭代器、容器等。 在讲述这些主要部件之前，先来了解一下面向对象编程和泛型编程，面向对象编程（Object-Oriented programming，简称OOP）企图将数据和处理数据的方法放到一起，例如，在C++的类中，一般会有成员变量和处理成员变量的成员函数，在需要使用的时候创建一个对象，然后以对象来调用它们。而泛型编程（Generic Programming,简称GP）是将数据和处理方法分离开来，这里的处理方法通常是全局函数，例如STL中的算法和容器，两者互不影响，需要的时候通过迭代器来传递信息。 好了，接下来就从这六大部件出发，了解STL的内部关系。这篇博文主要记录分配器的重点。 分配器（allocators） allocator主要是用来管理存储空间，它当中的 allocate() 调用 operator new() 来分配空间，其中 operator new() 中又调用了C语言中的 malloc() 函数，而 deallocate() 则调用了operator delete(),其中，operator delete() 又调用了 free() 来释放内存。以上谈的这种分配器是标准规范下的实现方法。而SGI STL有一种默认的分配器 alloc ，它的每一个容器都已经指定其缺省的空间分配器为 alloc，例如下面的 vector 声明： template &lt;class T, class Alloc = alloc&gt; class vector{…}; 这其中就是缺省使用的 alloc 为分配器。由于调用 malloc() 只会寻找整片比较大的空间，对于一些小型区块，可能造成内存浪费的问题,因此，SGI设计了双级分配器，第一级分配器直接使用 malloc() 和 free()，第二级分配器则视情况采用不同的策略：当配置区块超过128字节时，视之为 “足够大”，便调用第一级分配器 ，当分配区块小于128字节时，视之为 “过小”，为了降低额外负担（合理利用资源），就使用第二级分配器。 而第二级分配器的具体实现是以内存池管理的形式，每次配置一块大内存，然后维护对应的自由链表（可增加，也可删减），下次如果再有相同大小的内存需求，就直接从自由链表中取出，如果使用方释放了小块内存，则由分配器回收到对应的链表中。为了方便管理，SGI的第二级分配器会主动将任何小额区块的内存需求上调至8的倍数（例如使用者需要30字节，就自动调整为32字节），并维护16个自由链表，各自管理的大小分别为：8，16，24，32，40，56，64，72，80，88，96，104，112，128字节的小额区块（例如：第一个链表节点就管理空间内所有大小为8字节的小区快，第二个节点管理所有大小为16字节的小区快，以此类推）。 因此，整个的内存分配释放过程即可归纳为如下流程：分配器拥有标准接口函数 allocate()，此函数首先判断区块的大小，大于128字节就调用第一级分配器，小于128字节就检查对应的自由链表。如果自由链表内有可用的区块，就直接拿来用，如果没有可用的区块，就将区块大小上调至8的倍数，然后重新填充空间。 在释放的时候，同样由分配器的标准接口函数 deallocate() 首先判断区块大小，大于128字节就调用第一级分配器，小于128字节就找出对应的自由链表，将区块回收。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2019%2F07%2F13%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[写博客的想法是怎么产生的前两天在B站上偶然看见一个免费搭建个人博客的教程，于是产生了兴趣。尝试去搜索了一下，竟然发现有好多搭建博客的方法，实在是感觉自己好low，不过，总归现在发现还不算太晚（强行安慰。。）于是按照搜索的几种方法都进行了尝试，最终选择了用 hexo 配合 github 搭建了第一个属于自己的个人博客（正是此博客）。虽然现在看起来有点low，但是基本功能还算齐全，其他华丽的功能有待开发。 写博客的目的博客站点搭建好了，当然也要开始养成写博客的习惯了。之前在网上搜索一些问题的时候总是能看到各种大佬级别的博客，都写得特别好，虽然我也有过写博客的想法，但是一直没有付诸行动，这次搭建了自己的站点，再不写点就说不过去了，总不能就光秃秃的一个页面，什么内容也没有吧。所以借着这次机会，总算能治一治我的拖延症了。至于本博客的目的，就当是记录自己的生活，学习过程。如果能帮到别人，那自然是更好。 博客内容对于博客内容，我初步打算分为以下几个类别：生活、技术、读书笔记等。生活类的文章主要谈一些我所经历过的值得记录的事情以及感想；技术方面主要就是在学习过程中的一些积累（这方面可能会写的比较多一点）。读书笔记则会在我每读完一本书的时候做一些总结，方便以后查阅（主要是指技术书籍）。当然后续还有其他有趣的版块分类，我也会加进去。 期待的样子 我所期待的博客当然是不仅能够连贯地记录自己的生活，而且能够利用自己的知识帮助更多的人。然而，道理我们都懂，一口吃不成胖子，而且万事开头难，所以要一步一步来，努力把它打造成自己喜欢的样子。]]></content>
      <categories>
        <category>生活杂谈</category>
      </categories>
      <tags>
        <tag>生活杂谈</tag>
      </tags>
  </entry>
</search>
