<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuruijie</title>
  
  <subtitle>快乐搬砖，码出未来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liuruijie87.github.io/"/>
  <updated>2020-05-17T07:26:33.717Z</updated>
  <id>https://liuruijie87.github.io/</id>
  
  <author>
    <name>liuruijie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP/IP协议体系架构</title>
    <link href="https://liuruijie87.github.io/2020/05/17/TCP-IP%E5%8D%8F%E8%AE%AE%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/"/>
    <id>https://liuruijie87.github.io/2020/05/17/TCP-IP协议体系架构/</id>
    <published>2020-05-17T07:06:12.332Z</published>
    <updated>2020-05-17T07:26:33.717Z</updated>
    
    <content type="html"><![CDATA[<p>　　在学习完TCP/IP协议后，个人感觉有几个重要的概念值得重视，所以记录在此。</p><h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><p>　　TCP-IP协议的体系结构如下图，其中，数据链路层、网络层、传输层在内核中实现，因为这些既高效又稳定，而应用层负责处理应用程序的逻辑，因此在用户态实现。</p><img src="/2020/05/17/TCP-IP协议体系架构/1_TCP-IP协议族体系结构.png"><h1 id="数据链路层之ARP协议"><a href="#数据链路层之ARP协议" class="headerlink" title="数据链路层之ARP协议"></a>数据链路层之ARP协议</h1><p>　　ARP协议属于数据链路层中的协议。网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器，因此网络层必须先将目标机器的IP地址转换为其物理地址，才能使用数据链路层提供的服务，这就是ARP协议的用途。</p><h1 id="网络层及网络层协议"><a href="#网络层及网络层协议" class="headerlink" title="网络层及网络层协议"></a>网络层及网络层协议</h1><p>　　网络层实现数据包的选路和转发。通信的两台主机一般不是直接相连的，而是通过多个中间节点（路由器）连接的，网络层的任务就是选择这些中间节点，以确定两台主机之间的通信路径。同时，网络层对上层协议隐藏了网络拓扑连接的细节，使得在传输层和网络应用程序看来，通信的双方是直接相连的。网络层的协议有ICMP协议和IP协议。</p><h1 id="传输层之TCP协议"><a href="#传输层之TCP协议" class="headerlink" title="传输层之TCP协议"></a>传输层之TCP协议</h1><p>　　TCP协议（传输控制协议）为应用层提供可靠的、面向连接的和基于流的服务。TCP协议使用超时重传、数据确认等方式来确保数据包正确地发送至目的端，因此TCP服务是可靠的。TCP服务是基于流的。基于流的数据没有边界限制，它源源不断地从通信的一端流入另一端。发送端可以逐个字节地向数据流写入数据，接收端也可以逐个字节地将它们读出。</p><h1 id="传输层之UDP协议"><a href="#传输层之UDP协议" class="headerlink" title="传输层之UDP协议"></a>传输层之UDP协议</h1><p>　　UDP协议为应用层提供不可靠、无连接和基于数据报的服务。使用UDP协议的应用程序通常要自己处理数据确认、超时重传等逻辑。UDP协议是无连接的，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP地址等信息）。基于数据报的服务，是相对基于流的服务而言的。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。</p><h1 id="协议封装"><a href="#协议封装" class="headerlink" title="协议封装"></a>协议封装</h1><p>　　所谓封装，其实就是将上层的数据加上本层的头部或尾部。应用层数据经过层层封装，最终被封装成帧的形式，帧是最后在物理网络上传送的字节序列。</p><img src="/2020/05/17/TCP-IP协议体系架构/2_协议封装.png"><h1 id="协议分用"><a href="#协议分用" class="headerlink" title="协议分用"></a>协议分用</h1><p>　　当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协议通过处理本层负责的头部数据，以获得所需的信息，这就是分用。最终会将应用数据传递给应用层使用。</p><img src="/2020/05/17/TCP-IP协议体系架构/3_协议分用.png"><h1 id="协议类型"><a href="#协议类型" class="headerlink" title="协议类型"></a>协议类型</h1><p>　　由于IP协议、ARP协议、RARP协议都使用帧传输数据，所以帧的头部需要提供某个字段来区分它们。以以太网帧为例，它使用2字节的类型字段来标识上层协议。如果主机接收到的以太网帧类型字段的值为0x800，则为IP数据报，以太网驱动程序就将帧交付给IP模块。若值为0x806，则为ARP请求或应答报文。若值为0x835，则帧的数据部分为RARP请求或应答报文。</p><h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><p>　　Socket是一套应用程序编程接口，即API。能够实现系统调用，使得应用程序能够访问内核中协议提供的服务。<br>　　由socket定义的API提供两点功能：一是将应用程序的数据从用户缓冲区复制到TCP/UDP内核发送缓冲区，以交付内核来发送数据，或从内核TCP/UDP接受缓冲区复制数据到用户缓冲区，以读取数据。二是应用程序可以通过它们来修改内核中各层协议的某些头部信息或其他数据结构，从而精细地控制底层通信的行为。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　在学习完TCP/IP协议后，个人感觉有几个重要的概念值得重视，所以记录在此。&lt;/p&gt;
&lt;h1 id=&quot;体系结构&quot;&gt;&lt;a href=&quot;#体系结构&quot; class=&quot;headerlink&quot; title=&quot;体系结构&quot;&gt;&lt;/a&gt;体系结构&lt;/h1&gt;&lt;p&gt;　　TCP-IP协议的体系结
      
    
    </summary>
    
      <category term="技术积累" scheme="https://liuruijie87.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="TCP/IP" scheme="https://liuruijie87.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>浅谈TCP协议</title>
    <link href="https://liuruijie87.github.io/2020/05/17/%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://liuruijie87.github.io/2020/05/17/浅谈TCP协议/</id>
    <published>2020-05-17T07:02:04.032Z</published>
    <updated>2020-05-17T07:04:58.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="含有汇编代码的vs2017工程编译错误"><a href="#含有汇编代码的vs2017工程编译错误" class="headerlink" title="含有汇编代码的vs2017工程编译错误"></a>含有汇编代码的vs2017工程编译错误</h1><p>　　当一个项目工程中含有汇编代码，在编译的时候可能会出现以下的错误。</p><h2 id="‘yasm’-不是内部或外部命令"><a href="#‘yasm’-不是内部或外部命令" class="headerlink" title="‘yasm’ 不是内部或外部命令"></a>‘yasm’ 不是内部或外部命令</h2><p>　　这是因为yasm.exe的路径不对，如果没有装yasm，则在 <a href="http://www.tortall.net/projects/yasm/wiki/Download" target="_blank" rel="noopener">http://www.tortall.net/projects/yasm/wiki/Download</a> 这里下载yasm，然后将vsyasm.exe 改名yasm.exe复制到VC安装目录，例如：D:\soft\vs2017\Common7\IDE。重新编译，即可成功。</p><h2 id="Microsoft-CppCommon-targets-172-5-error-MSB6006-“cmd-exe”已退出，代码为-9009。"><a href="#Microsoft-CppCommon-targets-172-5-error-MSB6006-“cmd-exe”已退出，代码为-9009。" class="headerlink" title="Microsoft.CppCommon.targets(172,5): error MSB6006: “cmd.exe”已退出，代码为 9009。"></a>Microsoft.CppCommon.targets(172,5): error MSB6006: “cmd.exe”已退出，代码为 9009。</h2><p>　　还是因为项目工程中有汇编代码，而汇编代码没有编译通过，所以导致这个错误，解决方法参考第一个错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;含有汇编代码的vs2017工程编译错误&quot;&gt;&lt;a href=&quot;#含有汇编代码的vs2017工程编译错误&quot; class=&quot;headerlink&quot; title=&quot;含有汇编代码的vs2017工程编译错误&quot;&gt;&lt;/a&gt;含有汇编代码的vs2017工程编译错误&lt;/h1&gt;&lt;p&gt;　　
      
    
    </summary>
    
      <category term="技术积累" scheme="https://liuruijie87.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="TCP" scheme="https://liuruijie87.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>含有汇编代码的编译错误</title>
    <link href="https://liuruijie87.github.io/2020/05/04/%E5%90%AB%E6%9C%89%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF/"/>
    <id>https://liuruijie87.github.io/2020/05/04/含有汇编代码的编译错误/</id>
    <published>2020-05-04T07:04:36.786Z</published>
    <updated>2020-05-04T07:26:49.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="含有汇编代码的vs2017工程编译错误"><a href="#含有汇编代码的vs2017工程编译错误" class="headerlink" title="含有汇编代码的vs2017工程编译错误"></a>含有汇编代码的vs2017工程编译错误</h1><p>　　当一个项目工程中含有汇编代码，在编译的时候可能会出现以下的错误。</p><h2 id="‘yasm’-不是内部或外部命令"><a href="#‘yasm’-不是内部或外部命令" class="headerlink" title="‘yasm’ 不是内部或外部命令"></a>‘yasm’ 不是内部或外部命令</h2><p>　　这是因为yasm.exe的路径不对，如果没有装yasm，则在 <a href="http://www.tortall.net/projects/yasm/wiki/Download" target="_blank" rel="noopener">http://www.tortall.net/projects/yasm/wiki/Download</a> 这里下载yasm，然后将vsyasm.exe 改名yasm.exe复制到VC安装目录，例如：D:\soft\vs2017\Common7\IDE。重新编译，即可成功。</p><h2 id="Microsoft-CppCommon-targets-172-5-error-MSB6006-“cmd-exe”已退出，代码为-9009。"><a href="#Microsoft-CppCommon-targets-172-5-error-MSB6006-“cmd-exe”已退出，代码为-9009。" class="headerlink" title="Microsoft.CppCommon.targets(172,5): error MSB6006: “cmd.exe”已退出，代码为 9009。"></a>Microsoft.CppCommon.targets(172,5): error MSB6006: “cmd.exe”已退出，代码为 9009。</h2><p>　　还是因为项目工程中有汇编代码，而汇编代码没有编译通过，所以导致这个错误，解决方法参考第一个错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;含有汇编代码的vs2017工程编译错误&quot;&gt;&lt;a href=&quot;#含有汇编代码的vs2017工程编译错误&quot; class=&quot;headerlink&quot; title=&quot;含有汇编代码的vs2017工程编译错误&quot;&gt;&lt;/a&gt;含有汇编代码的vs2017工程编译错误&lt;/h1&gt;&lt;p&gt;　　
      
    
    </summary>
    
      <category term="技术积累" scheme="https://liuruijie87.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="编译错误" scheme="https://liuruijie87.github.io/tags/%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="https://liuruijie87.github.io/2020/04/06/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://liuruijie87.github.io/2020/04/06/git常用命令/</id>
    <published>2020-04-06T08:23:23.964Z</published>
    <updated>2020-04-07T09:33:16.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><h3 id="在Linux上安装Git"><a href="#在Linux上安装Git" class="headerlink" title="在Linux上安装Git"></a>在Linux上安装Git</h3><p>　　在Ubuntu Linux中，使用 sudo apt-get install git 完成安装。<br>　　如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。　　</p><h3 id="在Mac-OS-X上安装Git"><a href="#在Mac-OS-X上安装Git" class="headerlink" title="在Mac OS X上安装Git"></a>在Mac OS X上安装Git</h3><p>　　一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/。" target="_blank" rel="noopener">http://brew.sh/。</a><br>　　第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p><h3 id="在Windows上安装Git"><a href="#在Windows上安装Git" class="headerlink" title="在Windows上安装Git"></a>在Windows上安装Git</h3><p>　　从Git官网直接下载 <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a> 然后按默认选项安装即可。<br>　　安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！<br>　　<strong>安装完成后，还需要最后一步设置，在命令行输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><p>　　注意config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h2 id="创建版本库、提交文件"><a href="#创建版本库、提交文件" class="headerlink" title="创建版本库、提交文件"></a>创建版本库、提交文件</h2><p>　　选择一个合适的地方，创建一个空目录，然后创建文本文件，可以使用Notepad++编辑文本文件，默认编码设置为UTF-8 without BOM。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd  //查看当前工作目录</span><br><span class="line">$ git init  //把这个目录变成Git可以管理的仓库，此时以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，最好不要修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。如果没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</span><br><span class="line">$ git add readme.txt //把文件（readme.txt）添加到仓库</span><br><span class="line">$ git commit -m &quot;wrote a readme file&quot; //把文件提交到仓库，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样就能从历史记录里方便地找到改动记录。</span><br><span class="line">//为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件。</span><br></pre></td></tr></table></figure><h2 id="查看仓库状态、文件修改、版本回退和前进"><a href="#查看仓库状态、文件修改、版本回退和前进" class="headerlink" title="查看仓库状态、文件修改、版本回退和前进"></a>查看仓库状态、文件修改、版本回退和前进</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git status //可以让我们时刻掌握仓库当前的状态</span><br><span class="line">$ git diff readme.txt  //查看difference，知道了对readme.txt作了什么修改</span><br><span class="line">$ git log //显示从最近到最远的提交日志</span><br><span class="line">$ git log --pretty=oneline //简化版的查看提交日志</span><br><span class="line">$ git reset --hard HEAD^ //回退到上一个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。回退到前面版本，如果还想再回到最新版本，可以用 git reset --hard 版本号（不用写全）</span><br><span class="line">$ cat readme.txt //查看文件内容</span><br><span class="line">$ git reflog //记录每一次命令（可以查看版本号）</span><br><span class="line">$ git checkout -- readme.txt //撤销修改</span><br><span class="line">$ git reset HEAD readme.txt //把暂存区的修改回退到工作区</span><br><span class="line">$ rm test.txt //删除了工作区的文件</span><br><span class="line">$ git rm test.txt //从版本库中删除该文件，还需要git commit -m &quot;remove test.txt，才能彻底删除文件。</span><br><span class="line">$ git checkout -- test.txt //误删后因为版本库里还有，所以可以很轻松地把误删的文件恢复到最新版本。</span><br><span class="line">//git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</span><br><span class="line">//注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</span><br></pre></td></tr></table></figure><p>　　场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。<br>　　场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了场景1，第二步按场景1操作。<br>　　场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</file></p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git常用命令&quot;&gt;&lt;a href=&quot;#Git常用命令&quot; class=&quot;headerlink&quot; title=&quot;Git常用命令&quot;&gt;&lt;/a&gt;Git常用命令&lt;/h1&gt;&lt;h2 id=&quot;安装Git&quot;&gt;&lt;a href=&quot;#安装Git&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="技术积累" scheme="https://liuruijie87.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="git" scheme="https://liuruijie87.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>malloc和free详解</title>
    <link href="https://liuruijie87.github.io/2020/03/15/malloc%E5%92%8Cfree%E8%AF%A6%E8%A7%A3/"/>
    <id>https://liuruijie87.github.io/2020/03/15/malloc和free详解/</id>
    <published>2020-03-15T06:42:48.989Z</published>
    <updated>2020-03-15T07:13:00.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="malloc和free详解"><a href="#malloc和free详解" class="headerlink" title="malloc和free详解"></a>malloc和free详解</h1><h2 id="malloc的实质"><a href="#malloc的实质" class="headerlink" title="malloc的实质"></a>malloc的实质</h2><p>　　malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。如果无法获得符合要求的内存块，malloc函数会返回NULL指针，因此在调用malloc动态申请内存块时，一定要进行返回值的判断。</p><h2 id="malloc-到底从哪里得来了内存空间"><a href="#malloc-到底从哪里得来了内存空间" class="headerlink" title="malloc()到底从哪里得来了内存空间"></a>malloc()到底从哪里得来了内存空间</h2><p>　　１、malloc()到底从哪里得到了内存空间？答案是从堆里面获得空间。也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。就是这样！     　　说到这里，不得不另外插入一个小话题。什么是堆？说到堆，又忍不住说到了栈！什么是栈？下面就另外开个小部分专门而又简单地说一下这个题外话。<br>　　2、什么是堆：堆是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。  　　什么是栈：栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS/ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。<br>　　通过上面对概念的描述，可以知道：栈是由编译器自动分配释放，存放函数的参数值、局部变量的值等。操作方式类似于数据结构中的栈。堆一般由程序员分配释放，若不释放，程序结束时可能由OS回收。注意这里说是可能，并非一定。所以再强调一次，记得要释放！注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。<br>　　举个例子，如果你在函数上面定义了一个指针变量，然后在这个函数里申请了一块内存让指针指向它。实际上，这个指针的地址是在栈上，但是它所指向的内容却是在堆上面的！这一点要注意！所以，再想想，在一个函数里申请了空间后，比如说下面这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void Function(void) </span><br><span class="line">&#123; </span><br><span class="line">char *p = (char *)malloc(100 * sizeof(char)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　就这个例子，千万不要认为函数返回，函数所在的栈被销毁指针也跟着销毁，申请的内存也就一样跟着销毁了！这绝对是错误的！因为申请的内存在堆上，而函数所在的栈被销毁跟堆完全没有啥关系。所以，还是那句话：记得释放！</p><h2 id="free-到底释放了什么"><a href="#free-到底释放了什么" class="headerlink" title="free()到底释放了什么"></a>free()到底释放了什么</h2><p>　　free()释放的是指针指向的内存！注意！释放的是内存，不是指针！这点非常非常重要！指针是一个变量，只有程序结束时才被销毁。释放了内存空间后，原来指向这块空间的指针还是存在！只不过现在指针指向的内容的垃圾，是未定义的，所以说是垃圾。因此，前面我已经说过了，释放内存后把指针指向NULL，防止指针在后面不小心又被解引用了。这一点非常重要！</p><h2 id="malloc-以及free-的机制"><a href="#malloc-以及free-的机制" class="headerlink" title="malloc()以及free()的机制"></a>malloc()以及free()的机制</h2><p>　　事实上，仔细看一下free()的函数原型，也许也会发现似乎很神奇，free()函数非常简单，只有一个参数，只要把指向申请空间的指针传递给free()中的参数就可以完成释放工作！这里要追踪到malloc()的申请问题了。申请的时候实际上占用的内存要比申请的大。因为超出的空间是用来记录对这块内存的管理信息。先看一下在《UNIX环境高级编程》中第七章的一段话：   　　大多数实现所分配的存储空间比所要求的要稍大一些，额外的空间用来记录管理信息——分配块的长度，指向下一个分配块的指针等等。这就意味着如果写过一个已分配区的尾端，则会改写后一块的管理信息。这种类型的错误是灾难性的，但是因为这种错误不会很快就暴露出来，所以也就很难发现。将指向分配块的指针向后移动也可能会改写本块的管理信息。   　　以上这段话已经给了我们一些信息了。malloc()申请的空间实际就是分了两个不同性质的空间。一个就是用来记录管理信息的空间，另外一个就是可用空间了。而用来记录管理信息的实际上是一个结构体。在C语言中，用结构体来记录同一个对象的不同信息是天经地义的事！下面看看这个结构体的原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct mem_control_block </span><br><span class="line">&#123; </span><br><span class="line">    int is_available;    //这是一个标记？ </span><br><span class="line">    int size;            //这是实际空间的大小 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　对于size,这个是实际空间大小。而is_available是否是一个标记？free()就是根据这个结构体的信息来释放malloc()申请的空间！而结构体的两个成员的大小我想应该是操作系统的事了。但是这里有一个问题，malloc()申请空间后返回一个指针应该是指向第二种空间，也就是可用空间！不然，如果指向管理信息空间的话，写入的内容和结构体的类型有可能不一致，或者会把管理信息屏蔽掉，那就没法释放内存空间了，所以会发生错误！接下来分析free()的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void free(void *ptr)      </span><br><span class="line">&#123;</span><br><span class="line">struct mem_control_block *free;             </span><br><span class="line">free = ptr - sizeof(struct mem_control_block);             </span><br><span class="line">free-&gt;is_available = 1;             </span><br><span class="line">return;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　看一下函数第二句，这句非常重要和关键。其实这句就是把指向可用空间的指针倒回去，让它指向管理信息的那块空间，因为这里是在值上减去了一个结构体的大小！后面那一句free-&gt;is_available = 1;这里is_available应该只是一个标记而已！因为从这个变量的名称上来看，is_available翻译过来就是“是可以用”。这个变量的值是1，表明是可以用的空间！如果把它改为0或者是其他值不知道会发生什么事？！但是有一点可以肯定，就是释放绝对不会那么顺利进行！因为这是一个标记！<br>　　当然，这里可能还是有人会有疑问，为什么这样就可以释放呢？就free()这个源代码来看，什么也没有释放。但是它确实是确定了管理信息的那块内存的内容。所以，free()只是记录了一些信息，然后告诉操作系统那块内存可以去释放，然后由操作系统来释放那段内存。之前一个错误的认识，就是认为指向那块内存的指针不管移到那块内存中的哪个位置都可以释放那块内存！但是，这是大错特错！释放是不可以释放一部分的！首先这点应该要明白。而且，从free()的源代码看，ptr只能指向可用空间的首地址，不然，减去结构体大小之后一定不是指向管理信息空间的首地址。所以，要确保指针指向可用空间的首地址！如若验证，可以写一个程序然后移动指向可用空间的指针，看程序会不会崩溃！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;malloc和free详解&quot;&gt;&lt;a href=&quot;#malloc和free详解&quot; class=&quot;headerlink&quot; title=&quot;malloc和free详解&quot;&gt;&lt;/a&gt;malloc和free详解&lt;/h1&gt;&lt;h2 id=&quot;malloc的实质&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="技术积累" scheme="https://liuruijie87.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="malloc和free" scheme="https://liuruijie87.github.io/tags/malloc%E5%92%8Cfree/"/>
    
  </entry>
  
  <entry>
    <title>一个细胞的生命周期是3小时，1小时分裂一次，求n小时后容器内有多少个细胞。</title>
    <link href="https://liuruijie87.github.io/2020/03/06/%E7%BB%86%E8%83%9E%E5%88%86%E8%A3%82%E6%89%BE%E8%A7%84%E5%BE%8B%E9%A2%98/"/>
    <id>https://liuruijie87.github.io/2020/03/06/细胞分裂找规律题/</id>
    <published>2020-03-06T10:49:05.072Z</published>
    <updated>2020-03-06T11:09:48.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个细胞的生命周期是3小时，1小时分裂一次，求n小时后容器内有多少个细胞。"><a href="#一个细胞的生命周期是3小时，1小时分裂一次，求n小时后容器内有多少个细胞。" class="headerlink" title="一个细胞的生命周期是3小时，1小时分裂一次，求n小时后容器内有多少个细胞。"></a>一个细胞的生命周期是3小时，1小时分裂一次，求n小时后容器内有多少个细胞。</h1><p>　　假设经过三个小时的细胞分裂后再死亡。根据题意，细胞的生命周期是三个小时，一个小时后，第一个细胞分裂，此时细胞总数变成2，但是这两个细胞的生存时间是不一样的，如果都当成新生细胞即存活时间为0，那么给定的3小时生命周期也就没意义了，所以这个时候其中一个细胞的生存时间变成了1，另外一个刚分裂出来的是0，下面简单表示一下分裂进程（-1表示死亡）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">时间 细胞状态 (生存时间) 细胞总数</span><br><span class="line">0 0 1</span><br><span class="line">1 1 0 2</span><br><span class="line">2 2 1 0 0 4</span><br><span class="line">3 -1 2 1 1 0 0 0 0 7</span><br><span class="line">4 -1 2 2 1 1 1 1 0 0 0 0 0 0 0 13</span><br><span class="line">5 -1 -1 2 2 2 2 1 1 1 1 1 1 1</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 24</span><br><span class="line">… … …</span><br><span class="line">f0 = 1</span><br><span class="line">f1 = 2</span><br><span class="line">f2 = 4</span><br><span class="line">f3 = 7</span><br></pre></td></tr></table></figure><p>可以发现到第四个小时的时候，规律出来了，在第四个小时死亡的细胞是三小时前也就是第一个小时的时候同时出生的细胞，而在第一个小时同时出生的细胞数等于第一个小时前一个小时的细胞总数<br>所以有递推式：f(n) = 2f(n - 1) - f(n - 4)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一个细胞的生命周期是3小时，1小时分裂一次，求n小时后容器内有多少个细胞。&quot;&gt;&lt;a href=&quot;#一个细胞的生命周期是3小时，1小时分裂一次，求n小时后容器内有多少个细胞。&quot; class=&quot;headerlink&quot; title=&quot;一个细胞的生命周期是3小时，1小时分
      
    
    </summary>
    
      <category term="题集" scheme="https://liuruijie87.github.io/categories/%E9%A2%98%E9%9B%86/"/>
    
    
      <category term="细胞分裂" scheme="https://liuruijie87.github.io/tags/%E7%BB%86%E8%83%9E%E5%88%86%E8%A3%82/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议如何保证数据传输的可靠性</title>
    <link href="https://liuruijie87.github.io/2020/03/06/TCP%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/"/>
    <id>https://liuruijie87.github.io/2020/03/06/TCP协议如何保证数据传输的可靠性/</id>
    <published>2020-03-06T05:14:22.413Z</published>
    <updated>2020-03-06T05:48:16.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP协议如何保证数据传输的可靠性"><a href="#TCP协议如何保证数据传输的可靠性" class="headerlink" title="TCP协议如何保证数据传输的可靠性"></a>TCP协议如何保证数据传输的可靠性</h1><p>　　TCP协议传输的特点主要就是面向字节流、传输可靠、面向连接。<br>　　TCP协议保证数据传输可靠性的方式主要有：校验和、序列号、确认应答、超时重传、连接管理、流量控制、拥塞控制。</p><h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><p>　　计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。<br>　　发送方：在发送数据之前计算检验和，并进行校验和的填充。<br>　　接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。<br>　　<strong>注意：</strong>如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是如果接收方比对校验和与发送方一致，数据不一定传输成功。</p><h2 id="确认应答与序列号"><a href="#确认应答与序列号" class="headerlink" title="确认应答与序列号"></a>确认应答与序列号</h2><p>　　序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。<br>　　确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>　　在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟没有等到接收方的ACK报文，这该怎么办呢？而没有收到ACK报文的原因可能是什么呢？<br>　　首先，发送方没有介绍到响应的ACK报文原因可能有两点：<br>　　1.数据在传输过程中由于网络原因等直接全体丢包，接收方根本没有接收到。<br>　　2.接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。<br>　　TCP在解决这个问题的时候引入了一个新的机制，叫做超时重传机制。简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。<br>　　那么发送方发送完毕后等待的时间是多少呢？如果这个等待的时间过长，那么会影响TCP传输的整体效率，如果等待时间过短，又会导致频繁的发送重复的包。如何权衡？<br>　　由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待的时间）是动态计算的。<br>　　<em>在Linux中（BSD Unix和Windows下也是这样）超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，仍未响应，那么等待2x500ms的时间后，再次重传。等待4x500ms的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP就认为网络或者对端出现异常，强制关闭连接。</em></p><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p>　　连接管理就是三次握手与四次挥手的过程。保证可靠的连接，是保证可靠性的前提。</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>　　接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传呀什么的。而TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。<br>　　在TCP协议的报头信息当中，有一个16位字段的窗口大小。在介绍这个窗口大小时我们知道，窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小。这个数字越大，证明接收端接收缓冲区的剩余空间越大，网络的吞吐量越大。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。<br>　　<strong>注：</strong>16位的窗口大小最大能表示65535个字节（64K），但是TCP的窗口大小最大并不是64K。在TCP首部中40个字节的选项中还包含了一个窗口扩大因子M，实际的窗口大小就是16为窗口字段的值左移M位。每移一位，扩大两倍。 </p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>　　TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。<br>　　所以TCP引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。发送刚开始定义拥塞窗口为1，每次收到ACK应答，拥塞窗口加1。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。<br>　　拥塞窗口的增长是指数级别的。慢启动的机制只是说明在开始的时候发送的少，发送的慢，但是增长的速度是非常快的。为了控制拥塞窗口的增长，不能使拥塞窗口单纯的加倍，设置一个拥塞窗口的阈值，当拥塞窗口大小超过阈值时，不能再按照指数来增长，而是线性的增长。在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，慢启动的阈值会为原来的一半（这里的原来指的是发生网络拥塞时拥塞窗口的大小），同时拥塞窗口重置为1。<br>　　拥塞控制是TCP在传输时尽可能快的将数据传输，并且避免拥塞造成的一系列问题。是可靠性的保证，同时也是维护了传输的高效性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TCP协议如何保证数据传输的可靠性&quot;&gt;&lt;a href=&quot;#TCP协议如何保证数据传输的可靠性&quot; class=&quot;headerlink&quot; title=&quot;TCP协议如何保证数据传输的可靠性&quot;&gt;&lt;/a&gt;TCP协议如何保证数据传输的可靠性&lt;/h1&gt;&lt;p&gt;　　TCP协议传输的
      
    
    </summary>
    
      <category term="技术积累" scheme="https://liuruijie87.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="TCP" scheme="https://liuruijie87.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>一次完整的http请求过程</title>
    <link href="https://liuruijie87.github.io/2020/03/05/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84http%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <id>https://liuruijie87.github.io/2020/03/05/一次完整的http请求过程/</id>
    <published>2020-03-05T14:30:21.648Z</published>
    <updated>2020-03-05T14:36:55.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一次完整的http请求过程（在浏览器输入URL后，执行的全部过程）"><a href="#一次完整的http请求过程（在浏览器输入URL后，执行的全部过程）" class="headerlink" title="一次完整的http请求过程（在浏览器输入URL后，执行的全部过程）"></a>一次完整的http请求过程（在浏览器输入URL后，执行的全部过程）</h1><p>1.首先进行域名解析，域名解析具体过程讲一下：<br>　　浏览器搜索自己的DNS缓存，缓存中维护一张域名与IP地址的对应表；<br>　　若没有，则搜索操作系统的DNS缓存；<br>　　若没有，则操作系统将域名发送至本地域名服务器（递归查询方式），本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则，通过以下方式迭代查找：<br>　　　　本地域名服务器向根域名服务器发起请求，根域名服务器返回com域的顶级域名服务器的地址；<br>　　　　本地域名服务器向com域的顶级域名服务器发起请求，返回权限域名服务器地址；<br>　　　　本地域名服务器向权限域名服务器发起请求，得到IP地址；<br>　　本地域名服务器将得到的IP地址返回给操作系统，同时自己将IP地址缓存起来；<br>　　操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来；<br>　　至此，浏览器已经得到了域名对应的IP地址。<br>2.浏览器发起HTTP请求；<br>3.接下来到了传输层，选择传输协议，TCP或者UDP，TCP是可靠的传输控制协议，对HTTP请求进行封装，加入了端口号等信息；<br>4.然后到了网络层，通过IP协议将IP地址封装为IP数据报；然后此时会用到ARP协议，主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，找到目的MAC地址；<br>5.接下来到了数据链路层，把网络层交下来的IP数据报添加首部和尾部，封装为MAC帧，现在根据目的mac开始建立TCP连接，三次握手，接收端在收到物理层上交的比特流后，根据首尾的标记，识别帧的开始和结束，将中间的数据部分上交给网络层，然后层层向上传递到应用层；<br>6.服务器响应请求并请求客户端要的资源，传回给客户端；<br>7.断开TCP连接，浏览器对页面进行渲染呈现给客户端。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一次完整的http请求过程（在浏览器输入URL后，执行的全部过程）&quot;&gt;&lt;a href=&quot;#一次完整的http请求过程（在浏览器输入URL后，执行的全部过程）&quot; class=&quot;headerlink&quot; title=&quot;一次完整的http请求过程（在浏览器输入URL后，执
      
    
    </summary>
    
      <category term="技术积累" scheme="https://liuruijie87.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="https和http" scheme="https://liuruijie87.github.io/tags/https%E5%92%8Chttp/"/>
    
  </entry>
  
  <entry>
    <title>从https协议谈对称加密和非对称加密</title>
    <link href="https://liuruijie87.github.io/2020/03/05/%E4%BB%8Ehttps%E5%8D%8F%E8%AE%AE%E8%B0%88%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    <id>https://liuruijie87.github.io/2020/03/05/从https协议谈对称加密和非对称加密/</id>
    <published>2020-03-05T14:05:23.424Z</published>
    <updated>2020-03-05T14:28:50.673Z</updated>
    
    <content type="html"><![CDATA[<p>　　首先，我们为什么要用https协议，在此我们举例说明：你在网上商城，发送一个购物的请求，要购买一件商品，但你的数据包被黑客截获了，黑客在网上商城服务器回复你之前回复你，让你提供银行卡账号和密码，如果你未能识别出这是黑客行文，那么后果就可以自己想象了。<br>　　为了解决这个问题，一般的思路就是加密。加密后的数据包黑客就算截获了了也无法解密，也就无法知道你要干嘛，就无从构造回复报文。加密分为两种方式：对称加密和非对称加密。<br>　　在对称加密算法中，加密和解密使用的密钥是相同的，因此在使用对称加密算法的时候一定要保证密钥不被泄露。<br>　　在非对称加密算法中，加密使用的密钥和解密使用的密钥是不同的，一把是作为公开的公钥，另一把是作为谁都不能给的密钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。<br>　　在效率方面，对称加密算法的效率比非对称加密算法的效率要高的多。<br>　　接下来我们详细说下对称加密。<br>　　假如使用对称加密，在购物时你和网上商城约定了一个密钥，你发送请求的时候用这个密钥加密，网上商城使用同样的密钥解密，这样看起来没有一起都很OK，但有个问题，你和商城怎样约定密钥而不被截获了，既在加密建立前如何安全的传送密钥？如果直接传送密钥的信息，那么这信息可能被黑客截获，之后所有的通信黑客都可以解密查看了，也就没有秘密了。我们总不能和商城的人约定一个时间地点然后线下传送密钥吧，就算是线下接头那是不是也要有个约定的暗号什么的，不然你们又不认识，但在传输暗号的时候还是可能被黑客截获，那么线下和你接头的人也说不好是谁呢…<br>　　So，只要是使用对称加密，如何安全的传送密钥就是一个绕不开的问题，如果只使用对称加密，就会陷入一个密钥传送的死循环，幸好此时我们的非对称加密挺身而出。<br>　　网站使用非对称加密的时候，他的密钥放在自己的口袋里谁也不给，但他会把公钥放在一个指定的地方谁都可以获取，只要你拿到了公钥，在你网站交流的时候，你用公钥加密你的信息，这时就算被人截获但因为缺少私钥，所以黑客也解不开你的信息。目前为止，一切开起来很顺利，但网站在给你回复信息的时候有个问题：网站的回复信息是拿他自己的私钥加密的，这个信息谁都可以用公钥来解密的。看来要解决这个问题，只使用网站的公私钥还不行，客户端也得有自己的公私钥，客户端把自己的公钥给网站，把私钥放在自己口袋，在和网站通信的时候客户端使用网站的公钥加密，网站使用客户端的私钥加密回复信息，至此解决了非对称加密的保密性问题。<br>　　但对于非对称加密也有和对称加密一样的问题，如何将公钥给到对方，前面其实我们也说过一个方法，就是把各自的公钥放在公网上，这样谁都可以去取；还有另一种方法，就是在建立连接的时候把公钥传给对方。但这两种方式都有一个问题，你怎么确保给到你的公钥就是你信任的人呢，有没有可能有人假冒对方呢，答案是完全有可能。<br>　　解决信任问题，最好的方法就是证明，证明什么呢，证明“你是你”！在现实生活中要证明你是你，你需要拿着公安局给你的身份证或者户口本来证明，别人不一定信任你，但身份证的颁发机构是公安局，是权威机构，别人看到身份证也就相信了你是你。其实在网络中也一样，你也需要一个权威机构给你一个证明，证明你是你，证明他是他，证明我是我…在网络世界里，权威部门颁发给你的身份证被称为“证书”。<br>　　在证书中包含：公钥、证书的所有者、证书的发布机构、和证书的有效期。这样来看证书其实和身份证很像~，证书是怎么来的呢，有没有可能有假的证书呢，就像假的身份证一样？<br>　　要生成证书需要发起一个证书请求，然后将这个请求发给权威机构去认证，这个权威机构不是公安局而是CA（Certificate Authority），把生成证书的请求发给权威机构后，权威机构会给这个证书卡个公章，我们称之为签名算法，接着，继续我们的怀疑精神，有没有可能会仿造签名呢，该怎么解决呢？签名算法解决了伪造签名的问题，签名算法用自己的私钥来进行签名，这样能用他的公钥解开的签名就能证明这个签名是真的。<br>　　签名算法一般先对信息做一个hash运算，得到一个hash值，我们都知道这个过程是不可逆的，也就是无法根据hash值推导出原来的信息。在把信息发送出去的时候呢，把这个hash值加密后作为签名一起发出去。<br>　　CA用自己的私钥给网站的公钥的签名，就相当于CA成了网站的担保人，担保这个公钥是这个网站的公钥而不是别人伪造的。<br>　　那么你在和网站通信的时候就不会得到一个公钥了，而是一个证书，一个由CA担保的证书，但我们都知道，信任会传递，不信任也会传递，我们凭什么相信一个我们并不了解的CA机构呢，他又不是国家的公安局，而且我们得到的证书要解密的话还需要CA的公钥，我们怎么获取CA的公钥呢，怎么去相信获得的是CA的公钥呢，这是不是又是一个信任的死循环呢？当然不是，首先CA的公钥也要有人给他做担保人，谁呢？更牛的CA，你不相信小的CA机构，但如果是大的CA机构呢，就这样CA一层层的做担保，直到大到那种全球认可的CA机构他们不再需要担保人，因为他们自身就是root CA。<br>　　在使用Https的时候还有一种常见的证书，就是自签名证书（self-signed certificate），有点像是我给自己带盐，你爱信不信的意思。<br>　　到现在为止我们知道了，在使用https的时候我们无法只使用对称加密算法，但可以只使用非对称加密，之前我们提到过，非对称加密算法在效率上要远低于对称加密算法，因此在传输大数据量的时候我们希望能使用对称加密来提高效率，因此https将两种加密算法搭配使用，具体的过程如下：<br>　　1.客户端发送Client Hello信息到服务器，信息以明文传输TLS版本信息、加密套件候选列表、压缩算法候选列表等。另外还会给对方一个随机数，这个随机数客户端和服务器都会留着。<br>　　2.服务器会回复Server Hello消息，告诉客户端用那个协议、加密套件、压缩算法等，并且服务器也会给客户端一个自己的随机数，现在每个人手里都有两个随机数了。<br>　　3.然后服务器会给客户端自己的证书<br>　　4.服务器会告诉客户端Server Hello done，我就给你这些信息。<br>　　5.客户端会去验证这个证书，在验证的过程中会不断的上溯CA、CA的CA，一直到一个你信任的CA出来做担保。<br>　　6.证书验证通过后，客户端会生成随机数Pre-master，发送Client Key Exchange，用证书中的公钥加密发给服务器。<br>　　7.服务器有了第三（客户端给了两个，自己生成一个）个随机数，客户端也有了三个随机数，然后双方都通过“自己的随机数”+“对端的随机数”+“Pre-master”一起算出对称密钥。<br>　　8.然后双方都发送给对方一个Encrypted Handshake Message，将已经协商好的参数等，采用密钥加密发给对方，作为握手验证，双方验证通过后就可以采用对称加密通信了。<br>　　总结<br>　　加密分为对称加密和非对称加密，对称加密效率高，但是解决不了秘钥的传输问题；非对称加密可以解决这个问题，但效率不高。<br>　　非对称加密需要通过证书来验证公钥的合法性。<br>　　https是综合了对称加密和非对称加密算法的http协议。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　首先，我们为什么要用https协议，在此我们举例说明：你在网上商城，发送一个购物的请求，要购买一件商品，但你的数据包被黑客截获了，黑客在网上商城服务器回复你之前回复你，让你提供银行卡账号和密码，如果你未能识别出这是黑客行文，那么后果就可以自己想象了。&lt;br&gt;　　为了解决
      
    
    </summary>
    
      <category term="技术积累" scheme="https://liuruijie87.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="https和http" scheme="https://liuruijie87.github.io/tags/https%E5%92%8Chttp/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法学习笔记（2）-数组</title>
    <link href="https://liuruijie87.github.io/2020/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89-%E6%95%B0%E7%BB%84/"/>
    <id>https://liuruijie87.github.io/2020/01/14/数据结构与算法学习（2）-数组/</id>
    <published>2020-01-14T13:23:09.440Z</published>
    <updated>2020-01-14T13:42:26.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h1><p>　　前篇总结复杂度分析，本篇学习数组。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>　　数组（Array）是一种线性表数据结构。它用一组连续的内存空间来存储一组具有相同类型的数据。<br>　　数组和链表的区别，很多人都说，“链表适合插入、删除，时间复杂度O(1)；数组适合查找，查找时间复杂度为O(1)”。实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。<br>　　数组为了保持内存数据的连续性，会导致插入、删除这两个操作比 较低效。</p><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>　　如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是O(n)。因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为(1+2+…n)/n=O(n)。<br>　　如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须依次搬移k之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第k个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置。</p><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>　　跟插入数据类似，如果我们要删除第k个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为O(1)；如果删除开头的数据，则最坏情况时间复杂度为O(n)；平均情况时间复杂度也为O(n)。</p><h2 id="警惕数组的访问越界问题"><a href="#警惕数组的访问越界问题" class="headerlink" title="警惕数组的访问越界问题"></a>警惕数组的访问越界问题</h2><p>　　数组越界在C语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。</p><h2 id="容器能否完全替代数组？"><a href="#容器能否完全替代数组？" class="headerlink" title="容器能否完全替代数组？"></a>容器能否完全替代数组？</h2><p>　　针对数组类型，很多语言都提供了容器类，比如Java中的ArrayList、C++STL中的vector。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？<br>　　数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为10的数组，当第11个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。如果使用vector等容器，我们就完全不需要关心底层的扩容逻辑，vector已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为2倍大小。<br>　　不过，这里需要注意一点，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建vector的时候事先指定数据大小。<br>　　作为高级语言编程者，是不是数组就无用武之地了呢？当然不是，有些时候，用数组会更合适些，我总结了几点自己的经验：<br>　　1.如果数据大小事先已知，并且对数据的操作非常简单，用不到vector提供的大部分方法，也可以直接使用数组<br>　　2.还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如int Object[][]array；而用容器的话则需要这样定义：vector&lt;vector<int>&gt; v;<br>　　总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</int></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h1&gt;&lt;p&gt;　　前篇总结复杂度分析，本篇学习数组。&lt;/p&gt;
&lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="算法学习" scheme="https://liuruijie87.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="https://liuruijie87.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法学习笔记（1）-复杂度分析</title>
    <link href="https://liuruijie87.github.io/2020/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>https://liuruijie87.github.io/2020/01/13/数据结构与算法学习（1）-复杂度分析/</id>
    <published>2020-01-13T13:16:58.814Z</published>
    <updated>2020-01-14T13:27:59.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h1><p>　　众所周知，数据结构和算法是编程当中的内功，只有把内功修炼深厚，才能应对各种招式的变化。如果每天做一些机械性质的增删改查，那是注定在编程道路上走不远的，因此，从本篇开始，进行数据结构和算法的学习，并以笔记的形式进行知识点的总结。</p><h1 id="基本复杂度分析"><a href="#基本复杂度分析" class="headerlink" title="基本复杂度分析"></a>基本复杂度分析</h1><p>　　复杂度分析是算法学习的精髓，可以说掌握了复杂度分析，算法学习就成功了一半。而最常用的复杂度表示方法就是大O表示法，这是表示代码执行时间或所占空间随数据规模增长的变化趋势的一种方法。当n很大时，你可以把它想象成100000，而公式中的低阶、常量、系数三部分并不影响增长趋势，所以都可以忽略，我们只需保留一个最大量级就可以了。</p><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>　　1 只关注循环执行次数最多的一段代码。<br>　　2 加法法则：总的时间复杂度等于量级最大的那段代码的时间复杂度。即抽象公式：T(n)=T1(n)+T2(n)=Max(O(f(n)),O(g(n)))。<br>　　3 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。<br>　　常见的复杂度有O(1)、O(logn)、O(n)、O(nlogn)、O(n^2)、O(2^n)、O(n!)，其中O(2^n)和O(n!)为非多项式量级。<br>　　O(logn)比较难以分析，借用以下例子加以理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 1;</span><br><span class="line">while(i &lt;= n)&#123;</span><br><span class="line">i = i * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出i从1开始，每次循环就乘以2，当大于n时，循环结束，因此可以看出这是一个等比数列：2^0,2^1,2^2,2^3……2^k = n，其中k代表执行的次数，即k=logn（以2为底，用大O表示的话可以省略底数）。<br>　　另外，还有一种非寻常的情况，即代码的复杂度由两个数据的规模来决定，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int cal(int m, int n) &#123;</span><br><span class="line">int sum_1 = 0;</span><br><span class="line">int i = 1;</span><br><span class="line">for (; i &lt; m; ++i) &#123;</span><br><span class="line">sum_1 = sum_1 + i;</span><br><span class="line">&#125;</span><br><span class="line">int sum_2 = 0;</span><br><span class="line">int j = 1;</span><br><span class="line">for (; j &lt; n; ++j) &#123;</span><br><span class="line">sum_2 = sum_2 + j;</span><br><span class="line">&#125;</span><br><span class="line">return sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，m和n表示两个数据规模，我们无法事先评估,m和n谁的量级大，所以复杂度就是O(m+n)。</p><h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>　　空间复杂度一般比较简单，能够通过肉眼看出来，例如下面代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void print(int n) &#123;</span><br><span class="line">int i = 0;</span><br><span class="line">int[] a = new int[n];</span><br><span class="line">for (i; i &lt;n; ++i) &#123;</span><br><span class="line">a[i] = i * i;</span><br><span class="line">&#125;</span><br><span class="line">for (i = n-1; i &gt;= 0; --i) &#123;</span><br><span class="line">print out a[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　可以看到，申请了一个大小为n的int类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是O(n)。</p><h1 id="最好、最坏时间复杂度"><a href="#最好、最坏时间复杂度" class="headerlink" title="最好、最坏时间复杂度"></a>最好、最坏时间复杂度</h1><p>　　顾名思义，最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。同理，最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">int i = 0;</span><br><span class="line">int pos = -1;</span><br><span class="line">for (; i &lt; n; ++i) &#123;</span><br><span class="line">if (array[i] == x) &#123;</span><br><span class="line">pos = i;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　上述代码中，在一个数组中查找x，如果x是第一个数，则最快，而如果x不存在数组中，则要遍历n次，因此，最好复杂度O(1)，最坏复杂度O(n)。</p><h1 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h1><p>　　还是上述代码，为了方便你理解，我们假设在数组中与不在数组中的概率都为1/2。另外，要查找的数据出现在0～n-1这n个位置的概率也是一样的，为1/n。所以，根据概率乘法法则，要查找的数据出现在0～n-1中任意位置的概率就是1/(2n)。因此平均时间复杂度的计算过程为：1/2n+2/2n+……+n/2n+n/2=(3n+1)/4。这个值就是加权平均值，用大O法表示即：O(n)。</p><h1 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h1><p>　　首先看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int[] array = new int[n];</span><br><span class="line">int count = 0;</span><br><span class="line">void insert(int val) &#123;</span><br><span class="line">if (count == array.length) &#123;</span><br><span class="line">int sum = 0;</span><br><span class="line">for (int i = 0; i &lt; array.length; ++i) &#123;</span><br><span class="line">sum = sum + array[i];</span><br><span class="line">&#125;</span><br><span class="line">array[0] = sum;</span><br><span class="line">count = 1;</span><br><span class="line">&#125;</span><br><span class="line">array[count] = val;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用for循环遍历数组求和，并清空数组，将求和之后的sum值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。<br>　　最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为count的位置就可以了，所以最好情况时间复杂度为O(1)。最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为O(n)。<br>　　假设数组的长度是n，根据数据插入的位置的不同，我们可以分为n种情况，每种情况的时间复杂度是O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是O(n)。而且，这n+1种情况发生的概率一样，都是1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：1/(n+1)+1/(n+1)+……+n/(n+1)=O(1)。<br>　　每一次O(n)的插入操作，都会跟着n-1次O(1)的插入操作，所以把耗时多的那次操作均摊到接下来的n-1次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是O(1)。这就是均摊分析的大致思路。<br>　　对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系（即有规律），这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h1&gt;&lt;p&gt;　　众所周知，数据结构和算法是编程当中的内功，只有把内功修炼深厚，才能应对各种招式的变化。如果每天做一些机械性质的增删改查，那是注定在编程道
      
    
    </summary>
    
      <category term="算法学习" scheme="https://liuruijie87.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="https://liuruijie87.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构知识点</title>
    <link href="https://liuruijie87.github.io/2019/12/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://liuruijie87.github.io/2019/12/10/数据结构知识点/</id>
    <published>2019-12-10T02:29:22.283Z</published>
    <updated>2020-01-13T13:23:34.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>　　1、一个节点所拥有子树的个数被称为它的度。度为0的节点被称为叶节点。树的度等于树中所有节点的度的最大值。<br>　　2、一个节点的层次通过令根节点位于第一层来定义（有些书中将根节点的层次定义为0）。如果一个节点位于层次n，那么它的孩子位于层次n+1。树的高度或深度定义为树中节点的最大层次。<br>　　3、位于二叉树第i层的节点个数最多为2^(i-1),i&gt;=1。深度为k的二叉树的最大节点个数为2^k-1，k&gt;=1。<br>　　4、二叉树的遍历分为前序、中序、后序遍历，例如前序遍历是指：在遍历某一节点的左右子树之前先访问该节点。中序和后序与此类似。<br>　　5、二叉搜索树（BST）的节点放置规则：任何节点的键值一定大于其左子树中的每一个节点的键值，并小于其右子树中的每一个节点的键值。因此，从根节点一直往左走，直到无左路可走，即得最小元素，从根节点一直往右走，直到无右路可走，即得最大元素。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h1&gt;&lt;p&gt;　　1、一个节点所拥有子树的个数被称为它的度。度为0的节点被称为叶节点。树的度等于树中所有节点的度的最大值。&lt;br&gt;　　2、一个节点的层次通过令根节
      
    
    </summary>
    
      <category term="技术积累" scheme="https://liuruijie87.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="数据结构" scheme="https://liuruijie87.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>逻辑右移和算术右移</title>
    <link href="https://liuruijie87.github.io/2019/12/09/%E9%80%BB%E8%BE%91%E5%8F%B3%E7%A7%BB%E5%92%8C%E7%AE%97%E6%9C%AF%E5%8F%B3%E7%A7%BB/"/>
    <id>https://liuruijie87.github.io/2019/12/09/逻辑右移和算术右移/</id>
    <published>2019-12-09T05:41:46.808Z</published>
    <updated>2019-12-09T05:45:25.320Z</updated>
    
    <content type="html"><![CDATA[<p>　　逻辑右移就是不考虑符号位，右移一位，左边补零即可。<br>　　算术右移需要考虑符号位，右移一位，若符号位为1，就在左边补1；否则，就补0。<br>　　所以算术右移也可以进行有符号位的除法，右移n位就等于除以2的n次方。</p><p>　　例如，8位二进制数11001101分别右移一位。<br>　　逻辑右移就是01100110<br>　　算术右移就是11100110</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　逻辑右移就是不考虑符号位，右移一位，左边补零即可。&lt;br&gt;　　算术右移需要考虑符号位，右移一位，若符号位为1，就在左边补1；否则，就补0。&lt;br&gt;　　所以算术右移也可以进行有符号位的除法，右移n位就等于除以2的n次方。&lt;/p&gt;
&lt;p&gt;　　例如，8位二进制数1100110
      
    
    </summary>
    
      <category term="技术积累" scheme="https://liuruijie87.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="技术" scheme="https://liuruijie87.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>递归中的return</title>
    <link href="https://liuruijie87.github.io/2019/12/06/%E5%85%B3%E4%BA%8E%E9%80%92%E5%BD%92%E4%B8%AD%E7%9A%84return/"/>
    <id>https://liuruijie87.github.io/2019/12/06/关于递归中的return/</id>
    <published>2019-12-06T01:43:16.904Z</published>
    <updated>2019-12-06T02:31:32.317Z</updated>
    
    <content type="html"><![CDATA[<p>　　递归中的return常用来作为递归终止的条件，但是对于返回数值的情况，要搞明白它是怎么返回的。递归的方式就是自己调用自己，而在有返回值的函数中，上一层的函数还没执行完就调用下一层，因此，当达到递归终止条件时，首先return的是最底层调用的函数，return之后，继续执行上一层调用该函数之后的代码，此时我们看到的是上一层的情况，当上一层剩余的代码执行完之后，表示上一层的函数也结束，此时再返回上上一层，执行递归代码之后的代码，如此往复循环，直到返回到最上层，结束整个递归过程。需要注意的是，<strong>上一层执行递归之后的代码的时候，会调用下一层返回的值，也可以理解为在执行上一层代码的时候会调用下一层的实现过程，直到下一层执行完返回一个数值，然后再加上上一层的数值，就构成了上一层return的东西，如此往复。</strong>下面介绍例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int Sum(int n)</span><br><span class="line">        &#123;</span><br><span class="line">            if (n &lt;= 1)                  //#1</span><br><span class="line">                return n;                //#2</span><br><span class="line">            return n+Sum(n - 1);         //#3</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>　　上面是一个递归求和的代码，例如我们传参100进去，第一次执行到#3位置的时候，调用Sum(99)，此时Sum(100)还没有执行完，就已经开始执行Sum(99)了，Sum(100)要等待Sum(99)执行完后才开始执行自己未执行完的程序。同理当Sum(99)执行到#3位置的时候，也会调用Sum(98)，此时Sum(99)还没有执行完，Sum(99)要等到Sum(98)执行完之后才开始执行自己未执行完的程序…..就这样一直循环到n=1的时候，也就是在执行Sum(1)的时候满足递归结束条件，即return 1;这个时候表示Sum(1)已经执行完毕，接下来要执行Sum(2)中未执行完的内容，也就是return 2+Sum(1);而Sum(1)已经返回1，因此Sum(2)返回2+1=3，Sum(2)执行完毕，开始执行Sum(3)未执行完的内容…..如此往复，一直到Sum(99)执行完毕后，再执行Sum(100)中未执行完的内容，也就是return 100+Sum(99),而Sum(99)已经执行完毕，有返回值，因此Sum(100)=100+Sum(99)=5050。至此，整个递归过程结束，返回累加值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　递归中的return常用来作为递归终止的条件，但是对于返回数值的情况，要搞明白它是怎么返回的。递归的方式就是自己调用自己，而在有返回值的函数中，上一层的函数还没执行完就调用下一层，因此，当达到递归终止条件时，首先return的是最底层调用的函数，return之后，继续执
      
    
    </summary>
    
      <category term="技术积累" scheme="https://liuruijie87.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="技术" scheme="https://liuruijie87.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>算法积累</title>
    <link href="https://liuruijie87.github.io/2019/11/20/%E7%AE%97%E6%B3%95/"/>
    <id>https://liuruijie87.github.io/2019/11/20/算法/</id>
    <published>2019-11-20T01:06:22.363Z</published>
    <updated>2019-11-22T06:20:33.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>　　假设一个问题比较复杂，暂时找不到全局最优解，那么我们可以考虑把原问题拆成几个小问题（分而治之思想），分别求每个小问题的最优解，再把这些“局部最优解”叠起来，就“当作”整个问题的最优解了。<br>　　使用贪心算法的前提：<br>　　1、原问题复杂度过高；<br>　　2、求全局最优解的数学模型难以建立；<br>　　3、求全局最优解的计算量过大；<br>　　4、没有太大必要一定要求出全局最优解，“比较优”就可以。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;贪心算法&quot;&gt;&lt;a href=&quot;#贪心算法&quot; class=&quot;headerlink&quot; title=&quot;贪心算法&quot;&gt;&lt;/a&gt;贪心算法&lt;/h1&gt;&lt;h2 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h
      
    
    </summary>
    
      <category term="算法学习" scheme="https://liuruijie87.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="https://liuruijie87.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://liuruijie87.github.io/2019/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://liuruijie87.github.io/2019/11/12/操作系统知识点/</id>
    <published>2019-11-12T12:23:10.452Z</published>
    <updated>2020-01-13T13:22:17.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="x86-32硬件-内存架构"><a href="#x86-32硬件-内存架构" class="headerlink" title="x86-32硬件-内存架构"></a>x86-32硬件-内存架构</h2><p>　  1、地址是访问内存空间的索引。<br>　　2、80386是32位机器，即可寻址的范围是2^32=4G字节。<br>　　3、物理内存空间是计算机提交到总线上的用于访问计算机上的内存和外设的最终地址。一个计算机中只有一个物理地址空间。<br>　　4、线性地址空间是在操作系统的虚拟内存管理下，每个运行的应用程序能访问的地址空间。每个运行的程序都认为自己独享整个计算机系统的地址空间，这样可以让多个运行的应用程序之间相互隔离。<br>　　5、逻辑地址空间是应用程序直接使用的地址空间。</p><h2 id="内存使用与分段"><a href="#内存使用与分段" class="headerlink" title="内存使用与分段"></a>内存使用与分段</h2><p>　　1、重定位：修改程序中的地址（是相对地址）。<br>　　2、编译时重定位的程序只能放在内存固定位置，载入时重定位的程序一旦载入内存就不能动了。因此重定位最适合的时机是运行时重定位，即在运行每条指令时才完成重定位。（每执行一条指令都要从逻辑地址算出物理地址）每个进程有各自的基地址，在每条指令执行的第一步先从PCB中取出这个基地址。<br>　　3、内存如何使用？首先找一块空地址，得到基地址，然后将基地址写入PCB寄存器中，在程序运行中，每执行一条指令，首先从PCB中取出基地址，再加上程序中的逻辑地址，即可翻译成物理地址，这样内存就使用起来了。当进程间切换时，PCB中的值也会跟着变化。　　</p><h2 id="分段和分页机制"><a href="#分段和分页机制" class="headerlink" title="分段和分页机制"></a>分段和分页机制</h2><p>　　1、分段和分页是两种不同的地址变换机制，它们都对整个地址变换操作提供独立的处理阶段。尽管两种机制都使用存储在内存中的变换表，但所用的表结构不同。实际上，段表存储在线性地址空间，而页表存储在物理地址空间。因而段变换表可由分页机制重新定位而无需段机制的信息或合作。段变换机制把虚拟地址（逻辑地址）变换成线性地址，并且在线性地址中访问自己的表，但是并不知晓分页机制把这些线性地址转换到物理地址的过程。类似地，分页机制也不知道程序产生地址的虚拟地址空间。分页机制只是简单地把线性地址转换成物理地址，并且在物理内存中访问自己的转换表。</p><h1 id="CPU管理"><a href="#CPU管理" class="headerlink" title="CPU管理"></a>CPU管理</h1><p>　　</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>　　1、进程就是一个程序的执行过程。<br>　　2、只有进程从内核态转移到用户态时，才可能发生抢占，进程在内核态下运行是不会被抢占的。<br>　　3、多线程是指操作系统在单个进程内支持多个并发执行路径的能力。<br>　　4、进程中所有线程共享该进程的状态和资源，它们驻留在同一块地址空间中，并且可以访问到相同的数据。当一个线程改变了内存中的一个数据项时，其他线程在访问该数据项时能看到变化后的结果。<br>　　5、在大多数操作系统中，独立进程间的通信通常需要内核的介入，以提供保护和通信所需要的机制。但是由于在同一个进程中的线程共享内存和文件，它们无需调用内核就可以通信。<br>　　6、进程的终止会导致进程中所有线程的终止。<br>　　7、进程从创建（Linux下调用fork()）到结束的整个过程就是进程的生命期，进程在其生命期中的运行轨迹实际上就表现为进程状态的多次切换，如进程创建以后会成为就绪态；当该进程被调度以后会切换到运行态；在运行的过程中如果启动了一个文件读写操作，操作系统会将该进程切换到阻塞态（等待态）从而让出CPU；当文件读写完毕以后，操作系统会在将其切换成就绪态，等待进程调度算法来调度该进程执行……<br>　　8、用户态到内核态只能通过中断的方式。</p><h2 id="进程同步与死锁"><a href="#进程同步与死锁" class="headerlink" title="进程同步与死锁"></a>进程同步与死锁</h2><p>　　1、临界区：一次只允许一个进程进入该进程修改其信号量的那一段代码。<br>　　2、临界区代码保护原则：互斥进入，即如果一个进程在临界区中执行，则其他进程不允许进入。<br>　　3、好的临界区保护原则：（1）有空让进：当若干进程要求进入空闲临界区时，应尽快使一进程进入临界区。（2）有限等待：从进程发出进入请求到允许进入，不能无限等待。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>　　1、线程保留了并发的优点，避免了进程切换代价。<br>　　2、用户级线程，在用户态下切换。如果某个线程调用硬件在内核中发生阻塞，内核就会切换到其他进程，那么在之前那个进程下的用户级线程就会卡在那不动。<br>　　3、用户级线程用了两个栈，而内核级线程用了两套栈。即用户级线程切换的时候，TCB切换，用户栈也跟着切换；内核级线程切换的时候，TCB切换，用户栈和内核栈都要跟着切换。<br>　　4、内核级线程在内核栈之间切换的时候，通过TCB找到内核栈指针，然后通过ret切到某个内核程序，最后再用CS:PC切到用户程序。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>　　1、在通常情况下，调用系统调用和调用一个普通的自定义函数在代码上并没有什么区别，但调用后发生的事情有很大不同。调用自定义函数是通过 call 指令直接跳转到该函数的地址，继续运行。而调用系统调用，是调用系统库中为该系统调用编写的一个接口函数，叫 API（Application Programming Interface）。API并不能完成系统调用的真正功能，它要做的是去调用真正的系统调用，过程是：把系统调用的编号存入EAX；把函数参数存入其它通用寄存器；触发 0x80 号中断（int 0x80），进入内核态，调用相关的内核函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h1&gt;&lt;h2 id=&quot;x86-32硬件-内存架构&quot;&gt;&lt;a href=&quot;#x86-32硬件-内存架构&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="操作系统学习" scheme="https://liuruijie87.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="操作系统" scheme="https://liuruijie87.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>effective C++（2）</title>
    <link href="https://liuruijie87.github.io/2019/09/30/effective%20C++%EF%BC%882%EF%BC%89/"/>
    <id>https://liuruijie87.github.io/2019/09/30/effective C++（2）/</id>
    <published>2019-09-30T00:27:33.578Z</published>
    <updated>2019-09-30T01:26:10.508Z</updated>
    
    <content type="html"><![CDATA[<p>　　1.如果你打算在一个内含引用的类内支持赋值操作，你必须自己定义拷贝赋值操作符。<br>　　2.如果某个基类将拷贝赋值操作符声明为private，编译器就会拒绝为其子类生成一个拷贝赋值操作符。<br>　　3.当子类对象经由一个基类指针被删除，而该基类带着一个非虚析构函数，则在实际执行的时候，对象的子类部分没被销毁。将基类的析构函数声明为虚函数之后，子类的析构函数也自动成为虚析构函数，在主函数中基类指针指向的是派生类对象，当delete释放指针所指向的存储空间时，会执行派生类的析构函数，派生类的析构函数执行完之后会紧接着执行基类的析构函数，以释放从基类继承过来的成员变量所消耗的资源。<br>　　4.auto_ptrs有个不寻常的性质，若通过拷贝构造或拷贝赋值运算符复制它们，它们会变成null，而复制所得的指针将取得资源的唯一拥有权。<br>　　5.应该尽量延后变量的定义，直到能够给它初值实参为止，因为这样不仅能够避免构造和析构非必要对象，还可以避免毫无意义的默认构造行为。<br>　　6.将大多数inline限制在小型、频繁调用的函数身上。<br>　　7.public继承意味着“is a”的关系，虚函数意味着接口必须被继承，非虚函数意味着接口和实现都必须被继承。<br>　　8.private继承使得基类所有成员在子类中的访问权限变为private。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　1.如果你打算在一个内含引用的类内支持赋值操作，你必须自己定义拷贝赋值操作符。&lt;br&gt;　　2.如果某个基类将拷贝赋值操作符声明为private，编译器就会拒绝为其子类生成一个拷贝赋值操作符。&lt;br&gt;　　3.当子类对象经由一个基类指针被删除，而该基类带着一个非虚析构函数，
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://liuruijie87.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="effective C++" scheme="https://liuruijie87.github.io/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>零碎知识点</title>
    <link href="https://liuruijie87.github.io/2019/09/28/C++%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://liuruijie87.github.io/2019/09/28/C++零碎知识点/</id>
    <published>2019-09-28T06:18:07.278Z</published>
    <updated>2020-03-23T09:19:06.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>　　1、逗号表达式是将括号中所有表达式的值算出来，但是只使用最后一个表达式的值。<br>　　2、构造函数是可以私有化的，但一般不会这样做，因为私有化的构造函数不能被new到，并且类不能通过该私有构造函数初始化（可以调用静态方法初始化）。<br>　　3、一个类中可以有任意个构造函数（可以函数重载），但只能有一个析构函数。无论何时，只要类的对象被创建，就会执行构造函数。<br>　　4、类的静态数据成员只能在类内声明，类外定义和初始化。因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。const的静态成员可以在类内初始化，是因为它既然是const的，那后面的程序就不会再去试图初始化了。<br>　　5、当用#include“file.h”时，先搜索当前工作目录，如果没有，再去搜索标准库，库没有再搜索资源库；当用#include&lt;file.h&gt;时，编译器先从标准库开始搜索，如果没再搜索资源库目录，若还未找到则搜索当前工作目录。<br>　　6、字符数组的复制要用strcpy()函数,不能直接用赋值操作符赋值。不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。<br>　　7、数组名就是数组首元素的地址，在用scanf函数输入的时候，不用加&amp;。<br>　　8、定义数组时可以对第一维的长度不指定，但第二维的长度不能省去。<br>　　9、C++运算符是有优先级的，一般是算术运算符&gt;关系运算符&gt;逻辑运算符&gt;条件运算符，所以运算符顺序是!（一元算术运算符）&gt;  !=（关系运算符）&gt;  &amp;&amp;（逻辑运算符）&gt;  ?:（条件运算符）<br>　　10、内存对齐的3大规则:<br>　　（1）对于结构体的各个成员，第一个成员的偏移量是0，排列在后面的成员其当前偏移量必须是当前成员类型的整数倍。<br>　　（2）结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍。<br>　　（3）如程序中有#pragma  pack(n)预编译指令，则所有成员对齐以n字节为准(即偏移量是n的整数倍)，不再考虑当前类型以及最大结构体内类型。<br>　　11、✳是scanf函数中的一种修饰符，表示忽略该输入项，使用方法为：放在%与格式d（或者s，c等）之间，如：scanf(“%x%✳d%o”,&amp;x,&amp;y); 并且，scanf不能指明浮点数的精度。<br>　　12、子类实现父类虚函数叫重写，不叫重载。父类有纯虚函数，子类可以不实现，此时子类仍是抽象类。<br>　　13、继承类构造函数中，成员初始化列表同时出现对虚基类和非虚基类构造函数的调用时，虚基类的构造函数先于非虚基类的构造函数执行。<br>　　14、C语言中&amp;&amp;是一种双目运算符，表示与运算，而当左边所给表达式或变量为0时，不再计算右侧，整个表达式为零。<br>　　15、C语言中有数字三种表示：十进制、八进制(0开头)、十六进制(0x开头)。<br>　　16、内联函数是指用inline关键字修饰的函数。在类内定义的函数被默认成内联函数。内联函数从源代码层看，有函数的结构，而在编译后，却不具备函数的性质。内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处。编译时，类似宏替换，使用函数体替换调用处的函数名。一般在代码中用inline修饰，但是能否形成内联函数，需要看编译器对该函数定义的具体处理。<br>　　17、结构化程序由三种基本结构组成，三种基本结构组成的算法只能完成符合结构化的任务。<br>　　18、字符数组整体输入输出只是库函数里面用循环来完成一个一个元素的输入输出的，宏观上看上去就成了整体输入输出了。本质上说，与整型数组单个元素输入输出并没有区别，差别在于整型数组并不知道什么位置终止，需要人为地控制输入输出终止的条件，字符数组则很简单，输出默认’\0’终止，输入则默认空白字符或者换行。<br>　　19、read是UNIX或类UNIX系统中的系统函数，而fread才是C库里面的库函数。<br>　　20、在类定义时，无法使用构造函数，因而无法完成对象的初始化，类还没有定义完，不能初始化对象。只有在定义类对象时才会调用构造函数。<br>　　21、一般成员变量需要在类内进行初始化。静态成员变量必须在类外初始化，int型静态成员常量在类中初始化。<br>　　22、由于类的构造次序是由基类到派生类，所以在构造函数中调用虚函数，这个虚函数不会呈现出多态；相反，类的析构是从派生类到基类，当调用继承层次中某一层次的类的析构函数时往往意味着其派生类部分已经析构掉，所以也不会呈现出多态。（effeetive c++ 条款9）。<br>　　23、虚函数可以声明为inline，因为加上inline只是我们对编译器的一种建议，是否为inline还得看编译器的选择。相反，内联函数不能为虚函数，因为函数的内联属性是在编译器确定的，是静态行为，而虚函数的性质是在运行期确定的，是动态行为，二者是矛盾的，所以要想作为内联函数，就不要将它写成虚函数。<br>　　24、在C中使用malloc时不需要强制类型转换，因为在C中从void※到其他类型的指针是自动隐式转换的；在C++中使用malloc时必须要强制类型转换，否则会报错，因为C++是不支持void※类型隐式转换为其他类型的，但在c++中一般用new而不用malloc。malloc有一个参数。<br>　　25、宏定义不做语法检查。预处理是在编译之前的处理，而编译的工作之一便是语法检查，所以预处理不做语法检查。<br>　　26、C++中引入友元函数，是为在该类中提供一个对外（除了他自己意外）访问的窗口;这个友元函数不属于该类的成员函数，他是定义在类外的普通函数，只是在类中声明该函数可以直接访问类中的private或者protected成员。<br>　　27、使用友元函数注意的要点：<br>　　　　1）类中通过使用关键字friend来修饰友元函数，但该函数并不是类的成员函数，其声明可以放在类的私有部分，也可放在共有部分。友元函数的定义在类体外实现，不需要加类限定。<br>　　　　2）一个类中的成员函数可以是另外一个类的友元函数，而且一个函数可以是多个类友元函数。<br>　　　　3）友元函数可以访问类中的私有成员和其他数据，但是访问不可直接使用数据成员，需要通过对对象进行引用。<br>　　　　4）友元函数在调用上同一般函数一样，不必通过对对象进行引用。<br>　　28、程序占用三种类型的内存：静态内存、栈内存、堆内存；<br>　　静态内存：用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。<br>　　栈内存：用来保存定义在函数内的非static对象。<br>　　堆内存：在程序运行时分配。<br>　　分配在静态内存或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。动态对象的生存周期由程序（用户）来控制。<br>　　29、数组指针和指针数组的区别：<br>　　指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身的大小决定，每一个元素都是一个指针，在32 位系统下任何类型的指针永远是占4 个字节。它是“储存指针的数组”的简称。<br>　　数组指针：首先它是一个指针，它指向一个数组。在32位系统下任何类型的指针永远是占4个字节，至于它指向的数组占多少字节，不知道，具体要看数组大小。它是“指向数组的指针”的简称。<br>　　30、C语言中实数常数的科学表示法规定格式为：“实数e整数”或“实数E整数”，其中幂是整数，不能写成实数。e(或E)前后的实数和整数都不能省略掉。C语言规定。0开头的是八进制数，0x(0x)开头的是十六进制数。而八进制数数字是0～7，出现8是错误的。实数的小数点前后的数字都可以不写。<br>　　31、逗号表达式的求解过程是：先求解表达式1，再求解表达式2。整个逗号表达式的值是表达式2的值。例如逗号表达式a=3+5,a+4，对此表达式的求解，赋值运算符的优先级别高于逗号运算符，因此应先求解a=3+5，经计算和赋值后得到a的值为8，然后求解a+4，得12，整个逗号表达式的值为12(a仍为8)。<br>　　32、文件指针指向的是一块内存区域，这块区域存储着打开的文件的相关信息，包括文件读取指针当前位置、文件读取缓冲区大小等信息，并不是指向文件的。fscanf是从文件中格式化读取，fprintf是向文件中格式化写入。<br>　　33、类的方法后面加了const后，该方法的实现中不能修改类的成员。<br>　　34、文件读写操作的几种模式：<br>　　　　r代表read的简写，+代表可读可写，w代表write，b代表bit二进制位，t代表text。 </p><p>　　　　r 打开只读文件，该文件必须存在。<br>　　　　r+ 打开可读可写的文件，该文件必须存在(这里的写文件是指将之前的文件覆盖。<br>　　　　rt 打开只读文本文件，该文本必须存在。<br>　　　　rt+ 读写打开一个文本文件，允许读和写，该文件必须存在(这里的写文件是指将之前的文件覆盖。<br>　　　　rb 只读打开一个二进制文件，该文件必须存在。<br>　　　　rb+ 读写打开一个二进制文件，允许读和写，该文件必须存在(这里的写文件是指将之前的文件覆盖。 </p><p>　　　　w 打开只写文件，若文件存在，则文件长度清零，即文件内容会消失，若文件不存在则建立该文件。<br>　　　　w+ 打开可读写文件，若文件存在，则文件长度清零，即文件内容会消失，若文件不存在则建立该文件(这里的读文件，同样需要使用rewind()函数)。<br>　　　　wt 打开只写文本文件，若文件存在，则文件长度清零，即文件内容会消失，若文件不存在则建立该文件。<br>　　　　wt+ 打开可读写文本文件，若文件存在，则文件长度清零，即文件内容会消失，若文件不存在则建立该文件。<br>　　　　wb 打开只写二进制文件，若文件存在，则文件长度清零，即文件内容会消失，若文件不存在则建立该文件。<br>　　　　wb+ 打开可读写二进制文件，若文件存在，则文件长度清零，即文件内容会消失，若文件不存在则建立该文件。 </p><p>　　　　a 以附加的方式打开只写文件，若文件不存在，则建立文件，存在则在文件尾部添加数据,即追加内容。<br>　　　　a+ 以附加的方式打开可读写文件，不存在则建立文件，存在则写入数据到文件尾(这里的读文件，同样需要使用rewind()函数，但是写文件不需要rewind()函数，a是追加)。<br>　　　　at 文本数据的追加，不存在则创建，只能写。<br>　　　　at+ 读写打开一个文本文件，允许读或在文本末追加数据(这里的读文件，同样需要使用rewind()函数，但是写文件不需要rewind()函数，a是追加)。<br>　　　　ab 二进制数据的追加，不存在则创建，只能写。<br>　　　　ab+ 读写打开一个二进制文件，不存在则创建,允许读或在文本末追加数据(这里的读文件，同样需要使用rewind()函数，但是写文件不需要rewind()函数，a是追加)。<br>　　35、静态局部变量和全局变量的区别：静态局部变量虽然和全局变量都存放在全局数据区，延长了生命周期，但是作用域不同！静态局部变量仍然是个局部变量，只对函数内可见。<br>　　36、栈空间上面的局部变量默认初始化为随机值。全局整形变量和静态static整形变量默认初始值为0。<br>　　37、c++中包含纯虚函数的类称为抽象类，由于抽象类中包含了没有定义的纯虚函数，所以不能定义抽象类的对象。<br>　　38、抽象类只能用作其他类的基类，不能定义抽象类的对象。抽象类不能用于参数类型、函数返回值或显示转换的类型。抽象类可以定义抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。<br>　　39、逻辑运算符的优先级：! &gt; &amp;&amp; &gt; ||。!运算符比许多C++运算符具有更高的优先级。因此，为了避免错误，应始终将其操作数括在括号中，除非打算将其应用于没有其他操作符的变量或简单表达式。<br>　　40、运算符优先级：！&gt; 算术运算符 &gt; 关系运算符 &gt; （&amp;&amp; ||）&gt; 条件运算符&gt; 赋值运算符 &gt; 逗号运算符。<br>　　41、实型常量又称实数或浮点数。在C语言中可以用两种形式表示一个实型常量。<br>　　小数形式：小数形式是由数字和小数点组成的一种实数表示形式，例如0.123、.123、123.、0.0等都是合法的实型常量。<strong>注意：小数形式表示的实型常量必须要有小数点。</strong><br>　　指数形式：这种形式类似数学中的指数形式。在数学中，一个可以用幂的形式来表示，如2.3026可以表示为0.23026×10^1 2.3026×10^0 23.026×10^-1等形式。在C语言中，则以“e”或“E”后跟一个整数来表示以“10”为底数的幂数。2.3026可以表示为0.23026E1、2.3026e0、23.026e-1。C语言语法规定，字母e或E之前必须要有数字，且e或E后面的指数必须为整数。如e3、5e3.6、.e、e等都是非法的指数形式。<strong>注意：在字母e或E的前后以及数字之间不得插入空格。</strong><br>　　42、程序运行的过程中，其值不能被改变的量称为常量。常量有不同类型，其中12、0、-5为整型常量。’a’’b’为字符常量。而4.6、-8.7则为实型常量。一个实型常量可以赋给一个 float 型、double 型或 long double变量。根据变量的类型截取实型常量中相应的有效位数字。<br>　　43、用基类的指针指向不同的派生类的对象时，基类指针调用其虚成员函数，则会调用其真正指向对象的成员函数，而不是基类中定义的成员函数（只要派生类改写了该成员函数）。若不是虚函数，则不管基类指针指向的哪个派生类对象，调用时都会调用基类中定义的那个函数。<br>　　44、virtual函数是动态绑定，而缺省参数值却是静态绑定。意思是你可能会在“调用一个定义于派生类内的virtual函数”的同时，却使用基类为它所指定的缺省参数值。<strong>结论</strong>：绝不重新定义继承而来的缺省参数值！（可参考《Effective C++》条款37）<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void func(int val = 1)</span><br><span class="line">    &#123; std::cout&lt;&lt;&quot;A-&gt;&quot;&lt;&lt;val &lt;&lt;std::endl;&#125;</span><br><span class="line">    virtual void test()</span><br><span class="line">    &#123; func();&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B : public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void func(int val=0)</span><br><span class="line">&#123;std::cout&lt;&lt;&quot;B-&gt;&quot;&lt;&lt;val &lt;&lt;std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main(int argc ,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    B*p = new B;</span><br><span class="line">    p-&gt;test();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p-&gt;test()执行过程理解：<br>       (1) 由于B类中没有覆盖（重写）基类中的虚函数test()，因此会调用基类A中的test()；<br>       (2) A中test()函数中继续调用虚函数 fun()，因为虚函数执行动态绑定，p此时的动态类型（即目前所指对象的类型）为B✳，因此此时调用虚函数fun()时，执行的是B类中的fun()；所以先输出“B-&gt;”；<br>       (3) 缺省参数值是静态绑定，即此时val的值使用的是基类A中的缺省参数值，其值在编译阶段已经绑定，值为1，所以输出“1”；<br>       最终输出“B-&gt;1”。所以记住上述结论：<strong>绝不重新定义继承而来的缺省参数值！</strong><br>　　45、char✳ strcpy(char ✳dest,char ✳src)；将从src开始包含’\0’的字符串拷贝到以dest开始的位置，进行覆盖char✳ strcat(char ✳dest,char ✳src);将src开始的字符串添加到dest字符串的末尾(覆盖dest的\0”)两者都返回指向dest的指针。<br>　　46、所谓的左值，说通俗一点就是可以被修改和引用的值，左值可以取地址。与之相对的就是右值。在使用时，左值可以作为右值，但右值不能作为左值。例如a++操作通过临时量返回其值，该值是一个常量，因此不能被修改（不是左值），而++a就是一个左值，可以修改。a++通过一个临时量temp返回其中值,该值是一个常量，并不是用户定义的那种可以引用，寻址的变量，不能对其进行修改或者赋值操作，只能将其用来赋值给其他左值。<br>　　47、cin&gt;&gt; 该操作符是根据后面变量的类型读取数据。输入结束条件：遇到Enter、Space、Tab键。对结束符的处理：丢弃缓冲区中使得输入结束的结束符(Enter、Space、Tab)<br>　　48、const只对它左边的东西起作用，唯一的例外就是const本身就是最左边的修饰符，那么它才会对右边的东西起作用。<br>　　49、模板的实参是用来实例化类类型参数（typename）的，因此实参必须为有已确定内存空间大小的数据类型（指针、用户自定义类···）；也不能为抽象类，可为具体类（抽象类的限制）。不是任意的数据类型。</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>　　1、斜杠记法标识子网掩码，/20的意思就是掩码中有20个1，用十进制表示，就是255.255.240.0 二进制中255有8个1，240是1111 0000有4个1，一共20个1。/24即255.255.255.0。<br>　　2、HTTP状态码中400代表请求报文语法有误，服务器无法识别。<br>　　3、https使用的是非对称加密，举例子就是A生成一个公钥A，发送给B。B收到后对称生成一个秘钥B并用A加密，发送给A。最后A接收到后用私钥得到秘钥B，之后A与B之间就可以利用秘钥B进行加密通信了，并不用每次做一次非对称加密。</p><h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><p>　　1、通常情况，JVM中使用类加载器的优先级是：根类加载器（bootstrap class loader）扩展类加载器（extensions class loader）系统类加载器（system class loader）用户类加载器（user class loader）。<br>　　2、Java8的Stream中的中间操作方法：<br>　　（1）过滤：filter()<br>　　（2）截断流：limit()<br>　　（3）跳过元素：skip(n)<br>　　（4）筛选：distinct()<br>　　（5）映射：map() flatMap()<br>　　（6）排序：sorted() </p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>　　1、数据库中某一个字段的值并不唯一，但是需要创建索引加速查询速度，应该选择的索引类型为普通索引。即普通索引允许被索引列有重复值。<br>　　2、</p><h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><p>　　1、采用插入方式构建一颗大小为n的红黑树的时间复杂度是：O(n*log(n))。<br>　　2、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C++&quot;&gt;&lt;/a&gt;C++&lt;/h1&gt;&lt;p&gt;　　1、逗号表达式是将括号中所有表达式的值算出来，但是只使用最后一个表达式的值。&lt;br&gt;　　2、构造函数是可以私有化的，但一般不会这样做，因
      
    
    </summary>
    
      <category term="技术积累" scheme="https://liuruijie87.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="零碎知识点" scheme="https://liuruijie87.github.io/tags/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>effective C++（1）</title>
    <link href="https://liuruijie87.github.io/2019/09/17/effective%20C++%EF%BC%881%EF%BC%89/"/>
    <id>https://liuruijie87.github.io/2019/09/17/effective C++（1）/</id>
    <published>2019-09-17T02:31:04.246Z</published>
    <updated>2019-09-17T07:59:16.312Z</updated>
    
    <content type="html"><![CDATA[<p>　　01.C++总体来说包含四大部分内容，分别是：C语言部分（没有模板、异常、重载等概念）；面向对象部分（类、封装、继承、多态、虚函数等）；泛型编程部分（模板技术）；STL（容器、算法、迭代器等）。<br>　　02.对单纯常量，尽量以const对象或enums代替#define，因为宏定义是预处理器干的活，宏定义的记号名称有可能未被编译器看到，也许在编译器开始处理源码之前它就被预处理器移走了，因此编译会出错。而如果使用const等定义一个常量，编译器是一定会看到的，当然就会进入记号表内。<br>　　03.对于class专属常量，为了将常量的作用域限制于class内，必须让该常量成为class的一个成员。而为确保此常量至多只有一份实体，必须让它成为一个static成员。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">static const int Num = 5; //常量声明式</span><br><span class="line">int scores[Num];</span><br><span class="line">... </span><br><span class="line">&#125;;</span><br><span class="line">const int A::Num; //Num的定义</span><br></pre></td></tr></table></figure><p>　　上面程序中，在声明的时候已经给常量做了初始化，对于class的static类型的专属常量，只要不取它们的地址，或者不需要用到定义式，则不提供定义式也可以，因为在声明的时候已经给了初值，所以在定义式中不可以再设初值。<br>　　04.对于形似函数的宏，最好用inline函数替换#define。<br>　　05.const修饰指针的时候，如果const出现在星号左边，表示被指物是常量，如果出现在星号右边，表示指针自身是常量，如果出现在星号两边，表示被指物和指针两者都是常量。<strong>注意：</strong>当被指物是常量时，const写在类型前和类型后都可以。<br>　　06.声明STL的迭代器为const和声明指针为const是一样的操作，但是声明迭代器所指物为const需要用const_iterator。<br>　　07.non-const成员函数可以调用const成员函数，反之则不行。<br>　　08.确保对象在使用之前已经被初始化，读取未初始化的值会导致不明确的行为。<br>　　09.对于大多数类型而言，比起先调用默认构造函数后再调用拷贝赋值操作符，单只调用一次拷贝构造函数是比较高效的。对于内置类型来说，其初始化和赋值的成本相同，但为了一致性，最好也通过初始值列表来初始化。<br>　　10.如果成员变量是const或引用，则必须初始化，不能被赋值。<br>　　11.成员变量的初始化顺序是以其声明顺序被初始化的，并且父类的变量先初始化，再子类。<br>　　12.如果某编译单元内的某个全局static对象的初始化使用了另一编译单元内的某个全局static对象，它所用到的这个对象可能尚未被初始化，因为C++对“定义于不同编译单元内的全局static对象”的初始化次序并无明确定义。为解决此问题，可以用一个函数来代替这个全局对象。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//有问题的代码</span><br><span class="line">class FileSystem</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">...</span><br><span class="line">std::size_t num() const;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">extern FileSystem tfs;     //给客户使用的对象</span><br><span class="line"></span><br><span class="line">class Directory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">　　Directory(params);</span><br><span class="line">　　...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory(params)</span><br><span class="line">&#123;</span><br><span class="line">　　...</span><br><span class="line">　　std::size dis = tfs.num();   //使用tfs对象</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">Directory tempDir(params);</span><br><span class="line"></span><br><span class="line">//修改后的代码</span><br><span class="line">class FileSystem</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">...</span><br><span class="line">std::size_t num() const;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">FileSystem&amp; tfs()    //用该函数替换tfs对象</span><br><span class="line">&#123;</span><br><span class="line">static FileSystem fs;</span><br><span class="line">return fs;</span><br><span class="line">&#125;</span><br><span class="line">class Directory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">　　Directory(params);</span><br><span class="line">　　...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory(params)</span><br><span class="line">&#123;</span><br><span class="line">　　...</span><br><span class="line">　　std::size dis = tfs().num();   //改用tfs()</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">Directory&amp; tempDir()    //用该函数替换tempDir对象</span><br><span class="line">&#123;</span><br><span class="line">static Directory td;</span><br><span class="line">return td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　01.C++总体来说包含四大部分内容，分别是：C语言部分（没有模板、异常、重载等概念）；面向对象部分（类、封装、继承、多态、虚函数等）；泛型编程部分（模板技术）；STL（容器、算法、迭代器等）。&lt;br&gt;　　02.对单纯常量，尽量以const对象或enums代替#defi
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://liuruijie87.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="effective C++" scheme="https://liuruijie87.github.io/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>四年的青春，我们的故事还在继续</title>
    <link href="https://liuruijie87.github.io/2019/08/14/%E6%88%91%E4%BB%AC%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    <id>https://liuruijie87.github.io/2019/08/14/我们的故事/</id>
    <published>2019-08-14T12:50:34.300Z</published>
    <updated>2019-08-14T13:11:00.438Z</updated>
    
    <content type="html"><![CDATA[<p>今天学会了插入图片，让我来试一波吧，哈哈哈哈哈……</p><p>初次约会，多多关照</p><img src="/2019/08/14/我们的故事/1.jpg" title="初次约会"><p>一起吃火锅</p><img src="/2019/08/14/我们的故事/2.jpg" title="一起吃火锅"><p>一起看灯展</p><img src="/2019/08/14/我们的故事/3.jpg" title="一起看灯展"><p>一起去海滩</p><img src="/2019/08/14/我们的故事/4.jpg" title="一起去海滩"><p>一起去海滩+1</p><img src="/2019/08/14/我们的故事/5.jpg" title="一起去海滩+1"><p>一起去海滩+2</p><img src="/2019/08/14/我们的故事/6.jpg" title="一起去海滩+2"><p>毕业了…</p><img src="/2019/08/14/我们的故事/7.jpg" title="毕业了..."><p>一起逛北京</p><img src="/2019/08/14/我们的故事/8.jpg" title="一起逛北京">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天学会了插入图片，让我来试一波吧，哈哈哈哈哈……&lt;/p&gt;
&lt;p&gt;初次约会，多多关照&lt;/p&gt;
&lt;img src=&quot;/2019/08/14/我们的故事/1.jpg&quot; title=&quot;初次约会&quot;&gt;

&lt;p&gt;一起吃火锅&lt;/p&gt;
&lt;img src=&quot;/2019/08/14/我们的故事
      
    
    </summary>
    
      <category term="生活杂谈" scheme="https://liuruijie87.github.io/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="生活杂谈" scheme="https://liuruijie87.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
