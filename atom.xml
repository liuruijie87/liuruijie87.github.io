<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuruijie</title>
  
  <subtitle>快乐搬砖，码出未来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liuruijie87.github.io/"/>
  <updated>2020-03-05T14:36:55.068Z</updated>
  <id>https://liuruijie87.github.io/</id>
  
  <author>
    <name>liuruijie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一次完整的http请求过程</title>
    <link href="https://liuruijie87.github.io/2020/03/05/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84http%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <id>https://liuruijie87.github.io/2020/03/05/一次完整的http请求过程/</id>
    <published>2020-03-05T14:30:21.648Z</published>
    <updated>2020-03-05T14:36:55.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一次完整的http请求过程（在浏览器输入URL后，执行的全部过程）"><a href="#一次完整的http请求过程（在浏览器输入URL后，执行的全部过程）" class="headerlink" title="一次完整的http请求过程（在浏览器输入URL后，执行的全部过程）"></a>一次完整的http请求过程（在浏览器输入URL后，执行的全部过程）</h1><p>1.首先进行域名解析，域名解析具体过程讲一下：<br>　　浏览器搜索自己的DNS缓存，缓存中维护一张域名与IP地址的对应表；<br>　　若没有，则搜索操作系统的DNS缓存；<br>　　若没有，则操作系统将域名发送至本地域名服务器（递归查询方式），本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则，通过以下方式迭代查找：<br>　　　　本地域名服务器向根域名服务器发起请求，根域名服务器返回com域的顶级域名服务器的地址；<br>　　　　本地域名服务器向com域的顶级域名服务器发起请求，返回权限域名服务器地址；<br>　　　　本地域名服务器向权限域名服务器发起请求，得到IP地址；<br>　　本地域名服务器将得到的IP地址返回给操作系统，同时自己将IP地址缓存起来；<br>　　操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来；<br>　　至此，浏览器已经得到了域名对应的IP地址。<br>2.浏览器发起HTTP请求；<br>3.接下来到了传输层，选择传输协议，TCP或者UDP，TCP是可靠的传输控制协议，对HTTP请求进行封装，加入了端口号等信息；<br>4.然后到了网络层，通过IP协议将IP地址封装为IP数据报；然后此时会用到ARP协议，主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，找到目的MAC地址；<br>5.接下来到了数据链路层，把网络层交下来的IP数据报添加首部和尾部，封装为MAC帧，现在根据目的mac开始建立TCP连接，三次握手，接收端在收到物理层上交的比特流后，根据首尾的标记，识别帧的开始和结束，将中间的数据部分上交给网络层，然后层层向上传递到应用层；<br>6.服务器响应请求并请求客户端要的资源，传回给客户端；<br>7.断开TCP连接，浏览器对页面进行渲染呈现给客户端。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一次完整的http请求过程（在浏览器输入URL后，执行的全部过程）&quot;&gt;&lt;a href=&quot;#一次完整的http请求过程（在浏览器输入URL后，执行的全部过程）&quot; class=&quot;headerlink&quot; title=&quot;一次完整的http请求过程（在浏览器输入URL后，执
      
    
    </summary>
    
      <category term="技术积累" scheme="https://liuruijie87.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="https和http" scheme="https://liuruijie87.github.io/tags/https%E5%92%8Chttp/"/>
    
  </entry>
  
  <entry>
    <title>从https协议谈对称加密和非对称加密</title>
    <link href="https://liuruijie87.github.io/2020/03/05/%E4%BB%8Ehttps%E5%8D%8F%E8%AE%AE%E8%B0%88%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    <id>https://liuruijie87.github.io/2020/03/05/从https协议谈对称加密和非对称加密/</id>
    <published>2020-03-05T14:05:23.424Z</published>
    <updated>2020-03-05T14:28:50.673Z</updated>
    
    <content type="html"><![CDATA[<p>　　首先，我们为什么要用https协议，在此我们举例说明：你在网上商城，发送一个购物的请求，要购买一件商品，但你的数据包被黑客截获了，黑客在网上商城服务器回复你之前回复你，让你提供银行卡账号和密码，如果你未能识别出这是黑客行文，那么后果就可以自己想象了。<br>　　为了解决这个问题，一般的思路就是加密。加密后的数据包黑客就算截获了了也无法解密，也就无法知道你要干嘛，就无从构造回复报文。加密分为两种方式：对称加密和非对称加密。<br>　　在对称加密算法中，加密和解密使用的密钥是相同的，因此在使用对称加密算法的时候一定要保证密钥不被泄露。<br>　　在非对称加密算法中，加密使用的密钥和解密使用的密钥是不同的，一把是作为公开的公钥，另一把是作为谁都不能给的密钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。<br>　　在效率方面，对称加密算法的效率比非对称加密算法的效率要高的多。<br>　　接下来我们详细说下对称加密。<br>　　假如使用对称加密，在购物时你和网上商城约定了一个密钥，你发送请求的时候用这个密钥加密，网上商城使用同样的密钥解密，这样看起来没有一起都很OK，但有个问题，你和商城怎样约定密钥而不被截获了，既在加密建立前如何安全的传送密钥？如果直接传送密钥的信息，那么这信息可能被黑客截获，之后所有的通信黑客都可以解密查看了，也就没有秘密了。我们总不能和商城的人约定一个时间地点然后线下传送密钥吧，就算是线下接头那是不是也要有个约定的暗号什么的，不然你们又不认识，但在传输暗号的时候还是可能被黑客截获，那么线下和你接头的人也说不好是谁呢…<br>　　So，只要是使用对称加密，如何安全的传送密钥就是一个绕不开的问题，如果只使用对称加密，就会陷入一个密钥传送的死循环，幸好此时我们的非对称加密挺身而出。<br>　　网站使用非对称加密的时候，他的密钥放在自己的口袋里谁也不给，但他会把公钥放在一个指定的地方谁都可以获取，只要你拿到了公钥，在你网站交流的时候，你用公钥加密你的信息，这时就算被人截获但因为缺少私钥，所以黑客也解不开你的信息。目前为止，一切开起来很顺利，但网站在给你回复信息的时候有个问题：网站的回复信息是拿他自己的私钥加密的，这个信息谁都可以用公钥来解密的。看来要解决这个问题，只使用网站的公私钥还不行，客户端也得有自己的公私钥，客户端把自己的公钥给网站，把私钥放在自己口袋，在和网站通信的时候客户端使用网站的公钥加密，网站使用客户端的私钥加密回复信息，至此解决了非对称加密的保密性问题。<br>　　但对于非对称加密也有和对称加密一样的问题，如何将公钥给到对方，前面其实我们也说过一个方法，就是把各自的公钥放在公网上，这样谁都可以去取；还有另一种方法，就是在建立连接的时候把公钥传给对方。但这两种方式都有一个问题，你怎么确保给到你的公钥就是你信任的人呢，有没有可能有人假冒对方呢，答案是完全有可能。<br>　　解决信任问题，最好的方法就是证明，证明什么呢，证明“你是你”！在现实生活中要证明你是你，你需要拿着公安局给你的身份证或者户口本来证明，别人不一定信任你，但身份证的颁发机构是公安局，是权威机构，别人看到身份证也就相信了你是你。其实在网络中也一样，你也需要一个权威机构给你一个证明，证明你是你，证明他是他，证明我是我…在网络世界里，权威部门颁发给你的身份证被称为“证书”。<br>　　在证书中包含：公钥、证书的所有者、证书的发布机构、和证书的有效期。这样来看证书其实和身份证很像~，证书是怎么来的呢，有没有可能有假的证书呢，就像假的身份证一样？<br>　　要生成证书需要发起一个证书请求，然后将这个请求发给权威机构去认证，这个权威机构不是公安局而是CA（Certificate Authority），把生成证书的请求发给权威机构后，权威机构会给这个证书卡个公章，我们称之为签名算法，接着，继续我们的怀疑精神，有没有可能会仿造签名呢，该怎么解决呢？签名算法解决了伪造签名的问题，签名算法用自己的私钥来进行签名，这样能用他的公钥解开的签名就能证明这个签名是真的。<br>　　签名算法一般先对信息做一个hash运算，得到一个hash值，我们都知道这个过程是不可逆的，也就是无法根据hash值推导出原来的信息。在把信息发送出去的时候呢，把这个hash值加密后作为签名一起发出去。<br>　　CA用自己的私钥给网站的公钥的签名，就相当于CA成了网站的担保人，担保这个公钥是这个网站的公钥而不是别人伪造的。<br>　　那么你在和网站通信的时候就不会得到一个公钥了，而是一个证书，一个由CA担保的证书，但我们都知道，信任会传递，不信任也会传递，我们凭什么相信一个我们并不了解的CA机构呢，他又不是国家的公安局，而且我们得到的证书要解密的话还需要CA的公钥，我们怎么获取CA的公钥呢，怎么去相信获得的是CA的公钥呢，这是不是又是一个信任的死循环呢？当然不是，首先CA的公钥也要有人给他做担保人，谁呢？更牛的CA，你不相信小的CA机构，但如果是大的CA机构呢，就这样CA一层层的做担保，直到大到那种全球认可的CA机构他们不再需要担保人，因为他们自身就是root CA。<br>　　在使用Https的时候还有一种常见的证书，就是自签名证书（self-signed certificate），有点像是我给自己带盐，你爱信不信的意思。<br>　　到现在为止我们知道了，在使用https的时候我们无法只使用对称加密算法，但可以只使用非对称加密，之前我们提到过，非对称加密算法在效率上要远低于对称加密算法，因此在传输大数据量的时候我们希望能使用对称加密来提高效率，因此https将两种加密算法搭配使用，具体的过程如下：<br>　　1.客户端发送Client Hello信息到服务器，信息以明文传输TLS版本信息、加密套件候选列表、压缩算法候选列表等。另外还会给对方一个随机数，这个随机数客户端和服务器都会留着。<br>　　2.服务器会回复Server Hello消息，告诉客户端用那个协议、加密套件、压缩算法等，并且服务器也会给客户端一个自己的随机数，现在每个人手里都有两个随机数了。<br>　　3.然后服务器会给客户端自己的证书<br>　　4.服务器会告诉客户端Server Hello done，我就给你这些信息。<br>　　5.客户端会去验证这个证书，在验证的过程中会不断的上溯CA、CA的CA，一直到一个你信任的CA出来做担保。<br>　　6.证书验证通过后，客户端会生成随机数Pre-master，发送Client Key Exchange，用证书中的公钥加密发给服务器。<br>　　7.服务器有了第三（客户端给了两个，自己生成一个）个随机数，客户端也有了三个随机数，然后双方都通过“自己的随机数”+“对端的随机数”+“Pre-master”一起算出对称密钥。<br>　　8.然后双方都发送给对方一个Encrypted Handshake Message，将已经协商好的参数等，采用密钥加密发给对方，作为握手验证，双方验证通过后就可以采用对称加密通信了。<br>　　总结<br>　　加密分为对称加密和非对称加密，对称加密效率高，但是解决不了秘钥的传输问题；非对称加密可以解决这个问题，但效率不高。<br>　　非对称加密需要通过证书来验证公钥的合法性。<br>　　https是综合了对称加密和非对称加密算法的http协议。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　首先，我们为什么要用https协议，在此我们举例说明：你在网上商城，发送一个购物的请求，要购买一件商品，但你的数据包被黑客截获了，黑客在网上商城服务器回复你之前回复你，让你提供银行卡账号和密码，如果你未能识别出这是黑客行文，那么后果就可以自己想象了。&lt;br&gt;　　为了解决
      
    
    </summary>
    
      <category term="技术积累" scheme="https://liuruijie87.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="https和http" scheme="https://liuruijie87.github.io/tags/https%E5%92%8Chttp/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法学习笔记（2）-数组</title>
    <link href="https://liuruijie87.github.io/2020/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89-%E6%95%B0%E7%BB%84/"/>
    <id>https://liuruijie87.github.io/2020/01/14/数据结构与算法学习（2）-数组/</id>
    <published>2020-01-14T13:23:09.440Z</published>
    <updated>2020-01-14T13:42:26.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h1><p>　　前篇总结复杂度分析，本篇学习数组。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>　　数组（Array）是一种线性表数据结构。它用一组连续的内存空间来存储一组具有相同类型的数据。<br>　　数组和链表的区别，很多人都说，“链表适合插入、删除，时间复杂度O(1)；数组适合查找，查找时间复杂度为O(1)”。实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。<br>　　数组为了保持内存数据的连续性，会导致插入、删除这两个操作比 较低效。</p><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>　　如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是O(n)。因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为(1+2+…n)/n=O(n)。<br>　　如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须依次搬移k之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第k个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置。</p><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>　　跟插入数据类似，如果我们要删除第k个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为O(1)；如果删除开头的数据，则最坏情况时间复杂度为O(n)；平均情况时间复杂度也为O(n)。</p><h2 id="警惕数组的访问越界问题"><a href="#警惕数组的访问越界问题" class="headerlink" title="警惕数组的访问越界问题"></a>警惕数组的访问越界问题</h2><p>　　数组越界在C语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。</p><h2 id="容器能否完全替代数组？"><a href="#容器能否完全替代数组？" class="headerlink" title="容器能否完全替代数组？"></a>容器能否完全替代数组？</h2><p>　　针对数组类型，很多语言都提供了容器类，比如Java中的ArrayList、C++STL中的vector。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？<br>　　数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为10的数组，当第11个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。如果使用vector等容器，我们就完全不需要关心底层的扩容逻辑，vector已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为2倍大小。<br>　　不过，这里需要注意一点，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建vector的时候事先指定数据大小。<br>　　作为高级语言编程者，是不是数组就无用武之地了呢？当然不是，有些时候，用数组会更合适些，我总结了几点自己的经验：<br>　　1.如果数据大小事先已知，并且对数据的操作非常简单，用不到vector提供的大部分方法，也可以直接使用数组<br>　　2.还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如int Object[][]array；而用容器的话则需要这样定义：vector&lt;vector<int>&gt; v;<br>　　总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</int></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h1&gt;&lt;p&gt;　　前篇总结复杂度分析，本篇学习数组。&lt;/p&gt;
&lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="算法学习" scheme="https://liuruijie87.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="https://liuruijie87.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法学习笔记（1）-复杂度分析</title>
    <link href="https://liuruijie87.github.io/2020/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>https://liuruijie87.github.io/2020/01/13/数据结构与算法学习（1）-复杂度分析/</id>
    <published>2020-01-13T13:16:58.814Z</published>
    <updated>2020-01-14T13:27:59.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h1><p>　　众所周知，数据结构和算法是编程当中的内功，只有把内功修炼深厚，才能应对各种招式的变化。如果每天做一些机械性质的增删改查，那是注定在编程道路上走不远的，因此，从本篇开始，进行数据结构和算法的学习，并以笔记的形式进行知识点的总结。</p><h1 id="基本复杂度分析"><a href="#基本复杂度分析" class="headerlink" title="基本复杂度分析"></a>基本复杂度分析</h1><p>　　复杂度分析是算法学习的精髓，可以说掌握了复杂度分析，算法学习就成功了一半。而最常用的复杂度表示方法就是大O表示法，这是表示代码执行时间或所占空间随数据规模增长的变化趋势的一种方法。当n很大时，你可以把它想象成100000，而公式中的低阶、常量、系数三部分并不影响增长趋势，所以都可以忽略，我们只需保留一个最大量级就可以了。</p><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>　　1 只关注循环执行次数最多的一段代码。<br>　　2 加法法则：总的时间复杂度等于量级最大的那段代码的时间复杂度。即抽象公式：T(n)=T1(n)+T2(n)=Max(O(f(n)),O(g(n)))。<br>　　3 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。<br>　　常见的复杂度有O(1)、O(logn)、O(n)、O(nlogn)、O(n^2)、O(2^n)、O(n!)，其中O(2^n)和O(n!)为非多项式量级。<br>　　O(logn)比较难以分析，借用以下例子加以理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 1;</span><br><span class="line">while(i &lt;= n)&#123;</span><br><span class="line">i = i * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出i从1开始，每次循环就乘以2，当大于n时，循环结束，因此可以看出这是一个等比数列：2^0,2^1,2^2,2^3……2^k = n，其中k代表执行的次数，即k=logn（以2为底，用大O表示的话可以省略底数）。<br>　　另外，还有一种非寻常的情况，即代码的复杂度由两个数据的规模来决定，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int cal(int m, int n) &#123;</span><br><span class="line">int sum_1 = 0;</span><br><span class="line">int i = 1;</span><br><span class="line">for (; i &lt; m; ++i) &#123;</span><br><span class="line">sum_1 = sum_1 + i;</span><br><span class="line">&#125;</span><br><span class="line">int sum_2 = 0;</span><br><span class="line">int j = 1;</span><br><span class="line">for (; j &lt; n; ++j) &#123;</span><br><span class="line">sum_2 = sum_2 + j;</span><br><span class="line">&#125;</span><br><span class="line">return sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，m和n表示两个数据规模，我们无法事先评估,m和n谁的量级大，所以复杂度就是O(m+n)。</p><h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>　　空间复杂度一般比较简单，能够通过肉眼看出来，例如下面代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void print(int n) &#123;</span><br><span class="line">int i = 0;</span><br><span class="line">int[] a = new int[n];</span><br><span class="line">for (i; i &lt;n; ++i) &#123;</span><br><span class="line">a[i] = i * i;</span><br><span class="line">&#125;</span><br><span class="line">for (i = n-1; i &gt;= 0; --i) &#123;</span><br><span class="line">print out a[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　可以看到，申请了一个大小为n的int类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是O(n)。</p><h1 id="最好、最坏时间复杂度"><a href="#最好、最坏时间复杂度" class="headerlink" title="最好、最坏时间复杂度"></a>最好、最坏时间复杂度</h1><p>　　顾名思义，最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。同理，最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">int i = 0;</span><br><span class="line">int pos = -1;</span><br><span class="line">for (; i &lt; n; ++i) &#123;</span><br><span class="line">if (array[i] == x) &#123;</span><br><span class="line">pos = i;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　上述代码中，在一个数组中查找x，如果x是第一个数，则最快，而如果x不存在数组中，则要遍历n次，因此，最好复杂度O(1)，最坏复杂度O(n)。</p><h1 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h1><p>　　还是上述代码，为了方便你理解，我们假设在数组中与不在数组中的概率都为1/2。另外，要查找的数据出现在0～n-1这n个位置的概率也是一样的，为1/n。所以，根据概率乘法法则，要查找的数据出现在0～n-1中任意位置的概率就是1/(2n)。因此平均时间复杂度的计算过程为：1/2n+2/2n+……+n/2n+n/2=(3n+1)/4。这个值就是加权平均值，用大O法表示即：O(n)。</p><h1 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h1><p>　　首先看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int[] array = new int[n];</span><br><span class="line">int count = 0;</span><br><span class="line">void insert(int val) &#123;</span><br><span class="line">if (count == array.length) &#123;</span><br><span class="line">int sum = 0;</span><br><span class="line">for (int i = 0; i &lt; array.length; ++i) &#123;</span><br><span class="line">sum = sum + array[i];</span><br><span class="line">&#125;</span><br><span class="line">array[0] = sum;</span><br><span class="line">count = 1;</span><br><span class="line">&#125;</span><br><span class="line">array[count] = val;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用for循环遍历数组求和，并清空数组，将求和之后的sum值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。<br>　　最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为count的位置就可以了，所以最好情况时间复杂度为O(1)。最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为O(n)。<br>　　假设数组的长度是n，根据数据插入的位置的不同，我们可以分为n种情况，每种情况的时间复杂度是O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是O(n)。而且，这n+1种情况发生的概率一样，都是1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：1/(n+1)+1/(n+1)+……+n/(n+1)=O(1)。<br>　　每一次O(n)的插入操作，都会跟着n-1次O(1)的插入操作，所以把耗时多的那次操作均摊到接下来的n-1次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是O(1)。这就是均摊分析的大致思路。<br>　　对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系（即有规律），这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h1&gt;&lt;p&gt;　　众所周知，数据结构和算法是编程当中的内功，只有把内功修炼深厚，才能应对各种招式的变化。如果每天做一些机械性质的增删改查，那是注定在编程道
      
    
    </summary>
    
      <category term="算法学习" scheme="https://liuruijie87.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="https://liuruijie87.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构知识点</title>
    <link href="https://liuruijie87.github.io/2019/12/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://liuruijie87.github.io/2019/12/10/数据结构知识点/</id>
    <published>2019-12-10T02:29:22.283Z</published>
    <updated>2020-01-13T13:23:34.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>　　1、一个节点所拥有子树的个数被称为它的度。度为0的节点被称为叶节点。树的度等于树中所有节点的度的最大值。<br>　　2、一个节点的层次通过令根节点位于第一层来定义（有些书中将根节点的层次定义为0）。如果一个节点位于层次n，那么它的孩子位于层次n+1。树的高度或深度定义为树中节点的最大层次。<br>　　3、位于二叉树第i层的节点个数最多为2^(i-1),i&gt;=1。深度为k的二叉树的最大节点个数为2^k-1，k&gt;=1。<br>　　4、二叉树的遍历分为前序、中序、后序遍历，例如前序遍历是指：在遍历某一节点的左右子树之前先访问该节点。中序和后序与此类似。<br>　　5、二叉搜索树（BST）的节点放置规则：任何节点的键值一定大于其左子树中的每一个节点的键值，并小于其右子树中的每一个节点的键值。因此，从根节点一直往左走，直到无左路可走，即得最小元素，从根节点一直往右走，直到无右路可走，即得最大元素。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h1&gt;&lt;p&gt;　　1、一个节点所拥有子树的个数被称为它的度。度为0的节点被称为叶节点。树的度等于树中所有节点的度的最大值。&lt;br&gt;　　2、一个节点的层次通过令根节
      
    
    </summary>
    
      <category term="技术积累" scheme="https://liuruijie87.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="数据结构" scheme="https://liuruijie87.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>逻辑右移和算术右移</title>
    <link href="https://liuruijie87.github.io/2019/12/09/%E9%80%BB%E8%BE%91%E5%8F%B3%E7%A7%BB%E5%92%8C%E7%AE%97%E6%9C%AF%E5%8F%B3%E7%A7%BB/"/>
    <id>https://liuruijie87.github.io/2019/12/09/逻辑右移和算术右移/</id>
    <published>2019-12-09T05:41:46.808Z</published>
    <updated>2019-12-09T05:45:25.320Z</updated>
    
    <content type="html"><![CDATA[<p>　　逻辑右移就是不考虑符号位，右移一位，左边补零即可。<br>　　算术右移需要考虑符号位，右移一位，若符号位为1，就在左边补1；否则，就补0。<br>　　所以算术右移也可以进行有符号位的除法，右移n位就等于除以2的n次方。</p><p>　　例如，8位二进制数11001101分别右移一位。<br>　　逻辑右移就是01100110<br>　　算术右移就是11100110</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　逻辑右移就是不考虑符号位，右移一位，左边补零即可。&lt;br&gt;　　算术右移需要考虑符号位，右移一位，若符号位为1，就在左边补1；否则，就补0。&lt;br&gt;　　所以算术右移也可以进行有符号位的除法，右移n位就等于除以2的n次方。&lt;/p&gt;
&lt;p&gt;　　例如，8位二进制数1100110
      
    
    </summary>
    
      <category term="技术积累" scheme="https://liuruijie87.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="技术" scheme="https://liuruijie87.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>递归中的return</title>
    <link href="https://liuruijie87.github.io/2019/12/06/%E5%85%B3%E4%BA%8E%E9%80%92%E5%BD%92%E4%B8%AD%E7%9A%84return/"/>
    <id>https://liuruijie87.github.io/2019/12/06/关于递归中的return/</id>
    <published>2019-12-06T01:43:16.904Z</published>
    <updated>2019-12-06T02:31:32.317Z</updated>
    
    <content type="html"><![CDATA[<p>　　递归中的return常用来作为递归终止的条件，但是对于返回数值的情况，要搞明白它是怎么返回的。递归的方式就是自己调用自己，而在有返回值的函数中，上一层的函数还没执行完就调用下一层，因此，当达到递归终止条件时，首先return的是最底层调用的函数，return之后，继续执行上一层调用该函数之后的代码，此时我们看到的是上一层的情况，当上一层剩余的代码执行完之后，表示上一层的函数也结束，此时再返回上上一层，执行递归代码之后的代码，如此往复循环，直到返回到最上层，结束整个递归过程。需要注意的是，<strong>上一层执行递归之后的代码的时候，会调用下一层返回的值，也可以理解为在执行上一层代码的时候会调用下一层的实现过程，直到下一层执行完返回一个数值，然后再加上上一层的数值，就构成了上一层return的东西，如此往复。</strong>下面介绍例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int Sum(int n)</span><br><span class="line">        &#123;</span><br><span class="line">            if (n &lt;= 1)                  //#1</span><br><span class="line">                return n;                //#2</span><br><span class="line">            return n+Sum(n - 1);         //#3</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>　　上面是一个递归求和的代码，例如我们传参100进去，第一次执行到#3位置的时候，调用Sum(99)，此时Sum(100)还没有执行完，就已经开始执行Sum(99)了，Sum(100)要等待Sum(99)执行完后才开始执行自己未执行完的程序。同理当Sum(99)执行到#3位置的时候，也会调用Sum(98)，此时Sum(99)还没有执行完，Sum(99)要等到Sum(98)执行完之后才开始执行自己未执行完的程序…..就这样一直循环到n=1的时候，也就是在执行Sum(1)的时候满足递归结束条件，即return 1;这个时候表示Sum(1)已经执行完毕，接下来要执行Sum(2)中未执行完的内容，也就是return 2+Sum(1);而Sum(1)已经返回1，因此Sum(2)返回2+1=3，Sum(2)执行完毕，开始执行Sum(3)未执行完的内容…..如此往复，一直到Sum(99)执行完毕后，再执行Sum(100)中未执行完的内容，也就是return 100+Sum(99),而Sum(99)已经执行完毕，有返回值，因此Sum(100)=100+Sum(99)=5050。至此，整个递归过程结束，返回累加值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　递归中的return常用来作为递归终止的条件，但是对于返回数值的情况，要搞明白它是怎么返回的。递归的方式就是自己调用自己，而在有返回值的函数中，上一层的函数还没执行完就调用下一层，因此，当达到递归终止条件时，首先return的是最底层调用的函数，return之后，继续执
      
    
    </summary>
    
      <category term="技术积累" scheme="https://liuruijie87.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="技术" scheme="https://liuruijie87.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>算法积累</title>
    <link href="https://liuruijie87.github.io/2019/11/20/%E7%AE%97%E6%B3%95/"/>
    <id>https://liuruijie87.github.io/2019/11/20/算法/</id>
    <published>2019-11-20T01:06:22.363Z</published>
    <updated>2019-11-22T06:20:33.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>　　假设一个问题比较复杂，暂时找不到全局最优解，那么我们可以考虑把原问题拆成几个小问题（分而治之思想），分别求每个小问题的最优解，再把这些“局部最优解”叠起来，就“当作”整个问题的最优解了。<br>　　使用贪心算法的前提：<br>　　1、原问题复杂度过高；<br>　　2、求全局最优解的数学模型难以建立；<br>　　3、求全局最优解的计算量过大；<br>　　4、没有太大必要一定要求出全局最优解，“比较优”就可以。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;贪心算法&quot;&gt;&lt;a href=&quot;#贪心算法&quot; class=&quot;headerlink&quot; title=&quot;贪心算法&quot;&gt;&lt;/a&gt;贪心算法&lt;/h1&gt;&lt;h2 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h
      
    
    </summary>
    
      <category term="算法学习" scheme="https://liuruijie87.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="https://liuruijie87.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://liuruijie87.github.io/2019/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://liuruijie87.github.io/2019/11/12/操作系统知识点/</id>
    <published>2019-11-12T12:23:10.452Z</published>
    <updated>2020-01-13T13:22:17.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="x86-32硬件-内存架构"><a href="#x86-32硬件-内存架构" class="headerlink" title="x86-32硬件-内存架构"></a>x86-32硬件-内存架构</h2><p>　  1、地址是访问内存空间的索引。<br>　　2、80386是32位机器，即可寻址的范围是2^32=4G字节。<br>　　3、物理内存空间是计算机提交到总线上的用于访问计算机上的内存和外设的最终地址。一个计算机中只有一个物理地址空间。<br>　　4、线性地址空间是在操作系统的虚拟内存管理下，每个运行的应用程序能访问的地址空间。每个运行的程序都认为自己独享整个计算机系统的地址空间，这样可以让多个运行的应用程序之间相互隔离。<br>　　5、逻辑地址空间是应用程序直接使用的地址空间。</p><h2 id="内存使用与分段"><a href="#内存使用与分段" class="headerlink" title="内存使用与分段"></a>内存使用与分段</h2><p>　　1、重定位：修改程序中的地址（是相对地址）。<br>　　2、编译时重定位的程序只能放在内存固定位置，载入时重定位的程序一旦载入内存就不能动了。因此重定位最适合的时机是运行时重定位，即在运行每条指令时才完成重定位。（每执行一条指令都要从逻辑地址算出物理地址）每个进程有各自的基地址，在每条指令执行的第一步先从PCB中取出这个基地址。<br>　　3、内存如何使用？首先找一块空地址，得到基地址，然后将基地址写入PCB寄存器中，在程序运行中，每执行一条指令，首先从PCB中取出基地址，再加上程序中的逻辑地址，即可翻译成物理地址，这样内存就使用起来了。当进程间切换时，PCB中的值也会跟着变化。　　</p><h2 id="分段和分页机制"><a href="#分段和分页机制" class="headerlink" title="分段和分页机制"></a>分段和分页机制</h2><p>　　1、分段和分页是两种不同的地址变换机制，它们都对整个地址变换操作提供独立的处理阶段。尽管两种机制都使用存储在内存中的变换表，但所用的表结构不同。实际上，段表存储在线性地址空间，而页表存储在物理地址空间。因而段变换表可由分页机制重新定位而无需段机制的信息或合作。段变换机制把虚拟地址（逻辑地址）变换成线性地址，并且在线性地址中访问自己的表，但是并不知晓分页机制把这些线性地址转换到物理地址的过程。类似地，分页机制也不知道程序产生地址的虚拟地址空间。分页机制只是简单地把线性地址转换成物理地址，并且在物理内存中访问自己的转换表。</p><h1 id="CPU管理"><a href="#CPU管理" class="headerlink" title="CPU管理"></a>CPU管理</h1><p>　　</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>　　1、进程就是一个程序的执行过程。<br>　　2、只有进程从内核态转移到用户态时，才可能发生抢占，进程在内核态下运行是不会被抢占的。<br>　　3、多线程是指操作系统在单个进程内支持多个并发执行路径的能力。<br>　　4、进程中所有线程共享该进程的状态和资源，它们驻留在同一块地址空间中，并且可以访问到相同的数据。当一个线程改变了内存中的一个数据项时，其他线程在访问该数据项时能看到变化后的结果。<br>　　5、在大多数操作系统中，独立进程间的通信通常需要内核的介入，以提供保护和通信所需要的机制。但是由于在同一个进程中的线程共享内存和文件，它们无需调用内核就可以通信。<br>　　6、进程的终止会导致进程中所有线程的终止。<br>　　7、进程从创建（Linux下调用fork()）到结束的整个过程就是进程的生命期，进程在其生命期中的运行轨迹实际上就表现为进程状态的多次切换，如进程创建以后会成为就绪态；当该进程被调度以后会切换到运行态；在运行的过程中如果启动了一个文件读写操作，操作系统会将该进程切换到阻塞态（等待态）从而让出CPU；当文件读写完毕以后，操作系统会在将其切换成就绪态，等待进程调度算法来调度该进程执行……<br>　　8、用户态到内核态只能通过中断的方式。</p><h2 id="进程同步与死锁"><a href="#进程同步与死锁" class="headerlink" title="进程同步与死锁"></a>进程同步与死锁</h2><p>　　1、临界区：一次只允许一个进程进入该进程修改其信号量的那一段代码。<br>　　2、临界区代码保护原则：互斥进入，即如果一个进程在临界区中执行，则其他进程不允许进入。<br>　　3、好的临界区保护原则：（1）有空让进：当若干进程要求进入空闲临界区时，应尽快使一进程进入临界区。（2）有限等待：从进程发出进入请求到允许进入，不能无限等待。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>　　1、线程保留了并发的优点，避免了进程切换代价。<br>　　2、用户级线程，在用户态下切换。如果某个线程调用硬件在内核中发生阻塞，内核就会切换到其他进程，那么在之前那个进程下的用户级线程就会卡在那不动。<br>　　3、用户级线程用了两个栈，而内核级线程用了两套栈。即用户级线程切换的时候，TCB切换，用户栈也跟着切换；内核级线程切换的时候，TCB切换，用户栈和内核栈都要跟着切换。<br>　　4、内核级线程在内核栈之间切换的时候，通过TCB找到内核栈指针，然后通过ret切到某个内核程序，最后再用CS:PC切到用户程序。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>　　1、在通常情况下，调用系统调用和调用一个普通的自定义函数在代码上并没有什么区别，但调用后发生的事情有很大不同。调用自定义函数是通过 call 指令直接跳转到该函数的地址，继续运行。而调用系统调用，是调用系统库中为该系统调用编写的一个接口函数，叫 API（Application Programming Interface）。API并不能完成系统调用的真正功能，它要做的是去调用真正的系统调用，过程是：把系统调用的编号存入EAX；把函数参数存入其它通用寄存器；触发 0x80 号中断（int 0x80），进入内核态，调用相关的内核函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h1&gt;&lt;h2 id=&quot;x86-32硬件-内存架构&quot;&gt;&lt;a href=&quot;#x86-32硬件-内存架构&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="操作系统学习" scheme="https://liuruijie87.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="操作系统" scheme="https://liuruijie87.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>effective C++（2）</title>
    <link href="https://liuruijie87.github.io/2019/09/30/effective%20C++%EF%BC%882%EF%BC%89/"/>
    <id>https://liuruijie87.github.io/2019/09/30/effective C++（2）/</id>
    <published>2019-09-30T00:27:33.578Z</published>
    <updated>2019-09-30T01:26:10.508Z</updated>
    
    <content type="html"><![CDATA[<p>　　1.如果你打算在一个内含引用的类内支持赋值操作，你必须自己定义拷贝赋值操作符。<br>　　2.如果某个基类将拷贝赋值操作符声明为private，编译器就会拒绝为其子类生成一个拷贝赋值操作符。<br>　　3.当子类对象经由一个基类指针被删除，而该基类带着一个非虚析构函数，则在实际执行的时候，对象的子类部分没被销毁。将基类的析构函数声明为虚函数之后，子类的析构函数也自动成为虚析构函数，在主函数中基类指针指向的是派生类对象，当delete释放指针所指向的存储空间时，会执行派生类的析构函数，派生类的析构函数执行完之后会紧接着执行基类的析构函数，以释放从基类继承过来的成员变量所消耗的资源。<br>　　4.auto_ptrs有个不寻常的性质，若通过拷贝构造或拷贝赋值运算符复制它们，它们会变成null，而复制所得的指针将取得资源的唯一拥有权。<br>　　5.应该尽量延后变量的定义，直到能够给它初值实参为止，因为这样不仅能够避免构造和析构非必要对象，还可以避免毫无意义的默认构造行为。<br>　　6.将大多数inline限制在小型、频繁调用的函数身上。<br>　　7.public继承意味着“is a”的关系，虚函数意味着接口必须被继承，非虚函数意味着接口和实现都必须被继承。<br>　　8.private继承使得基类所有成员在子类中的访问权限变为private。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　1.如果你打算在一个内含引用的类内支持赋值操作，你必须自己定义拷贝赋值操作符。&lt;br&gt;　　2.如果某个基类将拷贝赋值操作符声明为private，编译器就会拒绝为其子类生成一个拷贝赋值操作符。&lt;br&gt;　　3.当子类对象经由一个基类指针被删除，而该基类带着一个非虚析构函数，
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://liuruijie87.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="effective C++" scheme="https://liuruijie87.github.io/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>C++零碎知识点</title>
    <link href="https://liuruijie87.github.io/2019/09/28/C++%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://liuruijie87.github.io/2019/09/28/C++零碎知识点/</id>
    <published>2019-09-28T06:18:07.278Z</published>
    <updated>2020-03-01T11:31:10.220Z</updated>
    
    <content type="html"><![CDATA[<p>　　1、逗号表达式是将括号中所有表达式的值算出来，但是只使用最后一个表达式的值。<br>　　2、构造函数是可以私有化的，但一般不会这样做，因为私有化的构造函数不能被new到，并且类不能通过该私有构造函数初始化（可以调用静态方法初始化）。<br>　　3、一个类中可以有任意个构造函数（可以函数重载），但只能有一个析构函数。无论何时，只要类的对象被创建，就会执行构造函数。<br>　　4、类的静态数据成员只能在类内声明，类外定义和初始化。因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。const的静态成员可以在类内初始化，是因为它既然是const的，那后面的程序就不会再去试图初始化了。<br>　　5、当用#include“file.h”时，先搜索当前工作目录，如果没有，再去搜索标准库，库没有再搜索资源库；当用#include&lt;file.h&gt;时，编译器先从标准库开始搜索，如果没再搜索资源库目录，若还未找到则搜索当前工作目录。<br>　　6、字符数组的复制要用strcpy()函数,不能直接用赋值操作符赋值。不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。<br>　　7、数组名就是数组首元素的地址，在用scanf函数输入的时候，不用加&amp;。<br>　　8、定义数组时可以对第一维的长度不指定，但第二维的长度不能省去。<br>　　9、C++运算符是有优先级的，一般是算术运算符&gt;关系运算符&gt;逻辑运算符&gt;条件运算符，所以运算符顺序是!（一元算术运算符）&gt;  !=（关系运算符）&gt;  &amp;&amp;（逻辑运算符）&gt;  ?:（条件运算符）<br>　　10、内存对齐的3大规则:<br>　　（1）对于结构体的各个成员，第一个成员的偏移量是0，排列在后面的成员其当前偏移量必须是当前成员类型的整数倍。<br>　　（2）结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍。<br>　　（3）如程序中有#pragma  pack(n)预编译指令，则所有成员对齐以n字节为准(即偏移量是n的整数倍)，不再考虑当前类型以及最大结构体内类型。<br>　　11、✳是scanf函数中的一种修饰符，表示忽略该输入项，使用方法为：放在%与格式d（或者s，c等）之间，如：scanf(“%x%✳d%o”,&amp;x,&amp;y); 并且，scanf不能指明浮点数的精度。<br>　　12、子类实现父类虚函数叫重写，不叫重载。父类有纯虚函数，子类可以不实现，此时子类仍是抽象类。<br>　　13、继承类构造函数中，成员初始化列表同时出现对虚基类和非虚基类构造函数的调用时，虚基类的构造函数先于非虚基类的构造函数执行。<br>　　14、C语言中&amp;&amp;是一种双目运算符，表示与运算，而当左边所给表达式或变量为0时，不再计算右侧，整个表达式为零。<br>　　15、C语言中有数字三种表示：十进制、八进制(0开头)、十六进制(0x开头)。<br>　　16、内联函数是指用inline关键字修饰的函数。在类内定义的函数被默认成内联函数。内联函数从源代码层看，有函数的结构，而在编译后，却不具备函数的性质。内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处。编译时，类似宏替换，使用函数体替换调用处的函数名。一般在代码中用inline修饰，但是能否形成内联函数，需要看编译器对该函数定义的具体处理。<br>　　17、结构化程序由三种基本结构组成，三种基本结构组成的算法只能完成符合结构化的任务。<br>　　18、字符数组整体输入输出只是库函数里面用循环来完成一个一个元素的输入输出的，宏观上看上去就成了整体输入输出了。本质上说，与整型数组单个元素输入输出并没有区别，差别在于整型数组并不知道什么位置终止，需要人为地控制输入输出终止的条件，字符数组则很简单，输出默认’\0’终止，输入则默认空白字符或者换行。<br>　　19、read是UNIX或类UNIX系统中的系统函数，而fread才是C库里面的库函数。<br>　　20、在类定义时，无法使用构造函数，因而无法完成对象的初始化，类还没有定义完，不能初始化对象。只有在定义类对象时才会调用构造函数。<br>　　21、一般成员变量需要在类内进行初始化。静态成员变量必须在类外初始化，int型静态成员常量在类中初始化。<br>　　22、由于类的构造次序是由基类到派生类，所以在构造函数中调用虚函数，这个虚函数不会呈现出多态；相反，类的析构是从派生类到基类，当调用继承层次中某一层次的类的析构函数时往往意味着其派生类部分已经析构掉，所以也不会呈现出多态。（effeetive c++ 条款9）。<br>　　23、虚函数可以声明为inline，因为加上inline只是我们对编译器的一种建议，是否为inline还得看编译器的选择。相反，内联函数不能为虚函数，因为函数的内联属性是在编译器确定的，是静态行为，而虚函数的性质是在运行期确定的，是动态行为，二者是矛盾的，所以要想作为内联函数，就不要将它写成虚函数。<br>　　24、在C中使用malloc时不需要强制类型转换，因为在C中从void※到其他类型的指针是自动隐式转换的；在C++中使用malloc时必须要强制类型转换，否则会报错，因为C++是不支持void※类型隐式转换为其他类型的，但在c++中一般用new而不用malloc。malloc有一个参数。<br>　　25、宏定义不做语法检查。预处理是在编译之前的处理，而编译的工作之一便是语法检查，所以预处理不做语法检查。<br>　　26、C++中引入友元函数，是为在该类中提供一个对外（除了他自己意外）访问的窗口;这个友元函数不属于该类的成员函数，他是定义在类外的普通函数，只是在类中声明该函数可以直接访问类中的private或者protected成员。<br>　　27、使用友元函数注意的要点：<br>　　　　1）类中通过使用关键字friend来修饰友元函数，但该函数并不是类的成员函数，其声明可以放在类的私有部分，也可放在共有部分。友元函数的定义在类体外实现，不需要加类限定。<br>　　　　2）一个类中的成员函数可以是另外一个类的友元函数，而且一个函数可以是多个类友元函数。<br>　　　　3）友元函数可以访问类中的私有成员和其他数据，但是访问不可直接使用数据成员，需要通过对对象进行引用。<br>　　　　4）友元函数在调用上同一般函数一样，不必通过对对象进行引用。<br>　　28、程序占用三种类型的内存：静态内存、栈内存、堆内存；<br>　　静态内存：用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。<br>　　栈内存：用来保存定义在函数内的非static对象。<br>　　堆内存：在程序运行时分配。<br>　　分配在静态内存或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。动态对象的生存周期由程序（用户）来控制。<br>　　29、数组指针和指针数组的区别：<br>　　指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身的大小决定，每一个元素都是一个指针，在32 位系统下任何类型的指针永远是占4 个字节。它是“储存指针的数组”的简称。<br>　　数组指针：首先它是一个指针，它指向一个数组。在32位系统下任何类型的指针永远是占4个字节，至于它指向的数组占多少字节，不知道，具体要看数组大小。它是“指向数组的指针”的简称。<br>　　30、C语言中实数常数的科学表示法规定格式为：“实数e整数”或“实数E整数”，其中幂是整数，不能写成实数。e(或E)前后的实数和整数都不能省略掉。C语言规定。0开头的是八进制数，0x(0x)开头的是十六进制数。而八进制数数字是0～7，出现8是错误的。实数的小数点前后的数字都可以不写。<br>　　31、逗号表达式的求解过程是：先求解表达式1，再求解表达式2。整个逗号表达式的值是表达式2的值。例如逗号表达式a=3+5,a+4，对此表达式的求解，赋值运算符的优先级别高于逗号运算符，因此应先求解a=3+5，经计算和赋值后得到a的值为8，然后求解a+4，得12，整个逗号表达式的值为12(a仍为8)。<br>　　32、文件指针指向的是一块内存区域，这块区域存储着打开的文件的相关信息，包括文件读取指针当前位置、文件读取缓冲区大小等信息，并不是指向文件的。fscanf是从文件中格式化读取，fprintf是向文件中格式化写入。<br>　　33、类的方法后面加了const后，该方法的实现中不能修改类的成员。<br>　　34、文件读写操作的几种模式：<br>　　　　r代表read的简写，+代表可读可写，w代表write，b代表bit二进制位，t代表text。 </p><p>　　　　r 打开只读文件，该文件必须存在。<br>　　　　r+ 打开可读可写的文件，该文件必须存在(这里的写文件是指将之前的文件覆盖。<br>　　　　rt 打开只读文本文件，该文本必须存在。<br>　　　　rt+ 读写打开一个文本文件，允许读和写，该文件必须存在(这里的写文件是指将之前的文件覆盖。<br>　　　　rb 只读打开一个二进制文件，该文件必须存在。<br>　　　　rb+ 读写打开一个二进制文件，允许读和写，该文件必须存在(这里的写文件是指将之前的文件覆盖。 </p><p>　　　　w 打开只写文件，若文件存在，则文件长度清零，即文件内容会消失，若文件不存在则建立该文件。<br>　　　　w+ 打开可读写文件，若文件存在，则文件长度清零，即文件内容会消失，若文件不存在则建立该文件(这里的读文件，同样需要使用rewind()函数)。<br>　　　　wt 打开只写文本文件，若文件存在，则文件长度清零，即文件内容会消失，若文件不存在则建立该文件。<br>　　　　wt+ 打开可读写文本文件，若文件存在，则文件长度清零，即文件内容会消失，若文件不存在则建立该文件。<br>　　　　wb 打开只写二进制文件，若文件存在，则文件长度清零，即文件内容会消失，若文件不存在则建立该文件。<br>　　　　wb+ 打开可读写二进制文件，若文件存在，则文件长度清零，即文件内容会消失，若文件不存在则建立该文件。 </p><p>　　　　a 以附加的方式打开只写文件，若文件不存在，则建立文件，存在则在文件尾部添加数据,即追加内容。<br>　　　　a+ 以附加的方式打开可读写文件，不存在则建立文件，存在则写入数据到文件尾(这里的读文件，同样需要使用rewind()函数，但是写文件不需要rewind()函数，a是追加)。<br>　　　　at 文本数据的追加，不存在则创建，只能写。<br>　　　　at+ 读写打开一个文本文件，允许读或在文本末追加数据(这里的读文件，同样需要使用rewind()函数，但是写文件不需要rewind()函数，a是追加)。<br>　　　　ab 二进制数据的追加，不存在则创建，只能写。<br>　　　　ab+ 读写打开一个二进制文件，不存在则创建,允许读或在文本末追加数据(这里的读文件，同样需要使用rewind()函数，但是写文件不需要rewind()函数，a是追加)。<br>　　35、静态局部变量和全局变量的区别：静态局部变量虽然和全局变量都存放在全局数据区，延长了生命周期，但是作用域不同！静态局部变量仍然是个局部变量，只对函数内可见。<br>　　36、栈空间上面的局部变量默认初始化为随机值。全局整形变量和静态static整形变量默认初始值为0。<br>　　37、c++中包含纯虚函数的类称为抽象类，由于抽象类中包含了没有定义的纯虚函数，所以不能定义抽象类的对象。<br>　　38、抽象类只能用作其他类的基类，不能定义抽象类的对象。抽象类不能用于参数类型、函数返回值或显示转换的类型。抽象类可以定义抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。<br>　　39、逻辑运算符的优先级：! &gt; &amp;&amp; &gt; ||。!运算符比许多C++运算符具有更高的优先级。因此，为了避免错误，应始终将其操作数括在括号中，除非打算将其应用于没有其他操作符的变量或简单表达式。<br>　　40、运算符优先级：！&gt; 算术运算符 &gt; 关系运算符 &gt; （&amp;&amp; ||）&gt; 条件运算符&gt; 赋值运算符 &gt; 逗号运算符。<br>　　41、实型常量又称实数或浮点数。在C语言中可以用两种形式表示一个实型常量。<br>　　小数形式：小数形式是由数字和小数点组成的一种实数表示形式，例如0.123、.123、123.、0.0等都是合法的实型常量。<strong>注意：小数形式表示的实型常量必须要有小数点。</strong><br>　　指数形式：这种形式类似数学中的指数形式。在数学中，一个可以用幂的形式来表示，如2.3026可以表示为0.23026×10^1 2.3026×10^0 23.026×10^-1等形式。在C语言中，则以“e”或“E”后跟一个整数来表示以“10”为底数的幂数。2.3026可以表示为0.23026E1、2.3026e0、23.026e-1。C语言语法规定，字母e或E之前必须要有数字，且e或E后面的指数必须为整数。如e3、5e3.6、.e、e等都是非法的指数形式。<strong>注意：在字母e或E的前后以及数字之间不得插入空格。</strong><br>　　42、程序运行的过程中，其值不能被改变的量称为常量。常量有不同类型，其中12、0、-5为整型常量。’a’’b’为字符常量。而4.6、-8.7则为实型常量。一个实型常量可以赋给一个 float 型、double 型或 long double变量。根据变量的类型截取实型常量中相应的有效位数字。<br>　　43、用基类的指针指向不同的派生类的对象时，基类指针调用其虚成员函数，则会调用其真正指向对象的成员函数，而不是基类中定义的成员函数（只要派生类改写了该成员函数）。若不是虚函数，则不管基类指针指向的哪个派生类对象，调用时都会调用基类中定义的那个函数。<br>　　44、virtual函数是动态绑定，而缺省参数值却是静态绑定。意思是你可能会在“调用一个定义于派生类内的virtual函数”的同时，却使用基类为它所指定的缺省参数值。<strong>结论</strong>：绝不重新定义继承而来的缺省参数值！（可参考《Effective C++》条款37）<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void func(int val = 1)</span><br><span class="line">    &#123; std::cout&lt;&lt;&quot;A-&gt;&quot;&lt;&lt;val &lt;&lt;std::endl;&#125;</span><br><span class="line">    virtual void test()</span><br><span class="line">    &#123; func();&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B : public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void func(int val=0)</span><br><span class="line">&#123;std::cout&lt;&lt;&quot;B-&gt;&quot;&lt;&lt;val &lt;&lt;std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main(int argc ,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    B*p = new B;</span><br><span class="line">    p-&gt;test();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p-&gt;test()执行过程理解：<br>       (1) 由于B类中没有覆盖（重写）基类中的虚函数test()，因此会调用基类A中的test()；<br>       (2) A中test()函数中继续调用虚函数 fun()，因为虚函数执行动态绑定，p此时的动态类型（即目前所指对象的类型）为B✳，因此此时调用虚函数fun()时，执行的是B类中的fun()；所以先输出“B-&gt;”；<br>       (3) 缺省参数值是静态绑定，即此时val的值使用的是基类A中的缺省参数值，其值在编译阶段已经绑定，值为1，所以输出“1”；<br>       最终输出“B-&gt;1”。所以记住上述结论：<strong>绝不重新定义继承而来的缺省参数值！</strong><br>　　45、char✳ strcpy(char ✳dest,char ✳src)；将从src开始包含’\0’的字符串拷贝到以dest开始的位置，进行覆盖char✳ strcat(char ✳dest,char ✳src);将src开始的字符串添加到dest字符串的末尾(覆盖dest的\0”)两者都返回指向dest的指针。<br>　　46、所谓的左值，说通俗一点就是可以被修改和引用的值，左值可以取地址。与之相对的就是右值。在使用时，左值可以作为右值，但右值不能作为左值。例如a++操作通过临时量返回其值，该值是一个常量，因此不能被修改（不是左值），而++a就是一个左值，可以修改。a++通过一个临时量temp返回其中值,该值是一个常量，并不是用户定义的那种可以引用，寻址的变量，不能对其进行修改或者赋值操作，只能将其用来赋值给其他左值。<br>　　47、cin&gt;&gt; 该操作符是根据后面变量的类型读取数据。输入结束条件：遇到Enter、Space、Tab键。对结束符的处理：丢弃缓冲区中使得输入结束的结束符(Enter、Space、Tab)<br>　　48、const只对它左边的东西起作用，唯一的例外就是const本身就是最左边的修饰符，那么它才会对右边的东西起作用。<br>　　49、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　1、逗号表达式是将括号中所有表达式的值算出来，但是只使用最后一个表达式的值。&lt;br&gt;　　2、构造函数是可以私有化的，但一般不会这样做，因为私有化的构造函数不能被new到，并且类不能通过该私有构造函数初始化（可以调用静态方法初始化）。&lt;br&gt;　　3、一个类中可以有任意个构
      
    
    </summary>
    
      <category term="技术积累" scheme="https://liuruijie87.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="C++知识点" scheme="https://liuruijie87.github.io/tags/C-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>effective C++（1）</title>
    <link href="https://liuruijie87.github.io/2019/09/17/effective%20C++%EF%BC%881%EF%BC%89/"/>
    <id>https://liuruijie87.github.io/2019/09/17/effective C++（1）/</id>
    <published>2019-09-17T02:31:04.246Z</published>
    <updated>2019-09-17T07:59:16.312Z</updated>
    
    <content type="html"><![CDATA[<p>　　01.C++总体来说包含四大部分内容，分别是：C语言部分（没有模板、异常、重载等概念）；面向对象部分（类、封装、继承、多态、虚函数等）；泛型编程部分（模板技术）；STL（容器、算法、迭代器等）。<br>　　02.对单纯常量，尽量以const对象或enums代替#define，因为宏定义是预处理器干的活，宏定义的记号名称有可能未被编译器看到，也许在编译器开始处理源码之前它就被预处理器移走了，因此编译会出错。而如果使用const等定义一个常量，编译器是一定会看到的，当然就会进入记号表内。<br>　　03.对于class专属常量，为了将常量的作用域限制于class内，必须让该常量成为class的一个成员。而为确保此常量至多只有一份实体，必须让它成为一个static成员。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">static const int Num = 5; //常量声明式</span><br><span class="line">int scores[Num];</span><br><span class="line">... </span><br><span class="line">&#125;;</span><br><span class="line">const int A::Num; //Num的定义</span><br></pre></td></tr></table></figure><p>　　上面程序中，在声明的时候已经给常量做了初始化，对于class的static类型的专属常量，只要不取它们的地址，或者不需要用到定义式，则不提供定义式也可以，因为在声明的时候已经给了初值，所以在定义式中不可以再设初值。<br>　　04.对于形似函数的宏，最好用inline函数替换#define。<br>　　05.const修饰指针的时候，如果const出现在星号左边，表示被指物是常量，如果出现在星号右边，表示指针自身是常量，如果出现在星号两边，表示被指物和指针两者都是常量。<strong>注意：</strong>当被指物是常量时，const写在类型前和类型后都可以。<br>　　06.声明STL的迭代器为const和声明指针为const是一样的操作，但是声明迭代器所指物为const需要用const_iterator。<br>　　07.non-const成员函数可以调用const成员函数，反之则不行。<br>　　08.确保对象在使用之前已经被初始化，读取未初始化的值会导致不明确的行为。<br>　　09.对于大多数类型而言，比起先调用默认构造函数后再调用拷贝赋值操作符，单只调用一次拷贝构造函数是比较高效的。对于内置类型来说，其初始化和赋值的成本相同，但为了一致性，最好也通过初始值列表来初始化。<br>　　10.如果成员变量是const或引用，则必须初始化，不能被赋值。<br>　　11.成员变量的初始化顺序是以其声明顺序被初始化的，并且父类的变量先初始化，再子类。<br>　　12.如果某编译单元内的某个全局static对象的初始化使用了另一编译单元内的某个全局static对象，它所用到的这个对象可能尚未被初始化，因为C++对“定义于不同编译单元内的全局static对象”的初始化次序并无明确定义。为解决此问题，可以用一个函数来代替这个全局对象。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//有问题的代码</span><br><span class="line">class FileSystem</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">...</span><br><span class="line">std::size_t num() const;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">extern FileSystem tfs;     //给客户使用的对象</span><br><span class="line"></span><br><span class="line">class Directory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">　　Directory(params);</span><br><span class="line">　　...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory(params)</span><br><span class="line">&#123;</span><br><span class="line">　　...</span><br><span class="line">　　std::size dis = tfs.num();   //使用tfs对象</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">Directory tempDir(params);</span><br><span class="line"></span><br><span class="line">//修改后的代码</span><br><span class="line">class FileSystem</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">...</span><br><span class="line">std::size_t num() const;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">FileSystem&amp; tfs()    //用该函数替换tfs对象</span><br><span class="line">&#123;</span><br><span class="line">static FileSystem fs;</span><br><span class="line">return fs;</span><br><span class="line">&#125;</span><br><span class="line">class Directory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">　　Directory(params);</span><br><span class="line">　　...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory(params)</span><br><span class="line">&#123;</span><br><span class="line">　　...</span><br><span class="line">　　std::size dis = tfs().num();   //改用tfs()</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">Directory&amp; tempDir()    //用该函数替换tempDir对象</span><br><span class="line">&#123;</span><br><span class="line">static Directory td;</span><br><span class="line">return td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　01.C++总体来说包含四大部分内容，分别是：C语言部分（没有模板、异常、重载等概念）；面向对象部分（类、封装、继承、多态、虚函数等）；泛型编程部分（模板技术）；STL（容器、算法、迭代器等）。&lt;br&gt;　　02.对单纯常量，尽量以const对象或enums代替#defi
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://liuruijie87.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="effective C++" scheme="https://liuruijie87.github.io/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>四年的青春，我们的故事还在继续</title>
    <link href="https://liuruijie87.github.io/2019/08/14/%E6%88%91%E4%BB%AC%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    <id>https://liuruijie87.github.io/2019/08/14/我们的故事/</id>
    <published>2019-08-14T12:50:34.300Z</published>
    <updated>2019-08-14T13:11:00.438Z</updated>
    
    <content type="html"><![CDATA[<p>今天学会了插入图片，让我来试一波吧，哈哈哈哈哈……</p><p>初次约会，多多关照</p><img src="/2019/08/14/我们的故事/1.jpg" title="初次约会"><p>一起吃火锅</p><img src="/2019/08/14/我们的故事/2.jpg" title="一起吃火锅"><p>一起看灯展</p><img src="/2019/08/14/我们的故事/3.jpg" title="一起看灯展"><p>一起去海滩</p><img src="/2019/08/14/我们的故事/4.jpg" title="一起去海滩"><p>一起去海滩+1</p><img src="/2019/08/14/我们的故事/5.jpg" title="一起去海滩+1"><p>一起去海滩+2</p><img src="/2019/08/14/我们的故事/6.jpg" title="一起去海滩+2"><p>毕业了…</p><img src="/2019/08/14/我们的故事/7.jpg" title="毕业了..."><p>一起逛北京</p><img src="/2019/08/14/我们的故事/8.jpg" title="一起逛北京">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天学会了插入图片，让我来试一波吧，哈哈哈哈哈……&lt;/p&gt;
&lt;p&gt;初次约会，多多关照&lt;/p&gt;
&lt;img src=&quot;/2019/08/14/我们的故事/1.jpg&quot; title=&quot;初次约会&quot;&gt;

&lt;p&gt;一起吃火锅&lt;/p&gt;
&lt;img src=&quot;/2019/08/14/我们的故事
      
    
    </summary>
    
      <category term="生活杂谈" scheme="https://liuruijie87.github.io/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="生活杂谈" scheme="https://liuruijie87.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>C++对象模型（5） -- 对象构造语义学</title>
    <link href="https://liuruijie87.github.io/2019/08/13/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%885%EF%BC%89/"/>
    <id>https://liuruijie87.github.io/2019/08/13/C++对象模型（5）/</id>
    <published>2019-08-13T06:51:56.308Z</published>
    <updated>2019-08-14T03:41:36.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、继承体系下的对象构造步骤及虚函数调用"><a href="#一、继承体系下的对象构造步骤及虚函数调用" class="headerlink" title="一、继承体系下的对象构造步骤及虚函数调用"></a>一、继承体系下的对象构造步骤及虚函数调用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">A()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;A this = %p\n&quot;, this);</span><br><span class="line">cout &lt;&lt; &quot;A::A()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual ~A() &#123;&#125;</span><br><span class="line">virtual void myvirfunc() &#123;&#125;</span><br><span class="line">virtual void myvirfunc2() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B:public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">B()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;B this = %p\n&quot;, this);</span><br><span class="line">cout &lt;&lt; &quot;B::B()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual ~B() &#123;&#125;</span><br><span class="line">virtual void myvirfunc() &#123;&#125;</span><br><span class="line">virtual void myvirfunc2() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class C:public B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">C():m_c(11)</span><br><span class="line">&#123;</span><br><span class="line">myvirfunc(); //构造函数中，这里没有走虚函数表，而是直接通过虚函数地址，直接调用这个虚函数（静态方式调用）</span><br><span class="line">myvirfunc1(); //虚函数中再调虚函数，走虚函数表</span><br><span class="line">printf(&quot;C this = %p\n&quot;, this);</span><br><span class="line">cout &lt;&lt; &quot;C::C()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual ~C() &#123;&#125;</span><br><span class="line">virtual void myvirfunc() &#123;&#125;</span><br><span class="line">virtual void myvirfunc1() &#123; myvirfunc2(); &#125; </span><br><span class="line">virtual void myvirfunc2() &#123;&#125;</span><br><span class="line">int m_c;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">C cobj;</span><br><span class="line"></span><br><span class="line">C *mycobj = new C();</span><br><span class="line">mycobj-&gt;myvirfunc();  //代码实现上的多态</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　（1）继承关系为：C继承于B，B继承于A。当定义一个对象的时候，构造函数的调用顺序为：类A的构造函数、类B的构造函数、类C的构造函数。<br>　　（2）当类中有虚函数，并且在构造函数中调用时，如果被调用虚函数里面没有虚函数，则不是走虚函数表调用，而是直接通过虚函数地址静态调用。如果被调用虚函数里面再调用其他虚函数，则就会走虚函数表调用。</p><h1 id="二、对象拷贝、析构函数"><a href="#二、对象拷贝、析构函数" class="headerlink" title="二、对象拷贝、析构函数"></a>二、对象拷贝、析构函数</h1><h2 id="对象的拷贝行为"><a href="#对象的拷贝行为" class="headerlink" title="对象的拷贝行为"></a>对象的拷贝行为</h2><p>　　（1）如果我们不写自己的拷贝构造函数和拷贝赋值运算符，编译器也会有默认的对象拷贝和对象赋值行为。<br>　　（2）当我们提供自己的拷贝赋值运算符和拷贝构造函数时，我们就接管了系统默认的拷贝行为，此时，我们有责任在拷贝赋值运算符和拷贝构造函数中写适当的代码，来完成对象的拷贝或者赋值的任务。<br>　　（3）要想禁止对象的默认拷贝构造和赋值，只要把拷贝构造函数和拷贝赋值运算符私有起来，只声明，不需要写函数体。</p><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>　　编译器会给我们生成一个析构函数的情况：<br>　　（1）如果继承一个基类，基类中带析构函数，那么编译器就会给我们合成出一个析构函数来调用基类中的析构函数。<br>　　（2）如果类成员是一个类类型成员，并且这个成员带析构函数，编译器也会合成出一个析构函数，这个析构函数存在的意义是要调用这个类类型成员所在类的析构函数。<br>　　如果我们有自己的析构函数，那么编译器就会在适当的情况下扩展我们的析构函数代码：<br>　　（1）如果类成员是一个类类型成员，并且这个成员带析构函数，编译器就扩展这个类的析构函数代码，即先执行了本类的析构函数代码，再执行类类型的析构函数代码。<br>　　（2）如果继承一个基类，基类中带析构函数，那么编译器就会扩展我们类的析构函数来调用基类中的析构函数。</p><h1 id="三、局部类对象、全局类对象的构造和析构函数"><a href="#三、局部类对象、全局类对象的构造和析构函数" class="headerlink" title="三、局部类对象、全局类对象的构造和析构函数"></a>三、局部类对象、全局类对象的构造和析构函数</h1><p>　　（1）对于局部类对象，只要出了对象的作用域，编译器总会在适当的地方插入调用对象析构函数的代码。因此局部对象应该现用现定义，这样可以减少某些情况下的开销（如果在开头处定义对象，而程序还没有运行到使用对象的时候就已经退出，此时就算没有用到对象，编译器也会调用局部类对象的析构函数，这会增加不必要的开销）。<br>　　（2）全局变量是放在数据段里的，在编译阶段就会把空间分配出来（全局变量的地址在编译期间就确定好的）。全局对象，在不给初值的情况下，编译器默认会把全局对象所在内存全部清0。<br>　　（3）全局对象构造和析构的步骤：<br>　　　a)全局对象获得地址（编译时确定好的，内存也是编译时分配好的，内存时运行期间一直存在）<br>　　　b)把全局对象的内存内容清0（也叫静态初始化）<br>　　　c)调用全局对象所对应的类的构造函数<br>　　　d)main(){……}<br>　　　e)调用全局对象所对应类的析构函数<br>　　（4）全局对象在main函数执行之前就被构造完毕，可以在main函数中直接使用，在main函数执行完毕后才被析构掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;A::A()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;A::~A()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int m_i;</span><br><span class="line">&#125;;</span><br><span class="line">A g_aobj; //全局对象</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A aobj; //局部对象</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、局部静态对象的构造和析构"><a href="#四、局部静态对象的构造和析构" class="headerlink" title="四、局部静态对象的构造和析构"></a>四、局部静态对象的构造和析构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;A::A()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;A::~A()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int m_i;</span><br><span class="line">&#125;;</span><br><span class="line">const A &amp;myfunc()</span><br><span class="line">&#123;</span><br><span class="line">//局部静态对象</span><br><span class="line">static A s_aobj1; </span><br><span class="line">printf(&quot;s_aobj1的地址是%p\n&quot;, &amp;s_aobj1);</span><br><span class="line">return s_aobj1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">myfunc();</span><br><span class="line">myfunc();</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　（1）如果我们不调用myfunc()函数，那么根本不会触发A的构造函数。<br>　　（2）局部静态对象，内存地址是在编译期间就确定好的。<br>　　（3）静态局部变量刚开始也被初始化为0。<br>　　（4）局部静态对象的析构，是在main函数执行结束后才被调用的。（前提是这个静态局部对象被构造过）<br>　　（5）不管myfunc()函数被调用几次，s_aobj1这种静态局部对象只会被构造1次。（只调用一次构造函数）</p><h1 id="五、new和delete"><a href="#五、new和delete" class="headerlink" title="五、new和delete"></a>五、new和delete</h1><p>　　（1）new类对象时加不加括号的差别：如果是个空类，那么加不加括号没有区别（现实中，不可能光写一个空类）。如果类中有成员变量，则带括号的初始化会把一些和成员变量有关的内存清0，但不是整个对象的内存全部清0。当类中有构造函数，两种写法都会调用类的构造函数。<br>　　（2）new干了两个事：一个是调用operator new(malloc)，一个是调用了类A的构造函数。delete也干了两个事：一个是调用了类A的析构函数，一个是调用operator delete(free)。</p><h1 id="六、临时对象"><a href="#六、临时对象" class="headerlink" title="六、临时对象"></a>六、临时对象</h1><h2 id="拷贝构造函数相关的临时对象"><a href="#拷贝构造函数相关的临时对象" class="headerlink" title="拷贝构造函数相关的临时对象"></a>拷贝构造函数相关的临时对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;A::A()构造函数被执行&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A(const A&amp; tmpobj)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;A::A()拷贝构造函数被执行&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;A::~A()析构函数被执行&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A operator+(const A&amp; obj1, const A&amp; obj2)</span><br><span class="line">&#123;</span><br><span class="line">A tmpobj; </span><br><span class="line">return tmpobj; </span><br><span class="line">//此时编译器产生临时对象，把tmpobj对象的内容通过调用拷贝构造函数</span><br><span class="line">把tmpobj的内容拷贝构造给这个临时对象，然后返回的是这个临时对象。</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A myobj1;</span><br><span class="line">A myobj2;</span><br><span class="line">A resultobj = myobj1 + myobj2; </span><br><span class="line">//这个从operator+里返回的临时对象直接构造到了resultobj里；</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拷贝赋值运算符相关的临时对象"><a href="#拷贝赋值运算符相关的临时对象" class="headerlink" title="拷贝赋值运算符相关的临时对象"></a>拷贝赋值运算符相关的临时对象</h2><pre><code>class A{public:    A()    {        cout &lt;&lt; &quot;A::A()构造函数被执行&quot; &lt;&lt; endl;    }    A(const A&amp; tmpobj)    {        cout &lt;&lt; &quot;A::A()拷贝构造函数被执行&quot; &lt;&lt; endl;    }    A &amp; operator=(const A&amp; tmpaobj)    {        cout &lt;&lt; &quot;A::operator()拷贝赋值运算符被执行&quot; &lt;&lt; endl;        return *this;     }    ~A()    {        cout &lt;&lt; &quot;A::~A()析构函数被执行&quot; &lt;&lt; endl;    }};A operator+(const A&amp; obj1, const A&amp; obj2){    A tmpobj;    return tmpobj; //编译器产生临时对象，把tmpobj对象的内容通过调用拷贝构造函数把tmpobj的内容拷贝构造给这个临时对象,然后返回的是这个临时对象。}int main(){    A myobj1;    A myobj2;    A resultobj;    resultobj = myobj1 + myobj2;    //调用拷贝赋值运算符    //A resultobj = myobj1 + myobj2; //调用拷贝构造函数    return 1;}</code></pre><h2 id="直接运算产生的临时对象"><a href="#直接运算产生的临时对象" class="headerlink" title="直接运算产生的临时对象"></a>直接运算产生的临时对象</h2><pre><code>class A{public:    A()    {        cout &lt;&lt; &quot;A::A()构造函数被执行&quot; &lt;&lt; endl;    }    A(const A&amp; tmpobj)    {            cout &lt;&lt; &quot;A::A()拷贝构造函数被执行&quot; &lt;&lt; endl;        m_i = tmpobj.m_i;    }    A &amp; operator=(const A&amp; tmpaobj)    {        cout &lt;&lt; &quot;A::operator()拷贝赋值运算符被执行&quot; &lt;&lt; endl;                    return *this;    }    ~A()    {        cout &lt;&lt; &quot;A::~A()析构函数被执行&quot; &lt;&lt; endl;    }    int m_i;};A operator+(const A&amp; obj1, const A&amp; obj2){    A tmpobj;    tmpobj.m_i = obj1.m_i + obj2.m_i;    return tmpobj; //编译器产生临时对象，把tmpobj对象的内容通过调用拷贝构造函数把tmpobj的内容拷贝构造给这个临时对象，然后返回的是这个临时对象。}int main(){    A myobj1;    myobj1.m_i = 1;    A myobj2;            myobj2.m_i = 2;    A resultobj = myobj1 +myobj2; //临时对象被接住，不会被立即析构    myobj1 + myobj2; //产生了临时对象，然后该临时对象立即被析构；    printf(&quot;(myobj1 + myobj2).m_i = %d\n&quot;, (myobj1 + myobj2).m_i);//临时对象的析构是整行语句的最后一步，这样就能保证printf打印出来一个有效值。 编译器要往必要的地方，帮助我们插入 A tmpobja1 = (myobj1 + myobj1);这样的代码，来产生临时对象供编译器完成我们程序开发者代码要实现的意图。    return 1;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、继承体系下的对象构造步骤及虚函数调用&quot;&gt;&lt;a href=&quot;#一、继承体系下的对象构造步骤及虚函数调用&quot; class=&quot;headerlink&quot; title=&quot;一、继承体系下的对象构造步骤及虚函数调用&quot;&gt;&lt;/a&gt;一、继承体系下的对象构造步骤及虚函数调用&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://liuruijie87.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++对象模型" scheme="https://liuruijie87.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++对象模型（4） -- 函数语义学</title>
    <link href="https://liuruijie87.github.io/2019/08/11/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%884%EF%BC%89/"/>
    <id>https://liuruijie87.github.io/2019/08/11/C++对象模型（4）/</id>
    <published>2019-08-11T00:39:31.865Z</published>
    <updated>2019-08-11T08:23:01.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、普通成员函数调用方式"><a href="#一、普通成员函数调用方式" class="headerlink" title="一、普通成员函数调用方式"></a>一、普通成员函数调用方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class MYACLS</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_i;</span><br><span class="line">void myfunc(int abc)</span><br><span class="line">&#123;</span><br><span class="line">m_i += abc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//编译器视角</span><br><span class="line">void _ZN6MYACLS6myfuncEi(MYACLS *const this, int abc) //编译器会额外安插一个this指针，一般会扔到参数的开头</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_i + abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void gmyfunc(MYACLS *ptmp,int abc)</span><br><span class="line">&#123;</span><br><span class="line">ptmp-&gt;m_i += abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">MYACLS myacls;</span><br><span class="line">myacls.myfunc(18); //调用成员函数   </span><br><span class="line"></span><br><span class="line">gmyfunc(&amp;myacls, 18); //调用全局函数</span><br><span class="line"></span><br><span class="line">printf(&quot;MYACLS::myfunc的地址=%p\n&quot;, &amp;MYACLS::myfunc); //可以发现多次打印成员函数的地址，都不会改变，编译的时候已经确定好了</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　（1）c++语言设计的时候有一个要求：要求对普通成员函数的调用不应该比全局函数效率差。基于这种设计要求，编译器内部实际上是将对成员函数myfunc()的调用转换成了对全局函数的调用。<br>　　（2）成员函数有独立的内存地址，是跟着类走的，并且成员函数的地址是在编译的时候就确定好的。<br>　　（3）编译器额外增加了一个叫this的形参，是个指针，指向的其实就是生成的对象。<br>　　（4）常规成员变量的存取，都通过this形参来进行，比如上述 this-&gt;m_i + abc。</p><h1 id="二、虚成员函数、静态成员函数调用方式"><a href="#二、虚成员函数、静态成员函数调用方式" class="headerlink" title="二、虚成员函数、静态成员函数调用方式"></a>二、虚成员函数、静态成员函数调用方式</h1><h2 id="虚成员函数（虚函数）调用方式"><a href="#虚成员函数（虚函数）调用方式" class="headerlink" title="虚成员函数（虚函数）调用方式"></a>虚成员函数（虚函数）调用方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class MYACLS</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void myvirfunc()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;myvirfunc()被调用,this = %p\n&quot;, this);</span><br><span class="line">myvirfunc2();         //走虚函数表指针调用</span><br><span class="line">MYACLS::myvirfunc2(); //直接调用虚函数，效率更高。这种写法压制了虚拟机制，不再通过查询虚函数表来调用</span><br><span class="line">                      //这种用类名::虚函数名()明确调用虚函数的方式等价于直接调用一个普通函数；</span><br><span class="line">&#125;</span><br><span class="line">virtual void myvirfunc2() </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;myvirfunc2()被调用,this = %p\n&quot;, this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">MYACLS myacls;</span><br><span class="line">myacls.myvirfunc(); //用对象调用虚函数。</span><br><span class="line"></span><br><span class="line">MYACLS *pmyacls = new MYACLS(); </span><br><span class="line">pmyacls-&gt;myvirfunc(); //用指针调用虚函数</span><br><span class="line">//编译器视角</span><br><span class="line">//(*pmyacls-&gt;vptr[0])(pmyacls);</span><br><span class="line">//a)vptr，编译器给生成的虚函数表指针，指向虚函数表</span><br><span class="line">//b)[0] 虚函数表中第一项。代表myvirfunc()地址</span><br><span class="line">//c)传递一个参数进去，就是this，也是编译器给加的</span><br><span class="line">//d)*就得到了虚函数的地址；</span><br><span class="line"></span><br><span class="line">//printf(&quot;MYACLS::myvirfunc2虚函数的地址为%p&quot;, &amp;MYACLS::myvirfunc2); //地址也是在编译阶段确定的，多次打印不会变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　（1）用对象调用虚函数，就像调用普通成员函数一样,不需要通过虚函数表。<br>　　（2）用指针调用虚函数，要通过虚函数表指针查找虚函数表，通过虚函数表在好到虚函数的入口地址，完成对虚函数的调用。</p><h2 id="静态成员函数调用方式"><a href="#静态成员函数调用方式" class="headerlink" title="静态成员函数调用方式"></a>静态成员函数调用方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class MYACLS</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_i;</span><br><span class="line">void myfunc(int abc)</span><br><span class="line">&#123;</span><br><span class="line">//m_i += abc; //这里需要用到this指针，而this指针为空，则会报告异常</span><br><span class="line">mystfunc();</span><br><span class="line">&#125;</span><br><span class="line">//静态成员函数</span><br><span class="line">static int m_si;</span><br><span class="line">static void mystfunc() //不需要this参数</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;mystfunc()被调用\n&quot;);</span><br><span class="line">m_si = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">MYACLS myacls;</span><br><span class="line">MYACLS *pmyacls = new MYACLS(); </span><br><span class="line"></span><br><span class="line">myacls.mystfunc();</span><br><span class="line">pmyacls-&gt;mystfunc();</span><br><span class="line">MYACLS::mystfunc();</span><br><span class="line"></span><br><span class="line">((MYACLS *)0)-&gt;mystfunc();  //能够正常调用静态成员函数</span><br><span class="line">((MYACLS *)0)-&gt;myfunc(12);  //有些成员函数希望支持独立于类对象之外的存取操作,归为类所有，跟静态成员函数看似相似</span><br><span class="line"></span><br><span class="line">myacls.myfunc(12);   //此时如果要存取非静态成员变量，就会出错。</span><br><span class="line">pmyacls-&gt;myfunc(12);</span><br><span class="line"></span><br><span class="line">printf(&quot;MYACLS::mystfunc()地址 = %p\n&quot;, MYACLS::mystfunc);</span><br><span class="line"></span><br><span class="line">delete pmyacls;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　（1）静态成员函数没有this指针，这点最重要。<br>　　（2）无法直接存取类中普通的非静态成员变量，因为非静态成员变量是通过this指针来操作的。<br>　　（3）静态成员函数不能在后面使用const，也不能设置为virtual。<br>　　（4）可以用类对象调用，但不非一定要用类对象调用。<br>　　（5）静态成员函数等同于非成员函数，有的需要提供回调函数的这种场合，可以将静态成员函数作为回调函数；</p><h1 id="三、静态、动态类型，绑定，多态实现深谈"><a href="#三、静态、动态类型，绑定，多态实现深谈" class="headerlink" title="三、静态、动态类型，绑定，多态实现深谈"></a>三、静态、动态类型，绑定，多态实现深谈</h1><h2 id="静态类型和动态类型"><a href="#静态类型和动态类型" class="headerlink" title="静态类型和动态类型"></a>静态类型和动态类型</h2><p>　　（1）静态类型：对象定义时的类型，编译期间就确定好的。<br>　　（2）动态类型：对象目前所指向的类型（运行的时候才决定的类型）。<br>　　（3）一般只有指针或者引用才有动态类型的说法。而且一般都是指父类的指针或者引用。另外，动态类型在执行过程中可以改变。<br>　　仔细看如下代码分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void myfunc() //普通成员函数</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Base::myfunc()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void myvirfunc(int value = 1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Base::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Derive :public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void myfunc() //普通成员函数</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Derive::myfunc()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void myvirfunc(int value = 2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Derive::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Derive2 :public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void myvirfunc() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Base base;       //base的静态类型是Base，没有动态类型，因为不是指针不是引用</span><br><span class="line">Derive derive;   //derive的静态类型是Derive，没有动态类型，因为不是指针不是引用</span><br><span class="line">Base *pbase;     //pbase的静态类型依旧是Base *  ,至少目前没有动态类型，因为它没有指向任何对象</span><br><span class="line">Base *pbase2 = new Derive(); //pbase2的静态类型依旧是Base * ，动态类型是Derive </span><br><span class="line">Base *pbase3 = new Derive2(); //pbase3的静态类型依旧是Base *，动态类型是Derive2 </span><br><span class="line"></span><br><span class="line">pbase = pbase2; //pbase的动态类型Derive</span><br><span class="line">pbase = pbase3; //pbase的动态类型改变为Derive2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h2><p>　　（1）静态绑定：绑定的是静态类型，所对应的函数或者属性依赖于对象的静态类型，发生在编译期<br>　　（2）动态绑定：绑定的是动态类型，所对应的函数或者属性依赖于对象的动态类型，发生在运行期<br>　　（3）普通成员函数是静态绑定，而虚函数是动态绑定。缺省参数一般是静态绑定。<br>　　代码分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void myfunc() //普通成员函数</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Base::myfunc()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void myvirfunc(int value = 1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Base::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Derive :public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void myfunc() //普通成员函数</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Derive::myfunc()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void myvirfunc(int value = 2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Derive::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Derive derive;</span><br><span class="line">Derive *pderive = &amp;derive;</span><br><span class="line">pderive-&gt;myfunc(); //Derive::myfunc()</span><br><span class="line">Base *pbase = &amp;derive; </span><br><span class="line">pbase-&gt;myfunc(); ////Base::myfunc()      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　普通成员函数是静态绑定，换句话说，myfunc()是普通成员函数。这里到底调用父类的myfunc还是子类的myfunc取决于调用者的静态类型。<br>　　因为这里pbase的静态类型是Base，所以调用的是Base里的myfunc()；pderive的静态类型是Derive，所以调用的是Derive的myfunc()。<br>　　结论：为了避免混淆，不应该在子类中重新定义一个继承来的非虚函数。<br>　　再看如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void myfunc() //普通成员函数</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Base::myfunc()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void myvirfunc(int value = 1) //缺省参数的值为1</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Base::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Derive :public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void myfunc() //普通成员函数</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Derive::myfunc()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void myvirfunc(int value = 2) //缺省参数的值为2</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Derive::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">　　Derive derive;</span><br><span class="line">Derive *pderive = &amp;derive;</span><br><span class="line">Base *pbase = &amp;derive; </span><br><span class="line"></span><br><span class="line">pderive-&gt;myvirfunc(); //执行Derive的myvirfunc(); ---  Derive::myvirfunc()</span><br><span class="line">pbase-&gt;myvirfunc(); //pbase动态类型是Derive，而虚函数是动态绑定，参照是它的动态类型；---  Derive::myvirfunc()</span><br><span class="line">                       //缺省value参数打印出来的居然是1：Derive::myvirfunc(),value = 1</span><br><span class="line">                       //这就始于函数参数缺省值的静态绑定，所以缺省参数绑定到了父类函数的缺省参数上去了</span><br><span class="line"></span><br><span class="line">Base &amp;yinbase = derive; //引用，效果和指针一样</span><br><span class="line">yinbase.myvirfunc();    //Derive::myvirfunc(),value = 1</span><br><span class="line">           </span><br><span class="line">pbase = &amp;base;   </span><br><span class="line">pbase-&gt;myvirfunc(); //----Base::myvirfunc(); Base::myvirfunc(),value = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　虚函数是动态绑定,换句话说，myvirfunc()是虚函数，这里到底执行哪个myvivfunc()取决于调用者的动态类型。<br>　　这里pbase的动态类型分别Derive，Base，所以调用的也分别是Derive和Base的myvirfunc()，pderive的动态类型是Derive，所以调用的是Derive的myvirfunc()。<br>　　从上面代码中可以看出，虚函数的参数缺省值是静态绑定，所以不要重新定义虚函数的缺省参数的值。</p><h2 id="c-中的多态性的体现"><a href="#c-中的多态性的体现" class="headerlink" title="c++中的多态性的体现"></a>c++中的多态性的体现</h2><p>　　多态性这个概念，分两方面谈：<br>　　a)从代码实现上<br>　　b)从表现形式上<br>　　有一个观点是肯定的：多态，必须是存在虚函数，没有虚函数，绝不可能存在多态，有虚函数并且调用虚函数。<br>　　（1）从代码实现上来看，当我们调用一个虚函数时，走的是不是通过查询虚函数表来找到虚函数入口地址，然后去执行虚函数，如果走的是这个途径，那就是多态，如果不走这个途径，它就不是多态。看代码分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void myvirfunc() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A *pa = new A();</span><br><span class="line">pa-&gt;myvirfunc(); //是多态</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">a.myvirfunc(); //这个就不是多态</span><br><span class="line"></span><br><span class="line">A *pa1 = &amp;a;</span><br><span class="line">pa1-&gt;myvirfunc(); //这个也是多态</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　（2）从表现形式上来看(通过代码来体现)<br>　　a)有继承关系，有父类有子类，父类中必须有虚函数(这意味着子类中一定有虚函数)，子类重写父类的虚函数。<br>　　b)父类指针或者引用指向子类对象。<br>　　c)当以父类指针或者引用调用子类中重写了的虚函数时，我们就能看出来多态的表现了，因为调用的是子类的虚函数。<br>　　代码分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void myvirfunc()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Base::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Derive :public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void myvirfunc()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Derive::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">　　Derive derive;</span><br><span class="line">Base *pbase = &amp;derive;</span><br><span class="line">pbase-&gt;myvirfunc(); //多态实现</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、多继承下的第二基类问题探讨"><a href="#四、多继承下的第二基类问题探讨" class="headerlink" title="四、多继承下的第二基类问题探讨"></a>四、多继承下的第二基类问题探讨</h1><p>　　先给出一个继承关系，稍后做具体分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void f() &#123; cout &lt;&lt; &quot;Base::f()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void g() &#123; cout &lt;&lt; &quot;Base::g()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void h() &#123; cout &lt;&lt; &quot;Base::h()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">virtual ~Base() &#123;</span><br><span class="line">int abc;</span><br><span class="line">abc = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void hBase2() &#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;Base2::hBase2()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual ~Base2()&#123;</span><br><span class="line">int abc;</span><br><span class="line">abc = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derive :public Base,public Base2 &#123;</span><br><span class="line">public:</span><br><span class="line">virtual void i() &#123; cout &lt;&lt; &quot;Derive::i()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void g() &#123; cout &lt;&lt; &quot;Derive::g()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">void myselffunc() &#123;&#125; //只属于Derive的函数</span><br><span class="line"></span><br><span class="line">virtual ~Derive() &#123;</span><br><span class="line">int abc;</span><br><span class="line">abc = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　多重继承的复杂性往往体现在后边这个基类上，先来看使用后面这个基类的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base2 *pb2 = new Derive();</span><br><span class="line">//编译器视角</span><br><span class="line">Derive *temp = new Derive();</span><br><span class="line">Base2 *pb2 = (Base2 *)((char *)temp + sizeof(Base));</span><br><span class="line">delete pb2;</span><br></pre></td></tr></table></figure><p>　　现在，我们考虑如何成功删除用第二基类指针new出来的继承类对象。注意，我们要删除的实际是整个Derive()对象，要能够保证Derive()对象的析构函数被正常调用，那么编译器会调用Base2的析构函数，还是调用Derive的析构函数呢？执行delte pb2时，系统的动作会是什么？<br>　　事实上，这里分为以下几种情况：<br>　　（1）如果Base2里没有析构函数,编译器会直接删除以pb2开头的这段内存，一定报异常，因为这段内存压根就不是new起始的内存。<br>　　（2）如果Base2里有一个析构函数，但整个析构函数是个普通析构函数（非虚析构函数），那么当delte pb2，这个析构函数就会被系统调用,但是delete的仍旧是pb2开头这段内存，所以一定报异常。因为这段内存压根就不是new起始的内存。（析构函数如果不是虚函数，编译器会实施静态绑定，静态绑定意味着你delete Base2指针时，删除的内存开始地址就是pb2的当前位置，所以肯定是错误的）。<br>　　（3）如果Base2里是一个虚析构函数，则delete的时候，编译器会自动按～Dervice() –&gt; ～Base2() –&gt; ～Base()的顺序调用，此时就是把整个Derive()对象的内存都释放了。<br>　　（4）Derive里就就算没有虚析构函数，因为Base2里有虚析构函数，编译器也会为此给Derive生成虚析构函数，为了调用～Base2()和～Base()虚析构函数。<br>　　由上述结论知，凡是涉及到继承的，所有类都加上虚析构函数，以防异常。<br>　　另外，Derive类的第二个虚函数表中发现了thunk字样，一般它用在多重继承中（从第二个虚函数表开始可能就 会有），用于this指针调整。它其实是一段汇编代码，这段代码干两个事情：<br>　　(1)调整this指针（this指针调整的目的就是让对象指针正确的指向对象首地址，从而能正确的调用对象的成员函数或者说正确确定数据成员的存储位置）<br>　　(2)调用Derive析构函数</p><h1 id="五、虚基类带虚函数的成员分布以及继承开销"><a href="#五、虚基类带虚函数的成员分布以及继承开销" class="headerlink" title="五、虚基类带虚函数的成员分布以及继承开销"></a>五、虚基类带虚函数的成员分布以及继承开销</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void f() &#123;&#125;</span><br><span class="line">virtual ~Base() &#123;&#125;</span><br><span class="line">int m_basei;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derive :public virtual Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual ~Derive()&#123;&#125;</span><br><span class="line">int m_derivei;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sizeof(Derive) &lt;&lt; endl;  //  16</span><br><span class="line">Derive dobj;</span><br><span class="line">dobj.m_basei = 2;      //  13-16字节</span><br><span class="line">dobj.m_derivei = 5;    //  5-8字节</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　由此可以看出，此种情况下的数据分布应该是：虚基类表指针（1-4字节）、子类数据成员（5-8字节）、虚函数表指针（9-12字节）、基类数据成员（13-16字节）。<br>　　一般来说，<br>　　（1）随着继承深度的增加，开销或者说执行时间也会增加。<br>　　（2）多重继承一般也会导致开销增加。<br>　　（3）虚函数也会导致开销增加。</p><h1 id="六、指向成员函数的指针以及vcall探讨"><a href="#六、指向成员函数的指针以及vcall探讨" class="headerlink" title="六、指向成员函数的指针以及vcall探讨"></a>六、指向成员函数的指针以及vcall探讨</h1><h2 id="指向普通成员函数的指针"><a href="#指向普通成员函数的指针" class="headerlink" title="指向普通成员函数的指针"></a>指向普通成员函数的指针</h2><p>　　成员函数地址是在编译时就确定好的。但是，要想调用成员函数，是需要通过对象来调用的。所有常规（非静态）成员函数，要想调用，都需要一个对象来调用它。并且，通过成员函数指针对常规的成员函数调用的成本，和通过普通的函数指针来调用静态成员函数，成本上差不多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void myfunc1(int tempvalue1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;tempvalue1 = &quot; &lt;&lt; tempvalue1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void myfunc2(int tempvalue2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;tempvalue2 = &quot; &lt;&lt; tempvalue2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void mysfunc(int tempvalue)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;A::mysfunc()静态成员函数--tempvalue = &quot; &lt;&lt; tempvalue &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A mya;</span><br><span class="line">void (A::*pmypoint)(int tempvalue) = &amp;A::myfunc1; //定义一个成员函数指针并给初值</span><br><span class="line">pmypoint = &amp;A::myfunc2; //给成员函数指针赋值</span><br><span class="line"></span><br><span class="line">(mya.*pmypoint)(15); //通过成员函数指针来调用成员函数，必须要通过对象的介入才能调用</span><br><span class="line"></span><br><span class="line">A *pmya = new A();</span><br><span class="line">(pmya-&gt;*pmypoint)(20); //用对象指针介入来使用成员函数指针来调用成员函数</span><br><span class="line"></span><br><span class="line">//编译器视角</span><br><span class="line">//pmypoint(&amp;mya, 15);</span><br><span class="line">//pmypoint(pmya, 20);</span><br><span class="line"></span><br><span class="line">void(*pmyspoint)(int tempvalue) = &amp;A::mysfunc; //一个普通的函数指针，而不是成员函数指针</span><br><span class="line">pmyspoint(80);</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指向虚成员函数的指针及vcall理解"><a href="#指向虚成员函数的指针及vcall理解" class="headerlink" title="指向虚成员函数的指针及vcall理解"></a>指向虚成员函数的指针及vcall理解</h2><p>　　vcall(vcall trunk) = virtual call：虚调用。它代表一段要执行的代码的地址，这段代码引导编译器去执行正确的虚函数，或者我们直接把vcall看成虚函数表，如果这么看待的话，那么vcall{0}代表的就是虚函数表里的第一个函数，vcall{4}就代表虚函数表里的第二个虚函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void myfunc1(int tempvalue1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;tempvalue1 = &quot; &lt;&lt; tempvalue1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void myfunc2(int tempvalue2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;tempvalue2 = &quot; &lt;&lt; tempvalue2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void mysfunc(int tempvalue)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;A::mysfunc()静态成员函数--tempvalue = &quot; &lt;&lt; tempvalue &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual void myvirfuncPrev(int tempvalue)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;A::myvirfuncPrev()虚成员函数--tempvalue = &quot; &lt;&lt; tempvalue &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual void myvirfunc(int tempvalue)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;A::myvirfunc()虚成员函数--tempvalue = &quot; &lt;&lt; tempvalue &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">void (A::*pmyvirfunc)(int tempvalue) = &amp;A::myvirfunc; //成员函数指针  -- vcall(vcall trunk)地址（虚函数）</span><br><span class="line"></span><br><span class="line">A *pvaobj = new A;</span><br><span class="line">pvaobj-&gt;myvirfunc(190);</span><br><span class="line">(pvaobj-&gt;*pmyvirfunc)(190);</span><br><span class="line">printf(&quot;%p\n&quot;, &amp;A::myvirfunc);</span><br><span class="line"></span><br><span class="line">pmyvirfunc = &amp;A::myfunc2;  //真正的成员函数地址</span><br><span class="line">(pvaobj-&gt;*pmyvirfunc)(33);</span><br><span class="line"></span><br><span class="line">delete pvaobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　完善理解：&amp;A::myvirfunc,打印出来的是一个地址，这个地址中有一段代码，这个代码中记录的是该虚函数在虚函数表中的一个偏移值，有了这个偏移值，再有了具体的对象指针，我们就能够知道调用的是哪个虚函数表里边的哪个虚函数了。<br>　　成员函数指针里，保存的可能是一个vcall(vcall trunk)地址（如果指针指向的是虚函数）,要么也可能是一个真正的成员函数地址（指针指向的不是虚函数）。如果是一个vcall地址，那vcall能够引导编译器找出正确的虚函数表中的虚函数地址进行调用。</p><h1 id="七、inline函数介绍及其扩展细节"><a href="#七、inline函数介绍及其扩展细节" class="headerlink" title="七、inline函数介绍及其扩展细节"></a>七、inline函数介绍及其扩展细节</h1><h2 id="inline函数介绍"><a href="#inline函数介绍" class="headerlink" title="inline函数介绍"></a>inline函数介绍</h2><p>　　使用inline之后，编译器内部会有一个比较复杂的测试算法来评估这个inline函数的复杂度,可能会统计这个inline函数中，赋值次数，内部函数调用，虚函数调用等次数（权重）。<br>　　（1）开发者写inline只是对编译器的一个建议，但如果编译器评估这个inline函数复杂度过高，这个inline建议就被编译器忽略。<br>　　（2）如果inline被编译器采纳，那么inline函数的扩展，就要在调用这个inline函数的那个点上进行，此时可能带来额外的问题比如：参数求值，可能导致临时对象的生成和管理。</p><h2 id="inline扩展细节"><a href="#inline扩展细节" class="headerlink" title="inline扩展细节"></a>inline扩展细节</h2><p>　　见代码的注释部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">inline int myfunc(int testv)</span><br><span class="line">&#123;</span><br><span class="line">return testv * (5 + 4) * testv;</span><br><span class="line">&#125;</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">int i = myfunc(12 + 15);  //编译器会先求值，然后用实参再替换形参</span><br><span class="line">int a = 80;</span><br><span class="line">int i = myfunc(a + 15); //编译器会先计算a和15的和值，然后再替换掉形参</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">_nmsp1::func();</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、普通成员函数调用方式&quot;&gt;&lt;a href=&quot;#一、普通成员函数调用方式&quot; class=&quot;headerlink&quot; title=&quot;一、普通成员函数调用方式&quot;&gt;&lt;/a&gt;一、普通成员函数调用方式&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://liuruijie87.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++对象模型" scheme="https://liuruijie87.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>STL源码剖析（4）</title>
    <link href="https://liuruijie87.github.io/2019/08/10/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/"/>
    <id>https://liuruijie87.github.io/2019/08/10/STL源码剖析读书笔记（4）/</id>
    <published>2019-08-10T04:36:28.186Z</published>
    <updated>2019-08-10T07:07:30.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>　　前一篇博文介绍了<strong>序列式容器</strong>，接下来介绍<strong>关联式容器</strong>。</p><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>　　所谓关联式容器，即每个元素都有一个键值（key）和一个实值（value）。当元素被插入到关联式容器中时，容器的内部结构便按照其键值大小，以某种特定规则将这个元素放置于适当位置。关联式容器没有头尾（只有最大元素和最小元素），所以不会有push_back(), push_front(), pop_back(), pop_front(), begin(), end()这些操作行为。<br>　　STL中的关联式容器分为set和map两大类，以及这两大类的衍生体multiset和multimap。这些容器的底层实现机制都是红黑树。红黑树也是一个独立的容器，但是并不开放给外界使用。此外，SGI STL还提供了一个不在标准规格之列的关联式容器：hashtable,以及以hashtable为底层机制的hash_set,hash_map,hash_multiset,hash_multimap。</p><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>　　（1）set里面元素的键值就是实值，实值就是键值，所有元素都会根据元素的键值自动被排序，并且set不允许两个元素有相同的键值。<br>　　（2）我们不能通过set的迭代器改变set的元素值，因为set的元素值就是其键值，关系到set元素的排列规则，如果任意改变set的元素值，会破坏set组织。因此，set<t>::iterator 被定义为const_iterator，杜绝写入操作。<br>　　（3）set拥有与list相同的某些性质：当用户对它进行元素新增或删除操作时，操作之前的所有迭代器（除了被删除元素的迭代器）在操作之后都依然有效。<br>　　（4）set是以红黑树为底层机制，因为红黑树是一种平衡二叉搜索树，自动排序效果不错。而且对于set所开放的各种接口操作，红黑树也都提供了，所以几乎所有的set操作行为，都只是调用红黑树的操作行为而已。</t></p><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>　　（1）map的所有元素都是pair，同时拥有实值（value）和键值（key）。pair的第一元素被视为键值，第二元素被视为实值。它的所有元素都会根据元素的键值自动被排序，并且map不允许两个元素拥有相同的键值。<br>　　（2）我们不能通过map的迭代器改变map里元素的键值，因为键值关系到map元素的排列规则，任意改变map元素键值将会严重破坏map组织，但是可以改变元素的实值，因为map元素的实值并不影响map元素的排列规则。<br>　　（3）map拥有与list相同的某些性质：当用户对它进行元素新增或删除操作时，操作之前的所有迭代器（除了被删除元素的迭代器）在操作之后都依然有效。<br>　　（4）map也是以红黑树为底层机制，因为红黑树是一种平衡二叉搜索树，自动排序效果不错。而且对于map所开放的各种接口操作，红黑树也都提供了，所以几乎所有的map操作行为，都只是调用红黑树的操作行为而已。</p><h1 id="multiset和multimap"><a href="#multiset和multimap" class="headerlink" title="multiset和multimap"></a>multiset和multimap</h1><p>　　（1）multiset的特性以及用法和set完全相同，唯一的差别在于它允许键值重复，因此它的插入操作采用的是底层机制红黑树的insert_equal()而非insert_unique()。<br>　　（2）multimap的特性以及用法和map完全相同，唯一的差别在于它允许键值重复，因此它的插入操作采用的是底层机制红黑树的insert_equal()而非insert_unique()。</p><h1 id="hash-set"><a href="#hash-set" class="headerlink" title="hash_set"></a>hash_set</h1><p>　　（1）hash_set以hashtable为底层机制，由于hash_set所提供的操作接口，hashtable都提供了，所以几乎所有的hash_set操作行为都只是转调用hashtable的操作行为而已。<br>　　（2）红黑树有自动排序功能，而hashtable没有，反映到表层就是，set的元素有自动排序功能而hash_set没有。<br>　　（3）hash_set跟set一样，元素的键值就是实值，实值就是键值。</p><h1 id="hash-map"><a href="#hash-map" class="headerlink" title="hash_map"></a>hash_map</h1><p>　　（1）hash_map也是以hashtable为底层机制，由于hash_map所提供的操作接口，hashtable都提供了，所以几乎所有的hash_map操作行为都只是转调用hashtable的操作行为而已。<br>　　（2）红黑树有自动排序功能，而hashtable没有，反映到表层就是，map的元素有自动排序功能而hash_map没有。<br>　　（3）hash_map跟map一样，每一个元素同时拥有一个实值和一个键值。</p><h1 id="hash-multiset和hash-multimap"><a href="#hash-multiset和hash-multimap" class="headerlink" title="hash_multiset和hash_multimap"></a>hash_multiset和hash_multimap</h1><p>　　（1）hash_multiset的特性与multiset完全相同，唯一差别就在于它的底层机制是hashtable。因此，hash_multiset的元素不会自动排序。<br>　　（2）hash_multiset和hash_set实现上的唯一差别在于，前者的元素插入操作采用底层机制hashtable的insert_equal(),后者则是采用insert_unique()。<br>　　（3）hash_multimap的特性与multimap完全相同，唯一差别就在于它的底层机制是hashtable。因此，hash_multimap的元素不会自动排序。<br>　　（4）hash_multimap和hash_map实现上的唯一差别在于，前者的元素插入操作采用底层机制hashtable的insert_equal(),后者则是采用insert_unique()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;　　前一篇博文介绍了&lt;strong&gt;序列式容器&lt;/strong&gt;，接下来介绍&lt;strong&gt;关联式容器&lt;/s
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://liuruijie87.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="STL" scheme="https://liuruijie87.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++对象模型（3） -- 数据语义学</title>
    <link href="https://liuruijie87.github.io/2019/08/09/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%883%EF%BC%89/"/>
    <id>https://liuruijie87.github.io/2019/08/09/C++对象模型（3）/</id>
    <published>2019-08-09T00:15:26.726Z</published>
    <updated>2019-08-09T10:14:30.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、数据成员绑定时机"><a href="#一、数据成员绑定时机" class="headerlink" title="一、数据成员绑定时机"></a>一、数据成员绑定时机</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef string mytype;</span><br><span class="line">//定义一个类</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void myfunc(mytype tmpvalue) //mytype = string</span><br><span class="line">&#123;</span><br><span class="line">m_value = tmpvalue; //出错，是把一个string类型给一个整型</span><br><span class="line">&#125;</span><br><span class="line">typedef int mytype;</span><br><span class="line">private:</span><br><span class="line">mytype m_value; //int</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　（1）编译器对成员函数的解析，是整个类定义完毕后才开始的。因为只有整个类定义完毕后，编译器才能看到类中的成员变量，才能根据实际的需要把出现该成员变量的场合做适当的解释（成员函数中解析成类中的变量类型，全局函数中解析成全局的变量类型）。<br>　　（2）对于成员函数参数，是在编译器第一次遇到整个类型mytype的时候被决定的。所以，mytype第一次遇到的时候，编译器只看到了typedef string mytype，没有看到类中的typedef int mytype。<br>　　（3）为了在类中尽早的看到类型mytype，所以这种类型定义语句typedef，一定要挪到类的最开头定义。（即上述代码中应该把typedef int mytype移到class A的开头处）当后边的成员函数第一次遇到这个类型mytype的时候，它就本着最近碰到的类型的原则来应用最近碰到的类型。</p><h1 id="二、进程内存空间布局"><a href="#二、进程内存空间布局" class="headerlink" title="二、进程内存空间布局"></a>二、进程内存空间布局</h1><p>　　不同的数据在内存中会有不同的保存时机，保存位置。当运行一个可执行文件时，操作系统就会把这个可执行文件加载到内存，此时进程有一个虚拟的地址空间（内存空间），分为：堆栈段、数据段、代码段等。从下面代码中可以看出些许规律。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">int *ptest = new int(120);</span><br><span class="line">int g1;</span><br><span class="line">int g2;</span><br><span class="line">int g3 = 12;</span><br><span class="line">int g4 = 32;</span><br><span class="line">int g5;</span><br><span class="line">int g6 = 0;</span><br><span class="line">static int g7;</span><br><span class="line">static int g8=0;</span><br><span class="line">static int g9 = 10;</span><br><span class="line">void mygfunc()</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//定义一个类</span><br><span class="line">class MYACLS</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_i;</span><br><span class="line">static int m_si; //声明不是定义</span><br><span class="line">int m_j;</span><br><span class="line">static int m_sj;</span><br><span class="line">int m_k;</span><br><span class="line">static int m_sk;</span><br><span class="line">//static void myclsfunc() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int MYACLS::m_sj = 0; //这才是定义；</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i = 7;;</span><br><span class="line">printf(&quot;i地址=%p\n&quot;, &amp;i); //i地址=00AFFB94</span><br><span class="line"></span><br><span class="line">printf(&quot;ptest地址=%p\n&quot;, &amp;ptest); //ptest地址=00F9B300</span><br><span class="line">printf(&quot;g1地址=%p\n&quot;, &amp;g1);       //g1地址=00F9B2EC</span><br><span class="line">printf(&quot;g2地址=%p\n&quot;, &amp;g2);       //g2地址=00F9B2F0</span><br><span class="line">printf(&quot;g3地址=%p\n&quot;, &amp;g3);       //g3地址=00F9B000</span><br><span class="line">printf(&quot;g4地址=%p\n&quot;, &amp;g4);       //g4地址=00F9B004</span><br><span class="line">printf(&quot;g5地址=%p\n&quot;, &amp;g5);       //g5地址=00F9B2F4</span><br><span class="line">printf(&quot;g6地址=%p\n&quot;, &amp;g6);       //g6地址=00F9B2F8</span><br><span class="line">printf(&quot;g7地址=%p\n&quot;, &amp;g7);       //g7地址=00F9B304</span><br><span class="line">printf(&quot;g8地址=%p\n&quot;, &amp;g8);       //g8地址=00F9B308</span><br><span class="line">printf(&quot;g9地址=%p\n&quot;, &amp;g9);       //g9地址=00F9B008</span><br><span class="line">printf(&quot;MYACLS::m_sj地址=%p\n&quot;, &amp;(MYACLS::m_sj)); //MYACLS::m_sj地址=00F9B2FC</span><br><span class="line"></span><br><span class="line">printf(&quot;mygfunc()地址=%p\n&quot;, mygfunc); //mygfunc()地址=00F91433</span><br><span class="line">printf(&quot;main()地址=%p\n&quot;, main); //main()地址=00F9132A</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (void*)mygfunc &lt;&lt; endl; //00F91433</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　从上述代码的打印结果来看，不同类型的数据在内存中的存储位置是不同的，同一类型的数据是连续存储的。</p><h1 id="三、类中成员变量的布局"><a href="#三、类中成员变量的布局" class="headerlink" title="三、类中成员变量的布局"></a>三、类中成员变量的布局</h1><p>　　（1）普通成员变量的存储顺序是按照在类中的定义顺序从上到下来的。比较晚出现的成员变量在内存中有更高的地址。类定义中pubic,private,protected的数量，不影响类对象的sizeof。<br>　　（2）某些因素会导致成员变量之间排列不连续，就是边界调整（字节对齐），调整的目的是提高效率，编译器自动调整。调整方式：往成员之间填补一些字节，使用类对象的sizoef字节数凑成一个4的整数倍，8的整数倍。<br>　　（3）为了统一字节对齐问题，引入一个概念叫一字节对齐(不对齐)：#pragma pack(1)。把这个语句放到程序最开始处即可。<br>　　（4）有虚函数时，编译器往类定义中增加vptr虚函数表指针（内部的数据成员）。<br>　　（5）成员变量偏移值，就是这个成员变量的地址，离对象首地址偏移多少。</p><h1 id="四、类中成员变量的存取"><a href="#四、类中成员变量的存取" class="headerlink" title="四、类中成员变量的存取"></a>四、类中成员变量的存取</h1><p>　　（1）静态成员变量，可以当做一个全局量，但是它只在类的空间内可见。引用时用类名::静态成员变量名。静态成员变量只有一个实体，保存在可执行文件的数据段。<br>　　（2）非静态成员变量（普通的成员变量）存放在类的对象中。存取通过类对象（类对象指针）来操作。例如：对于普通成员的访问，编译器是把类对象的首地址加上成员变量的偏移值。</p><h1 id="五、单一继承下的数据成员布局"><a href="#五、单一继承下的数据成员布局" class="headerlink" title="五、单一继承下的数据成员布局"></a>五、单一继承下的数据成员布局</h1><p>　　（1）一个子类对象，所包含的内容，是他自己的成员，加上他父类的成员的总和。从偏移值看，父类成员先出现，然后才是孩子类成员。<br>　　（2）引入继承关系后，可能会带来内存空间的额外增加（字节对齐）。所以不能用memcpy内存拷贝把父类对象的内容直接往子类对象里拷贝。</p><h1 id="六、带有虚函数的类中数据成员布局"><a href="#六、带有虚函数的类中数据成员布局" class="headerlink" title="六、带有虚函数的类中数据成员布局"></a>六、带有虚函数的类中数据成员布局</h1><h2 id="单个类带虚函数的数据成员布局"><a href="#单个类带虚函数的数据成员布局" class="headerlink" title="单个类带虚函数的数据成员布局"></a>单个类带虚函数的数据成员布局</h2><p>　　类中引入虚函数时，会有额外的成本付出：<br>　　1)编译的时候，编译器会产生虚函数表。<br>　　2)对象中会产生虚函数表指针vptr，用以指向虚函数表。<br>　　3)增加或者扩展构造函数，增加给虚函数表指针vptr赋值的代码，让vptr指向虚函数表。<br>　　4)如果多重继承，比如你继承了2个父类，每个父类都有虚函数的话，每个父类都会有vptr，那继承时，子类就会把这两根vptr都继承过来，如果子类还有自己额外的虚函数的话，子类与第一个基类共用一个vptr。<br>　　5)析构函数中也被扩展增加了虚函数表指针vptr相关的赋值代码，这个赋值代码似乎和构造函数中代码相同。</p><h2 id="单一继承父类带虚函数的数据成员布局"><a href="#单一继承父类带虚函数的数据成员布局" class="headerlink" title="单一继承父类带虚函数的数据成员布局"></a>单一继承父类带虚函数的数据成员布局</h2><p>　　代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_bi;</span><br><span class="line">virtual void mybvirfunc() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class MYACLS :public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_i;</span><br><span class="line">int m_j;</span><br><span class="line">MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int abc = 1; //方便加断点</span><br><span class="line">&#125;</span><br><span class="line">~MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int def = 0;//方便加断点</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl;  //16</span><br><span class="line">printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi);  //MYACLS::m_bi = 4</span><br><span class="line">printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i);    //MYACLS::m_i = 8</span><br><span class="line">printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j);    //MYACLS::m_j = 12</span><br><span class="line"></span><br><span class="line">MYACLS myobj;</span><br><span class="line">myobj.m_i = 3;</span><br><span class="line">myobj.m_j = 6;</span><br><span class="line">myobj.m_bi = 9;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　从打印结果可以看出，当父类中有虚函数的时候，指向父类虚函数表的虚函数表指针会占用内存开头的四个字节，紧接着是父类的成员变量，最后才是子类的成员变量。</p><h2 id="单一继承父类不带虚函数的数据成员布局"><a href="#单一继承父类不带虚函数的数据成员布局" class="headerlink" title="单一继承父类不带虚函数的数据成员布局"></a>单一继承父类不带虚函数的数据成员布局</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_bi;</span><br><span class="line">&#125;;</span><br><span class="line">class MYACLS :public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_i;</span><br><span class="line">int m_j;</span><br><span class="line">MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int abc = 1; //方便加断点</span><br><span class="line">&#125;</span><br><span class="line">~MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int def = 0;//方便加断点</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl;  //12</span><br><span class="line">printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi);  //MYACLS::m_bi = 0</span><br><span class="line">printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i);    //MYACLS::m_i = 4</span><br><span class="line">printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j);    //MYACLS::m_j = 8</span><br><span class="line"></span><br><span class="line">MYACLS myobj;</span><br><span class="line">myobj.m_i = 3;</span><br><span class="line">myobj.m_j = 6;</span><br><span class="line">myobj.m_bi = 9;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　从打印结果可以看出，如果父类中没有虚函数，则父类的成员变量就放到了内存开头处，之后是子类的成员变量。<br>　　但是如果子类中有虚函数而父类中没有，内存布局又会发生变化，即数据在内存空间中的分布分别是：父类成员、子类的虚函数表指针、子类成员。代码及打印结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_bi;</span><br><span class="line">&#125;;</span><br><span class="line">class MYACLS :public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_i;</span><br><span class="line">int m_j;</span><br><span class="line">virtual void myvirfunc() &#123;&#125;</span><br><span class="line">MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int abc = 1; //方便加断点</span><br><span class="line">&#125;</span><br><span class="line">~MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int def = 0;//方便加断点</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl;  //16</span><br><span class="line">printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi);  //MYACLS::m_bi = 0</span><br><span class="line">printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i);    //MYACLS::m_i = 8</span><br><span class="line">printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j);    //MYACLS::m_j = 12</span><br><span class="line"></span><br><span class="line">MYACLS myobj;</span><br><span class="line">myobj.m_i = 3;</span><br><span class="line">myobj.m_j = 6;</span><br><span class="line">myobj.m_bi = 9;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　如果子类和父类中都有虚函数，则子类和父类共用一个虚函数表指针，即它俩的地址一样，都在内存的开头处，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_bi;</span><br><span class="line">virtual void mybvirfunc() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class MYACLS :public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_i;</span><br><span class="line">int m_j;</span><br><span class="line">virtual void myvirfunc() &#123;&#125;</span><br><span class="line">MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int abc = 1; //方便加断点</span><br><span class="line">&#125;</span><br><span class="line">~MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int def = 0;//方便加断点</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl;  //16</span><br><span class="line">printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi);  //MYACLS::m_bi = 4</span><br><span class="line">printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i);    //MYACLS::m_i = 8</span><br><span class="line">printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j);    //MYACLS::m_j = 12</span><br><span class="line"></span><br><span class="line">MYACLS myobj;</span><br><span class="line">myobj.m_i = 3;</span><br><span class="line">myobj.m_j = 6;</span><br><span class="line">myobj.m_bi = 9;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　总结：不管是父类还是子类，只要含有虚函数，则虚函数指针就位于对应的所有数据成员的前面（父类指针对应父类成员，子类指针对应子类成员），如果父类和子类都含有虚函数，则它俩的虚函数表指针共用一块内存，位于内存空间的开头处。</p><h2 id="多重继承且父类都带虚函数的数据成员布局"><a href="#多重继承且父类都带虚函数的数据成员布局" class="headerlink" title="多重继承且父类都带虚函数的数据成员布局"></a>多重继承且父类都带虚函数的数据成员布局</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class Base1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_bi;</span><br><span class="line">virtual void mybvirfunc() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Base1()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Base1::Base1()的this指针是：%p!\n&quot;, this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_b2i;</span><br><span class="line">virtual void mybvirfunc2() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Base2()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Base2::Base2()的this指针是：%p!\n&quot;, this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class MYACLS :public Base1,public Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_i;</span><br><span class="line">int m_j;</span><br><span class="line"></span><br><span class="line">virtual void myvirfunc() &#123;&#125; //虚函数</span><br><span class="line">MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int abc = 1; //方便加断点</span><br><span class="line">printf(&quot;MYACLS::MYACLS()的this指针是：%p!\n&quot;, this);</span><br><span class="line">&#125;</span><br><span class="line">~MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int def = 0;//方便加断点</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl;                  //24</span><br><span class="line">printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi);    //MYACLS::m_bi = 4</span><br><span class="line">printf(&quot;MYACLS::m_b2i = %d\n&quot;, &amp;MYACLS::m_b2i);  //MYACLS::m_b2i = 4</span><br><span class="line">printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i);      //MYACLS::m_i = 16</span><br><span class="line">printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j);      //MYACLS::m_j = 20</span><br><span class="line"></span><br><span class="line">MYACLS myobj;       //Base1::Base1()的this指针是：004FFC24!</span><br><span class="line">                        //Base2::Base2()的this指针是：004FFC2C!</span><br><span class="line">                        //MYACLS::MYACLS()的this指针是：004FFC24!</span><br><span class="line">myobj.m_i = 3;</span><br><span class="line">myobj.m_j = 6;</span><br><span class="line">myobj.m_bi = 9;</span><br><span class="line">myobj.m_b2i = 12;</span><br><span class="line"></span><br><span class="line">MYACLS *pmyobj = new MYACLS();   //Base1::Base1()的this指针是：008F11D8!</span><br><span class="line">                                     //Base2::Base2()的this指针是：008F11E0!</span><br><span class="line">                                     //MYACLS::MYACLS()的this指针是：008F11D8!</span><br><span class="line">pmyobj-&gt;m_i = 3;</span><br><span class="line">pmyobj-&gt;m_j = 6;</span><br><span class="line">pmyobj-&gt;m_bi = 9;</span><br><span class="line">pmyobj-&gt;m_b2i = 12;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　（1）通过this指针打印，我们看到访问Base1成员不用跳 ，访问Base2成员要this指针要偏移（跳过）8字节。<br>　　（2）我们看到偏移值，m_bi和m_b2i偏移都是4。<br>　　（3）this指针，加上偏移值就的能够访问对应的成员变量，比如m_b2i = this指针+偏移值。<br>　　结论：我们要访问一个类对象中的成员，成员的定位是通过：this指针（编译器会自动调整）以及该成员的偏移值，这两个因素来定义。这种this指针偏移的调整都需要编译器介入来处理完成。</p><h2 id="虚基类相关"><a href="#虚基类相关" class="headerlink" title="虚基类相关"></a>虚基类相关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Grand //爷爷类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">&#125;;</span><br><span class="line">class A1 : virtual public Grand</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A2 : virtual public Grand</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C1 :public A1, public A2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_c1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; sizeof(Grand) &lt;&lt; endl;  // 1</span><br><span class="line">cout &lt;&lt; sizeof(A1) &lt;&lt; endl;     // 4</span><br><span class="line">cout &lt;&lt; sizeof(A2) &lt;&lt; endl;     // 4</span><br><span class="line">cout &lt;&lt; sizeof(C1) &lt;&lt; endl;     // 12</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　（1）虚基类就是让Grand类只被继承一次，防止二义性问题。<br>　　（2）有虚基类，就有虚基类表vbtable(virtual base table)、虚基类表指针vbptr(virtual base table pointer)。<br>　　（3）空类sizeof(Grand)=1好理解。虚继承之后，A1,A2里就会被编译器插入一个虚基类表指针，这个指针，有点成员变量的感觉。A1,A2里因为有了虚基类表指针，因此占用了4个字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Grand //爷爷类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_grand;</span><br><span class="line">&#125;;</span><br><span class="line">class A1 : virtual public Grand</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_a1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A2 : virtual public Grand</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_a2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C1 :public A1, public A2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_c1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; sizeof(Grand) &lt;&lt; endl;  // 1</span><br><span class="line">cout &lt;&lt; sizeof(A1) &lt;&lt; endl;     // 4</span><br><span class="line">cout &lt;&lt; sizeof(A2) &lt;&lt; endl;     // 4</span><br><span class="line">cout &lt;&lt; sizeof(C1) &lt;&lt; endl;     // 12</span><br><span class="line">//内存分布情况</span><br><span class="line">C1 c;</span><br><span class="line">c.m_grand = 2;   // 21-24字节</span><br><span class="line">c.m_a1 = 3;      // 5-8字节</span><br><span class="line">c.m_a2 = 4;      // 13-16字节</span><br><span class="line">c.m_c1 = 5;      // 17-20字节</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　根据内存分析可以看出：1-4字节和9-12字节应该存放的就是两个虚基类表指针，其中1-4字节是vbptr1（继承自A1），9-12字节是vbptr2（继承自A2）。其余的数据分布如上述程序中所示，需要注意的是：爷爷类里的成员分布在内存的最后。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Grand //爷爷类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_grand;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Grand2 //爷爷类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_grand2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A1 : virtual public Grand,virtual public Grand2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_a1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A2 : virtual public Grand</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_a2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C1 :public A1, public A2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_c1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sizeof(Grand) &lt;&lt; endl;   // 4</span><br><span class="line">cout &lt;&lt; sizeof(A1) &lt;&lt; endl;      // 16（3个int数据+1个虚基类表指针）</span><br><span class="line">cout &lt;&lt; sizeof(A2) &lt;&lt; endl;      // 12（2个int数据+1个虚基类表指针）</span><br><span class="line">cout &lt;&lt; sizeof(C1) &lt;&lt; endl;      // 28</span><br><span class="line"> //内存分布情况</span><br><span class="line">C1 c;</span><br><span class="line">c.m_a1 = 1;           // 5-8字节</span><br><span class="line">c.m_a2 = 2;           // 13-16字节</span><br><span class="line">c.m_c1 = 3;           // 17-20字节</span><br><span class="line">c.m_grand = 4;        // 21-24字节</span><br><span class="line">c.m_grand2 = 5;       // 25-28字节</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　由此，可以判断出，一个类同时虚继承多个父类，只会产生一个虚基类指针（A1）。1-4字节放的是A1的虚基类指针，9-12字节放的是A2的虚基类指针。其他的数据分布如程序所示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、数据成员绑定时机&quot;&gt;&lt;a href=&quot;#一、数据成员绑定时机&quot; class=&quot;headerlink&quot; title=&quot;一、数据成员绑定时机&quot;&gt;&lt;/a&gt;一、数据成员绑定时机&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://liuruijie87.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++对象模型" scheme="https://liuruijie87.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++对象模型（2） -- 虚函数</title>
    <link href="https://liuruijie87.github.io/2019/08/06/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%882)/"/>
    <id>https://liuruijie87.github.io/2019/08/06/C++对象模型（2)/</id>
    <published>2019-08-06T00:25:28.425Z</published>
    <updated>2019-08-06T02:19:52.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、虚函数表指针位置分析"><a href="#一、虚函数表指针位置分析" class="headerlink" title="一、虚函数表指针位置分析"></a>一、虚函数表指针位置分析</h1><p>　　一个类若有虚函数，这个类就会产生一个虚函数表。当类创建对象的时候，对象内就会维护一个虚函数表指针，该指针(vptr)会指向这个虚函数表的开始地址。接下来借助代码分析一下虚函数表指针的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int i; //4字节</span><br><span class="line">virtual void testfunc() &#123;&#125;  //虚函数，vptr4字节。</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A aobj;</span><br><span class="line">int ilen = sizeof(aobj);</span><br><span class="line">cout &lt;&lt; ilen &lt;&lt; endl;  //8字节</span><br><span class="line"></span><br><span class="line">char *p1 = reinterpret_cast&lt;char *&gt;(&amp;aobj); //类型转换，硬转 &amp;aobj这是对象aobj的首地址。</span><br><span class="line">char *p2 = reinterpret_cast&lt;char *&gt;(&amp;(aobj.i));</span><br><span class="line">if (p1 == p2) //说明aobj.i和aobj的位置相同，说明i在对象aobj内存布局的上边。虚函数表指针vptr在下边</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;虚函数表指针位于对象内存的末尾&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;虚函数表指针位于对象内存的开头&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　通过测试，我们发现虚函数表指针在对象内存的开头处。</p><h1 id="二、继承关系作用下虚函数的手工调用"><a href="#二、继承关系作用下虚函数的手工调用" class="headerlink" title="二、继承关系作用下虚函数的手工调用"></a>二、继承关系作用下虚函数的手工调用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">//父类</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void f() &#123; cout &lt;&lt; &quot;Base::f()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void g() &#123; cout &lt;&lt; &quot;Base::g()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void h() &#123; cout &lt;&lt; &quot;Base::h()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Derive :public Base </span><br><span class="line">&#123;</span><br><span class="line">virtual void g() &#123; cout &lt;&lt; &quot;Derive::g()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//</span><br><span class="line">cout &lt;&lt; sizeof(Base) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; sizeof(Derive) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Derive *d = new Derive(); //派生类指针。</span><br><span class="line">long *pvptr = (long *)d;  //指向对象的指针d转成了long *类型。</span><br><span class="line">long *vptr = (long *)(*pvptr); </span><br><span class="line">//(*pvptr)表示pvptr指向的对象，也就是Derive本身。Derive对象是4字节的，代表的是虚函数表指针地址。</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt;= 4; i++) //循环5次，打印出虚函数的地址。</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;vptr[%d] = 0x:%p\n&quot;, i, vptr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">　　//上述循环运行结果：</span><br><span class="line">　　//vptr[0] = 0x:00DF11A4</span><br><span class="line">　　//vptr[1] = 0x:00DF1320</span><br><span class="line">　　//vptr[2] = 0x:00DF1334</span><br><span class="line">　　//vptr[3] = 0x:00000000</span><br><span class="line">　　//vptr[4] = 0x:69726544</span><br><span class="line"></span><br><span class="line">typedef void(*Func)(void); //定义一个函数指针类型</span><br><span class="line">Func f = (Func)vptr[0]; //f就是函数指针变量，vptr[0]是指向第一个虚函数的。</span><br><span class="line">Func g = (Func)vptr[1];</span><br><span class="line">Func h = (Func)vptr[2];</span><br><span class="line">/*Func i = (Func)vptr[3];</span><br><span class="line">Func j = (Func)vptr[4];*/</span><br><span class="line"></span><br><span class="line">f();   //Base::f()</span><br><span class="line">g();   //Derive::g()</span><br><span class="line">h();   //Base::h()</span><br><span class="line">//i();</span><br><span class="line"></span><br><span class="line">Base *dpar = new Base();  //父类指针</span><br><span class="line">long *pvptrpar = (long *)dpar;</span><br><span class="line">long *vptrpar = (long *)(*pvptrpar);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt;= 4; i++) //循环5次；</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;vptr Base[%d] = 0x:%p\n&quot;, i, vptrpar[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">　　//上述循环运行结果：</span><br><span class="line">　　//vptr Base[0] = 0x:00DF11A4</span><br><span class="line">　　//vptr Base[1] = 0x:00DF117C</span><br><span class="line">　　//vptr Base[2] = 0x:00DF1334</span><br><span class="line">　　//vptr Base[3] = 0x:00000000</span><br><span class="line">　　//vptr Base[4] = 0x:65736142</span><br><span class="line"></span><br><span class="line">Func fpar = (Func)vptrpar[0];  </span><br><span class="line">Func gpar = (Func)vptrpar[1];  </span><br><span class="line">Func hpar = (Func)vptrpar[2];  </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;</span><br><span class="line">fpar(); //Base::f()</span><br><span class="line">gpar(); //Base::g()</span><br><span class="line">hpar(); //Base::h()</span><br><span class="line"></span><br><span class="line">return 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　从上面的运行结果来看（注释中已标出），对于子类对象来说，子类中要是有和父类同名的虚函数，则子类中的虚函数就会把父类中的同名虚函数覆盖，同时虚函数表中对应的虚函数地址必然会发生变化（变成子类中虚函数的地址）。但是如果是父类对象，则还是会调用父类中的虚函数（即不会被覆盖）。<br>　　接着看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef void(*Func)(void); //定义一个函数指针类型</span><br><span class="line"></span><br><span class="line">Derive derive;</span><br><span class="line">long *pvptrderive = (long *)(&amp;derive);  </span><br><span class="line">long *vptrderive = (long *)(*pvptrderive); //0x00b09b6c &#123;project100.exe!void(* Derive::`vftable&apos;[4])()&#125; &#123;11538847&#125;</span><br><span class="line">Func f1 = (Func)vptrderive[0]; //0x00b0119f &#123;project100.exe!Base::f(void)&#125;</span><br><span class="line">Func f2 = (Func)vptrderive[1]; //0x00b0150f &#123;project100.exe!Derive::g(void)&#125;</span><br><span class="line">Func f3 = (Func)vptrderive[2]; //0x00b01325 &#123;project100.exe!Base::h(void)&#125;</span><br><span class="line">Func f4 = (Func)vptrderive[3]; //0x69726544</span><br><span class="line">Func f5 = (Func)vptrderive[4]; //0x3a3a6576</span><br><span class="line"></span><br><span class="line">Derive derive2 = derive; //调用拷贝构造函数</span><br><span class="line">long *pvptrderive2 = (long *)(&amp;derive2);</span><br><span class="line">long *vptrderive2 = (long *)(*pvptrderive2);</span><br><span class="line"></span><br><span class="line">Base base = derive; //直接用子类对象给父类对象值，子类中的属于父类那部分内容会被编译器自动区分（切割）出来并拷贝给了父类对象。</span><br><span class="line">                            //所以Base base = derive;实际干了两个事情：</span><br><span class="line">                            //第一个事情：生成一个base对象</span><br><span class="line">                            //第二个事情：用derive来初始化base对象的值。</span><br><span class="line">long *pvptrbase = (long *)(&amp;base);</span><br><span class="line">long *vptrbase = (long *)(*pvptrbase); //0x00b09b34 &#123;project100.exe!void(* Base::`vftable&apos;[4])()&#125; &#123;11538847&#125;</span><br><span class="line">Func fb1 = (Func)vptrbase[0];   //0x00b0119f &#123;project100.exe!Base::f(void)&#125;</span><br><span class="line">Func fb2 = (Func)vptrbase[1];   //0x00b01177 &#123;project100.exe!Base::g(void)&#125;</span><br><span class="line">Func fb3 = (Func)vptrbase[2];   //0x00b01325 &#123;project100.exe!Base::h(void)&#125;</span><br><span class="line">Func fb4 = (Func)vptrbase[3];    //0x00000000</span><br><span class="line">Func fb5 = (Func)vptrbase[4];    //0x65736142</span><br></pre></td></tr></table></figure><p>　　可以看出，当用子类对象初始化父类对象的时候，编译器给咱们做了一个选择，显然derive的虚函数表指针值并没有覆盖base对象的虚函数表指针值。<br>　　总结：<br>　　（1）一个类只有包含虚函数才会存在虚函数表，同属于一个类的对象共享虚函数表，但是有各自的vptr（虚函数表指针），当然所指向的地址（虚函数表首地址）相同。<br>　　（2）父类中有虚函数就等于子类中有虚函数。话句话来说，父类中有虚函数表，则子类中肯定有虚函数表。因为你是继承父类的。并且只要在父类中是虚函数，那么子类中即便不写virtual，也依旧是虚函数。但如果子类只继承自一个父类，则不管是父类还是子类，它们内部都只会有一个虚函数表。<br>　　（3）如果子类中完全没有新的虚函数，则我们可以认为子类的虚函数表和父类的虚函数表内容相同。但，仅仅是内容相同，这两个虚函数表在内存中处于不同位置，换句话来说，这是内容相同的两张表。<br>　　（4）虚函数表中每一项，保存着一个虚函数的首地址，但如果子类的虚函数表某项和父类的虚函数表某项代表同一个函数（这表示子类没有覆盖父类的虚函数），则该表项所执行的该函数的地址应该相同。<br>　　（5）超出虚函数表部分的内容不可知。</p><h1 id="三、多重继承虚函数表分析"><a href="#三、多重继承虚函数表分析" class="headerlink" title="三、多重继承虚函数表分析"></a>三、多重继承虚函数表分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">//基类1</span><br><span class="line">class Base1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void f()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;base1::f()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void g()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;base1::g()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//基类2</span><br><span class="line">class Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void h()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;base2::h()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void i()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;base2::i()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//子类</span><br><span class="line">class Derived :public Base1, public Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void f() //覆盖父类1的虚函数</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;derived::f()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void i() //覆盖父类2的虚函数</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;derived::i()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如下三个我们自己的虚函数</span><br><span class="line">virtual void mh() </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;derived::mh()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual void mi()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;derived::mi()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual void mj()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;derived::mj()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sizeof(Base1) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; sizeof(Base2) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; sizeof(Derived) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Derived ins; </span><br><span class="line">Base1 &amp;b1 = ins; //多态</span><br><span class="line">Base2 &amp;b2 = ins;</span><br><span class="line">Derived &amp;d = ins;</span><br><span class="line"></span><br><span class="line">typedef void(*Func)(void);</span><br><span class="line">long *pderived1 = (long *)(&amp;ins);</span><br><span class="line">long *vptr1 = (long *)(*pderived1); //取第一个虚函数表指针。</span><br><span class="line"></span><br><span class="line">long *pderived2 = pderived1 + 1; //跳过4字。</span><br><span class="line">long *vptr2 = (long *)(*pderived2); //取第二个虚函数表指针。</span><br><span class="line"></span><br><span class="line">Func f1 = (Func)vptr1[0]; //0x00ab15d7 &#123;project100.exe!Derived::f(void)&#125;</span><br><span class="line">Func f2 = (Func)vptr1[1]; //0x00ab15f0 &#123;project100.exe!Base1::g(void)&#125;</span><br><span class="line">Func f3 = (Func)vptr1[2]; //0x00ab15cd &#123;project100.exe!Derived::mh(void)&#125;</span><br><span class="line">Func f4 = (Func)vptr1[3]; //0x00ab15ff &#123;project100.exe!Derived::mi(void)&#125;</span><br><span class="line">Func f5 = (Func)vptr1[4]; //0x00ab15eb &#123;project100.exe!Derived::mj(void)&#125;</span><br><span class="line">Func f6 = (Func)vptr1[5]; //非正常</span><br><span class="line">Func f7 = (Func)vptr1[6];</span><br><span class="line">Func f8 = (Func)vptr1[7];</span><br><span class="line"></span><br><span class="line">Func f11 = (Func)vptr2[0]; //0x00ab15af &#123;project100.exe!Base2::h(void)&#125;</span><br><span class="line">Func f22 = (Func)vptr2[1]; //0x00ab15b9 &#123;project100.exe!Derived::i(void)&#125;</span><br><span class="line">Func f33 = (Func)vptr2[2]; //非正常</span><br><span class="line">Func f44 = (Func)vptr2[3];</span><br><span class="line"></span><br><span class="line">b1.f();</span><br><span class="line">b2.i();</span><br><span class="line">d.f();</span><br><span class="line">d.i();</span><br><span class="line">d.mh();</span><br><span class="line">d.g();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;</span><br><span class="line">f1();</span><br><span class="line">f2();</span><br><span class="line">f3();</span><br><span class="line">f4();</span><br><span class="line">f5();</span><br><span class="line">cout &lt;&lt; &quot;-------------&quot; &lt;&lt; endl;</span><br><span class="line">f11();</span><br><span class="line">f22();</span><br><span class="line"></span><br><span class="line">return 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　（1）一个对象，如果它的类有多个基类则有多个虚函数表指针（注意是多个虚函数表指针，而不是多个虚函数表）。<br>　　（2）在多继承中，对应各个基类的vptr按继承顺序依次放置在类的内存空间中，且子类与第一个基类共用一个vptr(第二个基类有自己的vptr);<br>　　（3）如上程序中，子类对象ins有两个虚函数表指针，vptr1,vptr2。类Derived有两个虚函数表，因为它继承自两个基类。<br>　　（4）子类和第一个基类公用一个vptr（因为vptr指向一个虚函数表，所以也可以说子类和第一个基类共用一个虚函数表vtbl),因为我们注意到了类Derived的虚函数表1里边的5个函数，而g()正好是base1里边的函数。<br>　　（5）子类中的虚函数覆盖了父类中的同名虚函数。比如derived::f(),derived::i();</p><h1 id="四、vptr、vtbl创建时机"><a href="#四、vptr、vtbl创建时机" class="headerlink" title="四、vptr、vtbl创建时机"></a>四、vptr、vtbl创建时机</h1><p>　　（1）vptr（虚函数表指针）跟着对象走，所以对象什么时候创建出来，vptr就什么时候创建出来。即运行的时候。实际上，对于这种有虚函数的类，在编译的时候，编译器会往相关的构造函数中增加为vptr赋值的代码，这是在编译期间编译器为构造函数增加的。当程序运行的时候，遇到创建对象的代码，执行对象的构造函数，那么这个构造函数里有给对象的vptr(成员变量)赋值的语句，自然这个对象的vptr就被赋值了。<br>　　（2）虚函数表是编译器在编译期间（不是运行期间）就为每个类确定好了对应的虚函数表vtbl的内容。然后也是在编译期间在相应的类构造函数中添加给vptr赋值的代码，这样程序运行的时候，当运行到创建类对象的代码时，会调用类的构造函数，执行到类的构造函数中的给vptr赋值的代码，这样这个类对象的vptr(虚函数表指针)就有值了。</p><h1 id="五、普通类包含虚函数时引发的虚函数调用问题"><a href="#五、普通类包含虚函数时引发的虚函数调用问题" class="headerlink" title="五、普通类包含虚函数时引发的虚函数调用问题"></a>五、普通类包含虚函数时引发的虚函数调用问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">class X</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">int z;</span><br><span class="line">//X() :x(0), y(0), z(0)</span><br><span class="line">X()</span><br><span class="line">&#123;</span><br><span class="line">//编译器角度 伪码；</span><br><span class="line">//vptr = vtbl; //下边的memset会把vptr（虚函数表指针）清0</span><br><span class="line">memset(this, 0, sizeof(X));</span><br><span class="line">cout &lt;&lt; &quot;构造函数被执行&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//X(const X &amp;tm) :x(tm.x), y(tm.y), z(tm.z)</span><br><span class="line">X(const X &amp;tm)</span><br><span class="line">&#123;</span><br><span class="line">memcpy(this, &amp;tm, sizeof(X));</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数被执行&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual ~X()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数被执行&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void virfunc()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;虚函数virfunc()被执行&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void ptfunc()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;普通函数ptfunc()被执行&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//X x0;  //调用构造函数</span><br><span class="line">///*x0.x = 100;</span><br><span class="line">//x0.y = 200;</span><br><span class="line">//x0.z = 300;*/</span><br><span class="line">//x0.virfunc(); //虚函数表指针为null居然可以成功调用虚函数；</span><br><span class="line"></span><br><span class="line">//X x1(x0); //调用拷贝构造函数</span><br><span class="line">//cout &lt;&lt; &quot;x1.x=&quot; &lt;&lt; x1.x &lt;&lt; &quot; x1.y=&quot; &lt;&lt; x1.y &lt;&lt; &quot; x1.z=&quot; &lt;&lt; x1.z &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//X *px0 = new X();</span><br><span class="line">//px0-&gt;ptfunc(); //正常调用</span><br><span class="line">//px0-&gt;virfunc(); //无法正常调用</span><br><span class="line">//delete px0; //无法正常调用</span><br><span class="line">//new出来的对象，虚函数变得无法正常执行了；</span><br><span class="line"></span><br><span class="line">int i = 9;</span><br><span class="line">printf(&quot;i的地址 = %p\n&quot;, &amp;i);</span><br><span class="line">X x0;</span><br><span class="line">printf(&quot;ptfunc()的地址=%p\n&quot;, &amp;X::ptfunc); //打印正常的成员函数地址。</span><br><span class="line">//long *pvptrpar = (long *)(&amp;x0);</span><br><span class="line">//long *vptrpar = (long *)(*pvptrpar);</span><br><span class="line">//printf(&quot;virfunc的地址 = %p\n&quot;, vptrpar[1]);//虚函数virfunc地址</span><br><span class="line">x0.ptfunc();</span><br><span class="line">x0.virfunc(); //不叫多态，属于静态联编，我们推断：这个函数ptfunc()和virfunc()函数，是在编译的就确定好的；</span><br><span class="line"></span><br><span class="line">X *pX0 = new X();</span><br><span class="line">pX0-&gt;ptfunc();</span><br><span class="line">pX0-&gt;virfunc(); //通过虚函数表指针，找虚函数表，然后从虚函数表中找到virfunc虚函数的地址并调用。这就是多态</span><br><span class="line"></span><br><span class="line">//更明白：虚函数，多态，这种概念专门给指针或者引用用的；</span><br><span class="line">X &amp;xy = *pX0;</span><br><span class="line">xy.virfunc();</span><br><span class="line">X &amp;xy2 = x0;</span><br><span class="line">xy2.virfunc();</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　（1）如果一个普通类中包含了虚函数，那么在构造函数中使用如上所示的memset或者拷贝构造函数中使用如上所示的memcpy方法，那么就会出现程序崩溃的情形。<br>　　（2）某些情况下，编译器会往类内部增加一些我们看不见但真实存在的成员变量（隐藏成员变量），比如你类中增加了虚函数，系统默认往类对象中增加虚函数表指针，这个虚函数表指针就是隐藏的成员变量。有了这种变量的类，就不是普通的类了。同时，这种隐藏的成员变量的增加(使用)或者赋值的时机，往往都是在执行构造函数或者拷贝构造函数的函数体之前进行。那么你如果使用memset,memcpy，很可能把编译器给隐藏变量的值你就给清空了，要么覆盖了。<br>　　（3）静态联编是指：我们编译的时候就能确定调用哪个函数。把调用语句和被调用函数绑定到一起。动态联编是在程序运行时，根据时机情况，动态的把调用语句和被调用函数绑定到一起，动态联编一般旨有在多态和虚函数情况下才存在。<br>　　（4）对多态，虚函数，父类，子类。虚函数主要解决的问题父类指针指向子类对象这种情况。如果一个类中只有虚函数，没有继承，那么虚函数和普通函数没有区别，就算虚函数表指针被置空，仍然可通过对象正常调用，因为这是静态联编，不是多态。但是如果用new出来的对象调用，就会失败，因为虚函数表指针为空，找不到虚函数表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、虚函数表指针位置分析&quot;&gt;&lt;a href=&quot;#一、虚函数表指针位置分析&quot; class=&quot;headerlink&quot; title=&quot;一、虚函数表指针位置分析&quot;&gt;&lt;/a&gt;一、虚函数表指针位置分析&lt;/h1&gt;&lt;p&gt;　　一个类若有虚函数，这个类就会产生一个虚函数表。当类创建对
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://liuruijie87.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++对象模型" scheme="https://liuruijie87.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++对象模型（1） -- 对象</title>
    <link href="https://liuruijie87.github.io/2019/08/04/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%881%EF%BC%89/"/>
    <id>https://liuruijie87.github.io/2019/08/04/C++对象模型（1）/</id>
    <published>2019-08-04T00:05:24.676Z</published>
    <updated>2019-08-04T04:37:43.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、类对象所占用的空间"><a href="#一、类对象所占用的空间" class="headerlink" title="一、类对象所占用的空间"></a>一、类对象所占用的空间</h1><p>　　（1）一个空类所占用空间是一个字节，如果有成员变量，就是成员变量占用的内存。为什么空类还要占一个字节的内存？这是因为创建了一个对象就要占用一个字节的地址，就像买房子一样，空房子也是占面积的。<br>　　（2）类的成员函数不占用类对象的内存空间，而成员变量占用对象的内存空间。<br>　　（3）成员变量是包含在每个对象中的，是占用对象字节的，有多少个对象就有多少个成员变量。而对于成员函数，每个类只诞生一个（跟着类走），而不管你用这个类产生了多少个该类的对象。</p><h1 id="二、对象结构的发展和演化"><a href="#二、对象结构的发展和演化" class="headerlink" title="二、对象结构的发展和演化"></a>二、对象结构的发展和演化</h1><p>　　（1）非静态的成员变量(普通成员变量)跟着类对象走（存在对象内部），也就是每个类对象都有自己的成员变量。<br>　　（2）静态成员变量跟对象没有什么关系，所以肯定不会保存在对象内部，是保存在对象外面（表示所占用的内存空间和类对象无关）的，所以不计算在类对象sizeof()内。<br>　　（3）成员函数：不管静态的还是非静态，全部都保存在类对象之外。所以不管几个成员函数，不管是否是静态的成员函数，对象的sizeof的大小都是不增加的。<br>　　（4）虚函数：不管有几个虚函数，sizeof()都是多了4个字节。类里只要有一个虚函数（或者说至少有一个虚函数），这个类就会产生一个指向虚函数的指针。有两个虚函数，那么这个类就会产生两个指向虚函数的指针。而类本身指向虚函数的指针（一个或者一堆）要有地方存放，存放在一个表格里，这个表格我们就称为“虚函数表(virtual table【vtbl】)”。这个虚函数表一般是保存在可执行文件中的，在程序执行的时候载入到内存中来。<br>　　（5）虚函数表是基于类的，跟着类走的。对于类对象，这四个字节的增加，其实是因为虚函数的存在；因为有了虚函数的存在，导致系统往类对象中添加了一个指针，这个指针正好指向这个虚函数表，很多资料上把这个指针叫vptr；这个vptr的值由系统在适当的时机赋值（比如构造函数中通过增加额外的代码来给值）。<br>　　（6）如果有多个数据成员，那么为了提高访问速度，某些编译器可能会将数据成员之间的内存占用比例进行调整(内存字节对齐)。<br>　　（7）不管什么类型指针char *p,int *q;,该指针占用的内存大小是固定的。</p><h1 id="三、this指针调整：多重继承"><a href="#三、this指针调整：多重继承" class="headerlink" title="三、this指针调整：多重继承"></a>三、this指针调整：多重继承</h1><p>　　（1）派生类对象是包含基类子对象的。<br>　　（2）如果派生类只从一个基类继承的话，那么这个派生类对象的地址和基类子对象的地址相同。<br>　　（3）如果派生类对象同时继承多个基类，那么就要注意：第一个基类子对象的开始地址和派生类对象的开始地址相同。后续这些基类子对象的开始地址和派生类对象的开始地址相差多少呢？那就得把前边那些基类子对象所占用的内存空间累加。<br>　　（4）调用哪个子类的成员函数，这个this指针就会被编译器自动调整到对象内存布局中对应该子类对象的起始地址那去。</p><h1 id="四、构造函数语义"><a href="#四、构造函数语义" class="headerlink" title="四、构造函数语义"></a>四、构造函数语义</h1><p>　　传统认识认为：如果我们自己没定义任何构造函数，那么编译器就会为我们隐式自动定义一个默认的构造函数，我们称这种构造函数为：“合成的默认构造函数”。<br>　　事实是：“合成的默认构造函数”，只有在必要的时候，编译器才会为我们合成出来，而不是必然或者必须为我们合成出来。那么编译器会在哪些必要的时候帮助我们把默认的构造函数合成出来呢？<br>　　（1）该类没有任何构造函数，但包含一个类类型的成员,而该对象所属于的类有一个缺省的构造函数。这个时候，编译器就会为该类生成一个 “合成默认的构造函数”，合成的目的是为了调用类类型成员所属类里的默认构造函数。<br>　　（2）父类带缺省构造函数，子类没有任何构造函数，那因为父类这个缺省的构造函数要被调用，所以编译器会为这个子类合成出一个默认构造函数。合成的目的是为了调用这个父类的构造函数。换句话说，编译器合成了默认的构造函数，并在其中安插代码，调用其父类的默认构造函数。<br>　　（3）如果一个类含有虚函数，但没有任何构造函数时，因为虚函数的存在，编译器会给我们生成一个基于该类的虚函数表vftable。此外编译器给我们合成了一个构造函数，调用了父类的构造函数，并且在其中安插代码，把类的虚函数表地址赋给类对象的虚函数表指针（赋值语句/代码）。我们可以把虚函数表指针看成是我们表面上看不见的一个类的成员函数。<br>　　（4）当我们有自己的默认构造函数时，编译器会根据需要扩充我们自己写的构造函数代码，比如调用父类构造函数，给对象的虚函数表指针赋值。<br>　　（5）如果一个类带有虚基类，编译器也会为它合成一个默认构造函数。虚基类：通过两个直接基类（虚基类）继承同一个间接基类。所以一般是三层 ，有爷爷Grand，有两个爹A,A2，有孙子C。有虚基类结构，编译器为子类和父类都产生了“合成的默认构造函数”。</p><h1 id="五、拷贝构造函数语义"><a href="#五、拷贝构造函数语义" class="headerlink" title="五、拷贝构造函数语义"></a>五、拷贝构造函数语义</h1><p>　　传统上，大家认为：如果我们没有定义一个自己的拷贝构造函数，编译器会帮助我们合成 一个拷贝构造函数。<br>　　事实上，这个合成的拷贝构造函数，也是在必要的时候才会被编译器合成出来。那编译器在什么情况下会帮助我们合成出拷贝构造函数来呢？这个编译器合成出来的拷贝构造函数又要干什么事情呢？<br>　　（1）如果一个类A没有拷贝构造函数，但是含有一个类类型CTB的成员变量m_ctb。该类型CTB含有拷贝构造函数，那么当代码中有涉及到类A的拷贝构造时，编译器就会为类A合成一个拷贝构造函数。编译器合成的拷贝构造函数往往都是干一些特殊的事情。如果只是一些类成员变量值的拷贝这些事，编译器是不用专门合成出拷贝构造函数来干的，编译器内部就干了，即成员变量初始化手法，比如int这种简单类型，直接就按值拷贝过去,编译器不需要合成拷贝构造函数的情况下就帮助我们把这个事情办了。再如类A中有类类型ASon成员变量asubobj，也会递归似的去拷贝类ASon的每个成员变量。<br>　　（2）如果一个类CTBSon没有拷贝构造函数，但是它有一个父类CTB，父类有拷贝构造函数，当代码中有涉及到类CTBSon的拷贝构造时，编译器会为CTBSon合成一个拷贝构造函数，调用父类的拷贝构造函数。<br>　　（3）如果一个类CTBSon没有拷贝构造函数，但是该类声明了或者继承了虚函数，当代码中有涉及到类CTBSon的拷贝构造时，编译器会为CTBSon合成一个拷贝构造函数 ,往这个拷贝构造函数里插入语句。这个语句的含义是设定类对象的虚函数表指针值。<br>　　（4）如果一个类没有拷贝构造函数，但是该类含有虚基类，当代码中有涉及到类的拷贝构造时，编译器会为该类合成一个拷贝构造函数。</p><h1 id="六、程序转化语义"><a href="#六、程序转化语义" class="headerlink" title="六、程序转化语义"></a>六、程序转化语义</h1><p>　　程序转化语义主要是理解编译器如何将人类写的代码解析成编译器理解的代码。为此，从两个角度来分析。下面的代码帮助更好的理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class X</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_i;</span><br><span class="line">X(const X &amp;tmpx)</span><br><span class="line">&#123;</span><br><span class="line">m_i = tmpx.m_i;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数被调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">X()</span><br><span class="line">&#123;</span><br><span class="line">m_i = 0;</span><br><span class="line">cout &lt;&lt; &quot;构造函数被调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~X()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数被调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void functest()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;functest()被调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//参数初始化对比</span><br><span class="line">//人类角度</span><br><span class="line">void func(X tmpx)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//老编译器看func(老编译器角度)</span><br><span class="line">void func(X &amp;tmpx)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//返回值初始化对比</span><br><span class="line">//人类视角</span><br><span class="line">X func()</span><br><span class="line">&#123;</span><br><span class="line">X x0;</span><br><span class="line">//....</span><br><span class="line">return x0;   //系统产生临时对象并把x0的内容拷贝构造给了临时对象。</span><br><span class="line">&#125;</span><br><span class="line">//编译器角度的func</span><br><span class="line">void func(X &amp;extra)</span><br><span class="line">&#123;</span><br><span class="line">X x0; //从编译器角度，这行不调用X的构造函数</span><br><span class="line">//...</span><br><span class="line">//...</span><br><span class="line">extra.X::X(x0);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　我们写的代码，编译器会对代码进行拆分，拆分成编译器更容易理解和实现的代码。看一看编译器是如何解析这些代码的。<br>　　（1）定义时初始化对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//程序员视角</span><br><span class="line">X x0;</span><br><span class="line">x0.m_i = 15;</span><br><span class="line">X x1 = x0; </span><br><span class="line">X x2(x0);</span><br><span class="line">X x3 = (x0);</span><br><span class="line"></span><br><span class="line">//切换到编译器角度，编译器会拆分成两个步骤(编译器视角)</span><br><span class="line">X x100;           //步骤一：定义一个对象，为对象分配内存。从编译器视角来看，这句是不调用X类的构造函数。</span><br><span class="line">x100.X::X(x0);    //步骤二：直接调用对象的拷贝构造函数去了；</span><br></pre></td></tr></table></figure><p>　　（2）参数的初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//程序员视角/现代编译器</span><br><span class="line">func(x0);</span><br><span class="line"></span><br><span class="line">//老编译器视角</span><br><span class="line">X tmpobj; //编译器产生一个临时对象</span><br><span class="line">tmpobj.X::X(x0); //调用拷贝构造函数</span><br><span class="line">func(tmpobj); //用临时对象调用func</span><br><span class="line">tmpobj.X::~X(); //func()被调用完成后，本析构被调用。</span><br></pre></td></tr></table></figure><p>　　（3）返回值初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//程序员角度</span><br><span class="line">X my = func();</span><br><span class="line"></span><br><span class="line">//编译器对上述代码的理解(编译器角度)</span><br><span class="line">X my; //不会调用X的构造函数</span><br><span class="line">func(my);</span><br><span class="line"></span><br><span class="line">//利用返回值调用成员函数</span><br><span class="line">//人类视角</span><br><span class="line">func().functest();</span><br><span class="line"></span><br><span class="line">//切换到编译器视角</span><br><span class="line">X my; //不会调用X的构造函数</span><br><span class="line">(func(my), my).functest(); //逗号表达式：先计算表达式1，再计算表达式2，整个逗号表达式的结果是表达式2的值；</span><br><span class="line"></span><br><span class="line">//利用函数指针调用成员函数</span><br><span class="line">//程序员视角</span><br><span class="line">X(*pf)(); //定义个函数指针</span><br><span class="line">pf = func;</span><br><span class="line">pf().functest();</span><br><span class="line"></span><br><span class="line">//编译器视角</span><br><span class="line">X my; //不调用构造函数</span><br><span class="line">void (*pf)(X &amp;);</span><br><span class="line">pf = func;</span><br><span class="line">pf(my);</span><br><span class="line">my.functest();</span><br></pre></td></tr></table></figure><h1 id="七、拷贝构造续与深浅拷贝"><a href="#七、拷贝构造续与深浅拷贝" class="headerlink" title="七、拷贝构造续与深浅拷贝"></a>七、拷贝构造续与深浅拷贝</h1><p>　　（1）当编译器面临用一个类对象作为另外一个类对象初值的情况，各个编译器表现不同。但是所有编译器都为了提高效率而努力。我们也没有办法确定我们自己使用的编译器是否一定会调用拷贝构造函数。<br>　　（2）拷贝构造函数不是必须有的，如果只有一些简单的成员变量类型，int,double，你会发现你根本不需要拷贝构造函数，编译器内部本身就支持成员变量的bitwise(按位)copy，即按位拷贝。<br>　　（3）当需要处理很复杂的成员变量类型的时候。因为我们增加了自己的拷贝构造函数，导致编译器本身的bitwise拷贝能力失效，它会调用我们自己的拷贝构造函数，因此如果你增加了自己的拷贝构造函数后，就要对各个成员变量的值的初始化负责了。<br>　　（4）我们自己创建内存，把目标对象的内存内容拷贝过来，叫深拷贝，例如下面的程序。相反，上述编译器做的拷贝叫浅拷贝。（<strong>注意：</strong>涉及到指针的时候，必须用深拷贝，不能浅拷贝，否则指针所指的内存会被析构两次，导致错误）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class X</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_i;</span><br><span class="line">int *p_mi;</span><br><span class="line">X(const X&amp; tmpx)</span><br><span class="line">&#123;</span><br><span class="line">p_mi = new int(100); //自己申请内存</span><br><span class="line">memcpy(p_mi, tmpx.p_mi, sizeof(int)); //拷贝</span><br><span class="line">m_i = tmpx.m_i;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数被调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="八、初始化列表"><a href="#八、初始化列表" class="headerlink" title="八、初始化列表"></a>八、初始化列表</h1><p>　　（1）必须使用初始化列表的情况<br>　　　　（a）这个成员是个引用<br>　　　　（b）是个const类型成员<br>　　　　（c）如果这个类是继承一个基类，并且基类中有构造函数，这个构造函数里边还有参数。<br>　　　　（d）如果成员变量类型是某个类类型，而这个类的构造函数带参数时。<br>　　（2）使用初始化列表的优势。除了必须用初始化列表的场合，我们用初始化列表还有什么其他目的？ 有，就是提高程序运行效率。对于类类型成员变量放到初始化列表中能够比较明显的看到效率的提升，但是如果是个简单类型的成员变量比如int m_test,其实放在初始化列表或者放在函数体里效率差别不大。（<strong>提醒：</strong>成员变量初始化尽量放在初始化列表里，显得高端，大气上档次）<br>　　（3）初始化列表中的代码可以看作是被编译器安插到构造函数体中的，只是这些代码有些特殊。这些代码是在任何用户自己的构造函数体代码之前被执行的。所以要区分开构造函数中的<strong>用户代码</strong>和<strong>编译器插入的初始化所属的代码</strong>。<br>　　（4）初始化列表中变量的初始化顺序是变量的定义顺序，而不是在初始化列表中的顺序。不建议在初始化列表中进行两个都在初始化列表中出现的成员之间的初始化（例如：m1和m2都在初始化列表中，不建议用m1来初始化m2，或用m2初始化m1）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、类对象所占用的空间&quot;&gt;&lt;a href=&quot;#一、类对象所占用的空间&quot; class=&quot;headerlink&quot; title=&quot;一、类对象所占用的空间&quot;&gt;&lt;/a&gt;一、类对象所占用的空间&lt;/h1&gt;&lt;p&gt;　　（1）一个空类所占用空间是一个字节，如果有成员变量，就是成员变量
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://liuruijie87.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++对象模型" scheme="https://liuruijie87.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>STL源码剖析（3）</title>
    <link href="https://liuruijie87.github.io/2019/07/30/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/"/>
    <id>https://liuruijie87.github.io/2019/07/30/STL源码剖析读书笔记（3）/</id>
    <published>2019-07-30T00:58:40.224Z</published>
    <updated>2020-01-12T09:22:47.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>　　前一篇博文介绍了<strong>迭代器</strong>，接下来介绍一下STL的大部头–<strong>容器</strong>。这一篇首先介绍<strong>序列式容器</strong>。</p><h1 id="容器概览与分类"><a href="#容器概览与分类" class="headerlink" title="容器概览与分类"></a>容器概览与分类</h1><p>　　STL的容器是将运用最广的一些数据结构实现出来。众所周知，常用的数据结构不外乎 array, list, tree, stack, queue, hash table, set, map 等。根据数据在容器中的排列特性，这些数据结构分为序列式和关联式两种，因此容器也分为序列式容器和关联式容器。序列式容器有：array, vector, heap, priority-queue, list, slist, deque, stack, queue。关联式容器有：rb-tree, set, map, multiset, multimap, hashtable, hash-set, hash-map, hash-multiset, hash_multimap。<br>　　其中，heap是以vector为底层来实现的，priority-queue又是以heap为底层实现。而stack和queue都是以deque为原型通过配接器配接而来。关联式容器中的 set map multiset multimap 都是以 rb-tree 为底层实现, hash-set hash-map hash-multiset hash_multimap又都是以 hashtable 为底层实现。<br>　　需要注意的是，序列式容器都可序，但未必有序。接下来分别介绍各容器。</p><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h2 id="vector概述"><a href="#vector概述" class="headerlink" title="vector概述"></a>vector概述</h2><p>　　vector 的数据安排以及操作方式与 array 非常相似。两者唯一的差别在于空间的运用的灵活性。array 是静态空间，一旦配置了就不能改变，要换一个大（小）一点的空间，首先得配置一块新空间，然后从旧址一一搬往新址，再把原来的空间释放。vector 是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。因此使用 vector，我们再也不必因为害怕空间不足而一开始就要求一个大块头 array 了。</p><h2 id="vector的迭代器"><a href="#vector的迭代器" class="headerlink" title="vector的迭代器"></a>vector的迭代器</h2><p>　　vector 维护的是一个连续的线性空间，所以不论其元素型别为何，普通指针都可以作为 vector 的迭代器而满足所有必要条件。因此 vector 的迭代器是普通指针。vector 支持随机存取，而普通指针也正有这样的能力，所以 vector 提供的是 random access iterators。</p><h2 id="vector的数据结构"><a href="#vector的数据结构" class="headerlink" title="vector的数据结构"></a>vector的数据结构</h2><p>　　vector的数据结构比较简单，是线性连续空间。它内部维护有三个迭代器（指针）：start表示目前使用空间的头，finish表示目前使用空间的尾，end_of_storage表示目前可用空间的尾。<br>　　当我们以push_back()将新元素插入于vector尾端时，该函数首先检查是否还有备用空间，如果有就直接在备用空间上构造元素，并调整迭代器 finish，使 vector 变大。如果没有备用空间了，就扩充空间，即动态增加大小，这并不是在原空间之后接续新空间（因为无法保证原空间之后有可供配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对 vector 的任何操作，一旦引起空间重新配置，指向原 vector 的所有迭代器就都失效了。</p><h2 id="vector的erase-first-last-操作"><a href="#vector的erase-first-last-操作" class="headerlink" title="vector的erase(first, last)操作"></a>vector的erase(first, last)操作</h2><p>　　首先将last至finsh之间的元素拷贝到first开始处，然后释放拷贝内容中最后一个元素的下一个内存单元至finsh的内存，再将finsh调整为：finsh=finsh-(last-first)。　　</p><h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><h2 id="list概述"><a href="#list概述" class="headerlink" title="list概述"></a>list概述</h2><p>　　list是一个链表，是由一个一个节点组成的，每一个节点结构内部有两个指针，分别指向前一个节点和后一个节点，还有一个数据域来存放节点数据。list的好处是每次插入或删除一个元素，就配置或释放一个元素空间。因此，list对空间的利用率很高，一点也不浪费。而且，对于任何位置的元素插入或元素移除，list永远是常数时间。</p><h2 id="list的迭代器"><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h2><p>　　list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在存储空间中连续存在。list迭代器必须有能力指向list的节点，并且有能力进行正确的递增、递减、取值、成员存取等操作。也就是说，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取用的是节点的成员。<br>　　由于STL的list是一个双向链表。迭代器必须具备前移、后移的能力，所以list提供的是bidirectional iterators。list在插入和接合操作的时候都不会造成原有的list迭代器失效，在删除操作的时候只有指向被删元素的那个迭代器失效，其他迭代器不受任何影响。</p><h2 id="list的数据结构"><a href="#list的数据结构" class="headerlink" title="list的数据结构"></a>list的数据结构</h2><p>　　list不仅是一个双向链表，而且还是一个环状双向链表，所以它只需要一个指针，便可完整表现整个链表。如果让该指针（注意：此指针并非前面所说的节点内部的指针，这里的指针是指向每个节点的指针）指向刻意置于尾端的一个空白节点，便能符合STL对于“前闭后开”区间的要求，成为list迭代器。list作为双向链表，在头部和尾部都可以插入数据。</p><h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><h2 id="deque概述"><a href="#deque概述" class="headerlink" title="deque概述"></a>deque概述</h2><p>　　deque是一种双向开口的连续线性空间。所谓双向开口，意思就是可以在头尾两端分别做元素的插入和删除操作。deque和vector的不同主要有三点：（1）vector是单向开口的空间，虽然也能在头部插入元素，但是效率极差，而deque可以在常数时间内对头部进行插入或移除操作。（2）deque没有容量的概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。而vector是因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间。（3）deque的迭代器不是普通指针，因为它的实际空间并不是连续的，而vector的迭代器和普通指针一样。<br>　　deque表面上看起来是连续空间，其实它内部是将一段一段连续空间通过中控器的操作接合起来，一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，使人们使用起来感觉像是在操作一段连续空间。它还提供了随机存取接口，避免了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器结构。<br>　　deque采用一块所谓的map作为主控，这里的map其实是一小块连续空间，其中每个元素都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的存储空间主体。通过看源码，可以发现map其实是一个指针，所指之物又是一个指针，指向另一块空间。</p><h2 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h2><p>　　deque的迭代器首先必须能够指出缓冲区在哪里，其次它必须能够判断自己是否已经处于所在缓冲区的边缘，如果是，一旦前进或后退时就必须跳跃至下一个或上一个缓冲区。因此，deque的迭代器应该包括四个指针：cur指向该迭代器所指缓冲区中的当前元素，first指向该迭代器所指缓冲区的头部，last指向该迭代器所指缓冲区的尾部，node指向管控中心，用来找到迭代器所指的缓冲区。</p><h2 id="deque的数据结构"><a href="#deque的数据结构" class="headerlink" title="deque的数据结构"></a>deque的数据结构</h2><p>　　deque除了维护一个先前说过的指向map的指针外，也维护start,finish两个迭代器，分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素的下一位置。此外，它当然也必须记住目前的map大小。因为一旦map所提供的节点不足，就必须重新配置更大的一块map。</p><h1 id="stack和queue"><a href="#stack和queue" class="headerlink" title="stack和queue"></a>stack和queue</h1><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>　　stack是一种先进后出的数据结构，它只有一个出口。stack允许新增元素、移除元素、取得顶端元素。但除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不允许有遍历行为。STL中以deque作为缺省情况下的stack底部结构。<br>　　stack所有元素的进出都必须符合先进后出的条件，只有stack顶端的元素，才有机会被外界取用。stack不提供走访功能，也不提供迭代器。另外，除了deque外，list也可以作为stack的底部容器。</p><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>　　queue是一种先进先出的数据结构。他有两个出口，允许新增元素、移除元素、从最底端加入元素、取得最顶端的元素。但是除了最底端加入、最顶端取出外，没有其他任何办法可以存取queue的其他元素。即queue不允许有遍历行为，queue也没有迭代器。STL默认将deque作为queue的底部容器，当然list也可以作为queue的底部容器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;　　前一篇博文介绍了&lt;strong&gt;迭代器&lt;/strong&gt;，接下来介绍一下STL的大部头–&lt;strong&gt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://liuruijie87.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="STL" scheme="https://liuruijie87.github.io/tags/STL/"/>
    
  </entry>
  
</feed>
