<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuruijie</title>
  
  <subtitle>快乐搬砖，码出未来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liuruijie87.github.io/"/>
  <updated>2019-08-09T10:14:30.388Z</updated>
  <id>https://liuruijie87.github.io/</id>
  
  <author>
    <name>liuruijie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++对象模型（3） -- 数据语义学</title>
    <link href="https://liuruijie87.github.io/2019/08/09/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%883%EF%BC%89/"/>
    <id>https://liuruijie87.github.io/2019/08/09/C-对象模型（3）/</id>
    <published>2019-08-09T00:15:26.726Z</published>
    <updated>2019-08-09T10:14:30.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、数据成员绑定时机"><a href="#一、数据成员绑定时机" class="headerlink" title="一、数据成员绑定时机"></a>一、数据成员绑定时机</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef string mytype;</span><br><span class="line">//定义一个类</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void myfunc(mytype tmpvalue) //mytype = string</span><br><span class="line">&#123;</span><br><span class="line">m_value = tmpvalue; //出错，是把一个string类型给一个整型</span><br><span class="line">&#125;</span><br><span class="line">typedef int mytype;</span><br><span class="line">private:</span><br><span class="line">mytype m_value; //int</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　（1）编译器对成员函数的解析，是整个类定义完毕后才开始的。因为只有整个类定义完毕后，编译器才能看到类中的成员变量，才能根据实际的需要把出现该成员变量的场合做适当的解释（成员函数中解析成类中的变量类型，全局函数中解析成全局的变量类型）。<br>　　（2）对于成员函数参数，是在编译器第一次遇到整个类型mytype的时候被决定的。所以，mytype第一次遇到的时候，编译器只看到了typedef string mytype，没有看到类中的typedef int mytype。<br>　　（3）为了在类中尽早的看到类型mytype，所以这种类型定义语句typedef，一定要挪到类的最开头定义。（即上述代码中应该把typedef int mytype移到class A的开头处）当后边的成员函数第一次遇到这个类型mytype的时候，它就本着最近碰到的类型的原则来应用最近碰到的类型。</p><h1 id="二、进程内存空间布局"><a href="#二、进程内存空间布局" class="headerlink" title="二、进程内存空间布局"></a>二、进程内存空间布局</h1><p>　　不同的数据在内存中会有不同的保存时机，保存位置。当运行一个可执行文件时，操作系统就会把这个可执行文件加载到内存，此时进程有一个虚拟的地址空间（内存空间），分为：堆栈段、数据段、代码段等。从下面代码中可以看出些许规律。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">int *ptest = new int(120);</span><br><span class="line">int g1;</span><br><span class="line">int g2;</span><br><span class="line">int g3 = 12;</span><br><span class="line">int g4 = 32;</span><br><span class="line">int g5;</span><br><span class="line">int g6 = 0;</span><br><span class="line">static int g7;</span><br><span class="line">static int g8=0;</span><br><span class="line">static int g9 = 10;</span><br><span class="line">void mygfunc()</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//定义一个类</span><br><span class="line">class MYACLS</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_i;</span><br><span class="line">static int m_si; //声明不是定义</span><br><span class="line">int m_j;</span><br><span class="line">static int m_sj;</span><br><span class="line">int m_k;</span><br><span class="line">static int m_sk;</span><br><span class="line">//static void myclsfunc() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int MYACLS::m_sj = 0; //这才是定义；</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i = 7;;</span><br><span class="line">printf(&quot;i地址=%p\n&quot;, &amp;i); //i地址=00AFFB94</span><br><span class="line"></span><br><span class="line">printf(&quot;ptest地址=%p\n&quot;, &amp;ptest); //ptest地址=00F9B300</span><br><span class="line">printf(&quot;g1地址=%p\n&quot;, &amp;g1);       //g1地址=00F9B2EC</span><br><span class="line">printf(&quot;g2地址=%p\n&quot;, &amp;g2);       //g2地址=00F9B2F0</span><br><span class="line">printf(&quot;g3地址=%p\n&quot;, &amp;g3);       //g3地址=00F9B000</span><br><span class="line">printf(&quot;g4地址=%p\n&quot;, &amp;g4);       //g4地址=00F9B004</span><br><span class="line">printf(&quot;g5地址=%p\n&quot;, &amp;g5);       //g5地址=00F9B2F4</span><br><span class="line">printf(&quot;g6地址=%p\n&quot;, &amp;g6);       //g6地址=00F9B2F8</span><br><span class="line">printf(&quot;g7地址=%p\n&quot;, &amp;g7);       //g7地址=00F9B304</span><br><span class="line">printf(&quot;g8地址=%p\n&quot;, &amp;g8);       //g8地址=00F9B308</span><br><span class="line">printf(&quot;g9地址=%p\n&quot;, &amp;g9);       //g9地址=00F9B008</span><br><span class="line">printf(&quot;MYACLS::m_sj地址=%p\n&quot;, &amp;(MYACLS::m_sj)); //MYACLS::m_sj地址=00F9B2FC</span><br><span class="line"></span><br><span class="line">printf(&quot;mygfunc()地址=%p\n&quot;, mygfunc); //mygfunc()地址=00F91433</span><br><span class="line">printf(&quot;main()地址=%p\n&quot;, main); //main()地址=00F9132A</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (void*)mygfunc &lt;&lt; endl; //00F91433</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　从上述代码的打印结果来看，不同类型的数据在内存中的存储位置是不同的，同一类型的数据是连续存储的。</p><h1 id="三、类中成员变量的布局"><a href="#三、类中成员变量的布局" class="headerlink" title="三、类中成员变量的布局"></a>三、类中成员变量的布局</h1><p>　　（1）普通成员变量的存储顺序是按照在类中的定义顺序从上到下来的。比较晚出现的成员变量在内存中有更高的地址。类定义中pubic,private,protected的数量，不影响类对象的sizeof。<br>　　（2）某些因素会导致成员变量之间排列不连续，就是边界调整（字节对齐），调整的目的是提高效率，编译器自动调整。调整方式：往成员之间填补一些字节，使用类对象的sizoef字节数凑成一个4的整数倍，8的整数倍。<br>　　（3）为了统一字节对齐问题，引入一个概念叫一字节对齐(不对齐)：#pragma pack(1)。把这个语句放到程序最开始处即可。<br>　　（4）有虚函数时，编译器往类定义中增加vptr虚函数表指针（内部的数据成员）。<br>　　（5）成员变量偏移值，就是这个成员变量的地址，离对象首地址偏移多少。</p><h1 id="四、类中成员变量的存取"><a href="#四、类中成员变量的存取" class="headerlink" title="四、类中成员变量的存取"></a>四、类中成员变量的存取</h1><p>　　（1）静态成员变量，可以当做一个全局量，但是它只在类的空间内可见。引用时用类名::静态成员变量名。静态成员变量只有一个实体，保存在可执行文件的数据段。<br>　　（2）非静态成员变量（普通的成员变量）存放在类的对象中。存取通过类对象（类对象指针）来操作。例如：对于普通成员的访问，编译器是把类对象的首地址加上成员变量的偏移值。</p><h1 id="五、单一继承下的数据成员布局"><a href="#五、单一继承下的数据成员布局" class="headerlink" title="五、单一继承下的数据成员布局"></a>五、单一继承下的数据成员布局</h1><p>　　（1）一个子类对象，所包含的内容，是他自己的成员，加上他父类的成员的总和。从偏移值看，父类成员先出现，然后才是孩子类成员。<br>　　（2）引入继承关系后，可能会带来内存空间的额外增加（字节对齐）。所以不能用memcpy内存拷贝把父类对象的内容直接往子类对象里拷贝。</p><h1 id="六、带有虚函数的类中数据成员布局"><a href="#六、带有虚函数的类中数据成员布局" class="headerlink" title="六、带有虚函数的类中数据成员布局"></a>六、带有虚函数的类中数据成员布局</h1><h2 id="单个类带虚函数的数据成员布局"><a href="#单个类带虚函数的数据成员布局" class="headerlink" title="单个类带虚函数的数据成员布局"></a>单个类带虚函数的数据成员布局</h2><p>　　类中引入虚函数时，会有额外的成本付出：<br>　　1)编译的时候，编译器会产生虚函数表。<br>　　2)对象中会产生虚函数表指针vptr，用以指向虚函数表。<br>　　3)增加或者扩展构造函数，增加给虚函数表指针vptr赋值的代码，让vptr指向虚函数表。<br>　　4)如果多重继承，比如你继承了2个父类，每个父类都有虚函数的话，每个父类都会有vptr，那继承时，子类就会把这两根vptr都继承过来，如果子类还有自己额外的虚函数的话，子类与第一个基类共用一个vptr。<br>　　5)析构函数中也被扩展增加了虚函数表指针vptr相关的赋值代码，这个赋值代码似乎和构造函数中代码相同。</p><h2 id="单一继承父类带虚函数的数据成员布局"><a href="#单一继承父类带虚函数的数据成员布局" class="headerlink" title="单一继承父类带虚函数的数据成员布局"></a>单一继承父类带虚函数的数据成员布局</h2><p>　　代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_bi;</span><br><span class="line">virtual void mybvirfunc() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class MYACLS :public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_i;</span><br><span class="line">int m_j;</span><br><span class="line">MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int abc = 1; //方便加断点</span><br><span class="line">&#125;</span><br><span class="line">~MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int def = 0;//方便加断点</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl;  //16</span><br><span class="line">printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi);  //MYACLS::m_bi = 4</span><br><span class="line">printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i);    //MYACLS::m_i = 8</span><br><span class="line">printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j);    //MYACLS::m_j = 12</span><br><span class="line"></span><br><span class="line">MYACLS myobj;</span><br><span class="line">myobj.m_i = 3;</span><br><span class="line">myobj.m_j = 6;</span><br><span class="line">myobj.m_bi = 9;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　从打印结果可以看出，当父类中有虚函数的时候，指向父类虚函数表的虚函数表指针会占用内存开头的四个字节，紧接着是父类的成员变量，最后才是子类的成员变量。</p><h2 id="单一继承父类不带虚函数的数据成员布局"><a href="#单一继承父类不带虚函数的数据成员布局" class="headerlink" title="单一继承父类不带虚函数的数据成员布局"></a>单一继承父类不带虚函数的数据成员布局</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_bi;</span><br><span class="line">&#125;;</span><br><span class="line">class MYACLS :public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_i;</span><br><span class="line">int m_j;</span><br><span class="line">MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int abc = 1; //方便加断点</span><br><span class="line">&#125;</span><br><span class="line">~MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int def = 0;//方便加断点</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl;  //12</span><br><span class="line">printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi);  //MYACLS::m_bi = 0</span><br><span class="line">printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i);    //MYACLS::m_i = 4</span><br><span class="line">printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j);    //MYACLS::m_j = 8</span><br><span class="line"></span><br><span class="line">MYACLS myobj;</span><br><span class="line">myobj.m_i = 3;</span><br><span class="line">myobj.m_j = 6;</span><br><span class="line">myobj.m_bi = 9;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　从打印结果可以看出，如果父类中没有虚函数，则父类的成员变量就放到了内存开头处，之后是子类的成员变量。<br>　　但是如果子类中有虚函数而父类中没有，内存布局又会发生变化，即数据在内存空间中的分布分别是：父类成员、子类的虚函数表指针、子类成员。代码及打印结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_bi;</span><br><span class="line">&#125;;</span><br><span class="line">class MYACLS :public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_i;</span><br><span class="line">int m_j;</span><br><span class="line">virtual void myvirfunc() &#123;&#125;</span><br><span class="line">MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int abc = 1; //方便加断点</span><br><span class="line">&#125;</span><br><span class="line">~MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int def = 0;//方便加断点</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl;  //16</span><br><span class="line">printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi);  //MYACLS::m_bi = 0</span><br><span class="line">printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i);    //MYACLS::m_i = 8</span><br><span class="line">printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j);    //MYACLS::m_j = 12</span><br><span class="line"></span><br><span class="line">MYACLS myobj;</span><br><span class="line">myobj.m_i = 3;</span><br><span class="line">myobj.m_j = 6;</span><br><span class="line">myobj.m_bi = 9;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　如果子类和父类中都有虚函数，则子类和父类共用一个虚函数表指针，即它俩的地址一样，都在内存的开头处，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_bi;</span><br><span class="line">virtual void mybvirfunc() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class MYACLS :public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_i;</span><br><span class="line">int m_j;</span><br><span class="line">virtual void myvirfunc() &#123;&#125;</span><br><span class="line">MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int abc = 1; //方便加断点</span><br><span class="line">&#125;</span><br><span class="line">~MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int def = 0;//方便加断点</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl;  //16</span><br><span class="line">printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi);  //MYACLS::m_bi = 4</span><br><span class="line">printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i);    //MYACLS::m_i = 8</span><br><span class="line">printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j);    //MYACLS::m_j = 12</span><br><span class="line"></span><br><span class="line">MYACLS myobj;</span><br><span class="line">myobj.m_i = 3;</span><br><span class="line">myobj.m_j = 6;</span><br><span class="line">myobj.m_bi = 9;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　总结：不管是父类还是子类，只要含有虚函数，则虚函数指针就位于对应的所有数据成员的前面（父类指针对应父类成员，子类指针对应子类成员），如果父类和子类都含有虚函数，则它俩的虚函数表指针共用一块内存，位于内存空间的开头处。</p><h2 id="多重继承且父类都带虚函数的数据成员布局"><a href="#多重继承且父类都带虚函数的数据成员布局" class="headerlink" title="多重继承且父类都带虚函数的数据成员布局"></a>多重继承且父类都带虚函数的数据成员布局</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class Base1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_bi;</span><br><span class="line">virtual void mybvirfunc() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Base1()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Base1::Base1()的this指针是：%p!\n&quot;, this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_b2i;</span><br><span class="line">virtual void mybvirfunc2() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Base2()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Base2::Base2()的this指针是：%p!\n&quot;, this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class MYACLS :public Base1,public Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_i;</span><br><span class="line">int m_j;</span><br><span class="line"></span><br><span class="line">virtual void myvirfunc() &#123;&#125; //虚函数</span><br><span class="line">MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int abc = 1; //方便加断点</span><br><span class="line">printf(&quot;MYACLS::MYACLS()的this指针是：%p!\n&quot;, this);</span><br><span class="line">&#125;</span><br><span class="line">~MYACLS()</span><br><span class="line">&#123;</span><br><span class="line">int def = 0;//方便加断点</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sizeof(MYACLS) &lt;&lt; endl;                  //24</span><br><span class="line">printf(&quot;MYACLS::m_bi = %d\n&quot;, &amp;MYACLS::m_bi);    //MYACLS::m_bi = 4</span><br><span class="line">printf(&quot;MYACLS::m_b2i = %d\n&quot;, &amp;MYACLS::m_b2i);  //MYACLS::m_b2i = 4</span><br><span class="line">printf(&quot;MYACLS::m_i = %d\n&quot;, &amp;MYACLS::m_i);      //MYACLS::m_i = 16</span><br><span class="line">printf(&quot;MYACLS::m_j = %d\n&quot;, &amp;MYACLS::m_j);      //MYACLS::m_j = 20</span><br><span class="line"></span><br><span class="line">MYACLS myobj;       //Base1::Base1()的this指针是：004FFC24!</span><br><span class="line">                        //Base2::Base2()的this指针是：004FFC2C!</span><br><span class="line">                        //MYACLS::MYACLS()的this指针是：004FFC24!</span><br><span class="line">myobj.m_i = 3;</span><br><span class="line">myobj.m_j = 6;</span><br><span class="line">myobj.m_bi = 9;</span><br><span class="line">myobj.m_b2i = 12;</span><br><span class="line"></span><br><span class="line">MYACLS *pmyobj = new MYACLS();   //Base1::Base1()的this指针是：008F11D8!</span><br><span class="line">                                     //Base2::Base2()的this指针是：008F11E0!</span><br><span class="line">                                     //MYACLS::MYACLS()的this指针是：008F11D8!</span><br><span class="line">pmyobj-&gt;m_i = 3;</span><br><span class="line">pmyobj-&gt;m_j = 6;</span><br><span class="line">pmyobj-&gt;m_bi = 9;</span><br><span class="line">pmyobj-&gt;m_b2i = 12;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　（1）通过this指针打印，我们看到访问Base1成员不用跳 ，访问Base2成员要this指针要偏移（跳过）8字节。<br>　　（2）我们看到偏移值，m_bi和m_b2i偏移都是4。<br>　　（3）this指针，加上偏移值就的能够访问对应的成员变量，比如m_b2i = this指针+偏移值。<br>　　结论：我们要访问一个类对象中的成员，成员的定位是通过：this指针（编译器会自动调整）以及该成员的偏移值，这两个因素来定义。这种this指针偏移的调整都需要编译器介入来处理完成。</p><h2 id="虚基类相关"><a href="#虚基类相关" class="headerlink" title="虚基类相关"></a>虚基类相关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Grand //爷爷类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">&#125;;</span><br><span class="line">class A1 : virtual public Grand</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A2 : virtual public Grand</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C1 :public A1, public A2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_c1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; sizeof(Grand) &lt;&lt; endl;  // 1</span><br><span class="line">cout &lt;&lt; sizeof(A1) &lt;&lt; endl;     // 4</span><br><span class="line">cout &lt;&lt; sizeof(A2) &lt;&lt; endl;     // 4</span><br><span class="line">cout &lt;&lt; sizeof(C1) &lt;&lt; endl;     // 12</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　（1）虚基类就是让Grand类只被继承一次，防止二义性问题。<br>　　（2）有虚基类，就有虚基类表vbtable(virtual base table)、虚基类表指针vbptr(virtual base table pointer)。<br>　　（3）空类sizeof(Grand)=1好理解。虚继承之后，A1,A2里就会被编译器插入一个虚基类表指针，这个指针，有点成员变量的感觉。A1,A2里因为有了虚基类表指针，因此占用了4个字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Grand //爷爷类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_grand;</span><br><span class="line">&#125;;</span><br><span class="line">class A1 : virtual public Grand</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_a1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A2 : virtual public Grand</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_a2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C1 :public A1, public A2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_c1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; sizeof(Grand) &lt;&lt; endl;  // 1</span><br><span class="line">cout &lt;&lt; sizeof(A1) &lt;&lt; endl;     // 4</span><br><span class="line">cout &lt;&lt; sizeof(A2) &lt;&lt; endl;     // 4</span><br><span class="line">cout &lt;&lt; sizeof(C1) &lt;&lt; endl;     // 12</span><br><span class="line">//内存分布情况</span><br><span class="line">C1 c;</span><br><span class="line">c.m_grand = 2;   // 21-24字节</span><br><span class="line">c.m_a1 = 3;      // 5-8字节</span><br><span class="line">c.m_a2 = 4;      // 13-16字节</span><br><span class="line">c.m_c1 = 5;      // 17-20字节</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　根据内存分析可以看出：1-4字节和9-12字节应该存放的就是两个虚基类表指针，其中1-4字节是vbptr1（继承自A1），9-12字节是vbptr2（继承自A2）。其余的数据分布如上述程序中所示，需要注意的是：爷爷类里的成员分布在内存的最后。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Grand //爷爷类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_grand;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Grand2 //爷爷类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_grand2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A1 : virtual public Grand,virtual public Grand2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_a1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A2 : virtual public Grand</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_a2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C1 :public A1, public A2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_c1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sizeof(Grand) &lt;&lt; endl;   // 4</span><br><span class="line">cout &lt;&lt; sizeof(A1) &lt;&lt; endl;      // 16（3个int数据+1个虚基类表指针）</span><br><span class="line">cout &lt;&lt; sizeof(A2) &lt;&lt; endl;      // 12（2个int数据+1个虚基类表指针）</span><br><span class="line">cout &lt;&lt; sizeof(C1) &lt;&lt; endl;      // 28</span><br><span class="line"> //内存分布情况</span><br><span class="line">C1 c;</span><br><span class="line">c.m_a1 = 1;           // 5-8字节</span><br><span class="line">c.m_a2 = 2;           // 13-16字节</span><br><span class="line">c.m_c1 = 3;           // 17-20字节</span><br><span class="line">c.m_grand = 4;        // 21-24字节</span><br><span class="line">c.m_grand2 = 5;       // 25-28字节</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　由此，可以判断出，一个类同时虚继承多个父类，只会产生一个虚基类指针（A1）。1-4字节放的是A1的虚基类指针，9-12字节放的是A2的虚基类指针。其他的数据分布如程序所示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、数据成员绑定时机&quot;&gt;&lt;a href=&quot;#一、数据成员绑定时机&quot; class=&quot;headerlink&quot; title=&quot;一、数据成员绑定时机&quot;&gt;&lt;/a&gt;一、数据成员绑定时机&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://liuruijie87.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++对象模型" scheme="https://liuruijie87.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++对象模型（2） -- 虚函数</title>
    <link href="https://liuruijie87.github.io/2019/08/06/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%882/"/>
    <id>https://liuruijie87.github.io/2019/08/06/C-对象模型（2/</id>
    <published>2019-08-06T00:25:28.425Z</published>
    <updated>2019-08-06T02:19:52.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、虚函数表指针位置分析"><a href="#一、虚函数表指针位置分析" class="headerlink" title="一、虚函数表指针位置分析"></a>一、虚函数表指针位置分析</h1><p>　　一个类若有虚函数，这个类就会产生一个虚函数表。当类创建对象的时候，对象内就会维护一个虚函数表指针，该指针(vptr)会指向这个虚函数表的开始地址。接下来借助代码分析一下虚函数表指针的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int i; //4字节</span><br><span class="line">virtual void testfunc() &#123;&#125;  //虚函数，vptr4字节。</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A aobj;</span><br><span class="line">int ilen = sizeof(aobj);</span><br><span class="line">cout &lt;&lt; ilen &lt;&lt; endl;  //8字节</span><br><span class="line"></span><br><span class="line">char *p1 = reinterpret_cast&lt;char *&gt;(&amp;aobj); //类型转换，硬转 &amp;aobj这是对象aobj的首地址。</span><br><span class="line">char *p2 = reinterpret_cast&lt;char *&gt;(&amp;(aobj.i));</span><br><span class="line">if (p1 == p2) //说明aobj.i和aobj的位置相同，说明i在对象aobj内存布局的上边。虚函数表指针vptr在下边</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;虚函数表指针位于对象内存的末尾&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;虚函数表指针位于对象内存的开头&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　通过测试，我们发现虚函数表指针在对象内存的开头处。</p><h1 id="二、继承关系作用下虚函数的手工调用"><a href="#二、继承关系作用下虚函数的手工调用" class="headerlink" title="二、继承关系作用下虚函数的手工调用"></a>二、继承关系作用下虚函数的手工调用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">//父类</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void f() &#123; cout &lt;&lt; &quot;Base::f()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void g() &#123; cout &lt;&lt; &quot;Base::g()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void h() &#123; cout &lt;&lt; &quot;Base::h()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Derive :public Base </span><br><span class="line">&#123;</span><br><span class="line">virtual void g() &#123; cout &lt;&lt; &quot;Derive::g()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//</span><br><span class="line">cout &lt;&lt; sizeof(Base) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; sizeof(Derive) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Derive *d = new Derive(); //派生类指针。</span><br><span class="line">long *pvptr = (long *)d;  //指向对象的指针d转成了long *类型。</span><br><span class="line">long *vptr = (long *)(*pvptr); </span><br><span class="line">//(*pvptr)表示pvptr指向的对象，也就是Derive本身。Derive对象是4字节的，代表的是虚函数表指针地址。</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt;= 4; i++) //循环5次，打印出虚函数的地址。</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;vptr[%d] = 0x:%p\n&quot;, i, vptr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">　　//上述循环运行结果：</span><br><span class="line">　　//vptr[0] = 0x:00DF11A4</span><br><span class="line">　　//vptr[1] = 0x:00DF1320</span><br><span class="line">　　//vptr[2] = 0x:00DF1334</span><br><span class="line">　　//vptr[3] = 0x:00000000</span><br><span class="line">　　//vptr[4] = 0x:69726544</span><br><span class="line"></span><br><span class="line">typedef void(*Func)(void); //定义一个函数指针类型</span><br><span class="line">Func f = (Func)vptr[0]; //f就是函数指针变量，vptr[0]是指向第一个虚函数的。</span><br><span class="line">Func g = (Func)vptr[1];</span><br><span class="line">Func h = (Func)vptr[2];</span><br><span class="line">/*Func i = (Func)vptr[3];</span><br><span class="line">Func j = (Func)vptr[4];*/</span><br><span class="line"></span><br><span class="line">f();   //Base::f()</span><br><span class="line">g();   //Derive::g()</span><br><span class="line">h();   //Base::h()</span><br><span class="line">//i();</span><br><span class="line"></span><br><span class="line">Base *dpar = new Base();  //父类指针</span><br><span class="line">long *pvptrpar = (long *)dpar;</span><br><span class="line">long *vptrpar = (long *)(*pvptrpar);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt;= 4; i++) //循环5次；</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;vptr Base[%d] = 0x:%p\n&quot;, i, vptrpar[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">　　//上述循环运行结果：</span><br><span class="line">　　//vptr Base[0] = 0x:00DF11A4</span><br><span class="line">　　//vptr Base[1] = 0x:00DF117C</span><br><span class="line">　　//vptr Base[2] = 0x:00DF1334</span><br><span class="line">　　//vptr Base[3] = 0x:00000000</span><br><span class="line">　　//vptr Base[4] = 0x:65736142</span><br><span class="line"></span><br><span class="line">Func fpar = (Func)vptrpar[0];  </span><br><span class="line">Func gpar = (Func)vptrpar[1];  </span><br><span class="line">Func hpar = (Func)vptrpar[2];  </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;</span><br><span class="line">fpar(); //Base::f()</span><br><span class="line">gpar(); //Base::g()</span><br><span class="line">hpar(); //Base::h()</span><br><span class="line"></span><br><span class="line">return 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　从上面的运行结果来看（注释中已标出），对于子类对象来说，子类中要是有和父类同名的虚函数，则子类中的虚函数就会把父类中的同名虚函数覆盖，同时虚函数表中对应的虚函数地址必然会发生变化（变成子类中虚函数的地址）。但是如果是父类对象，则还是会调用父类中的虚函数（即不会被覆盖）。<br>　　接着看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef void(*Func)(void); //定义一个函数指针类型</span><br><span class="line"></span><br><span class="line">Derive derive;</span><br><span class="line">long *pvptrderive = (long *)(&amp;derive);  </span><br><span class="line">long *vptrderive = (long *)(*pvptrderive); //0x00b09b6c &#123;project100.exe!void(* Derive::`vftable&apos;[4])()&#125; &#123;11538847&#125;</span><br><span class="line">Func f1 = (Func)vptrderive[0]; //0x00b0119f &#123;project100.exe!Base::f(void)&#125;</span><br><span class="line">Func f2 = (Func)vptrderive[1]; //0x00b0150f &#123;project100.exe!Derive::g(void)&#125;</span><br><span class="line">Func f3 = (Func)vptrderive[2]; //0x00b01325 &#123;project100.exe!Base::h(void)&#125;</span><br><span class="line">Func f4 = (Func)vptrderive[3]; //0x69726544</span><br><span class="line">Func f5 = (Func)vptrderive[4]; //0x3a3a6576</span><br><span class="line"></span><br><span class="line">Derive derive2 = derive; //调用拷贝构造函数</span><br><span class="line">long *pvptrderive2 = (long *)(&amp;derive2);</span><br><span class="line">long *vptrderive2 = (long *)(*pvptrderive2);</span><br><span class="line"></span><br><span class="line">Base base = derive; //直接用子类对象给父类对象值，子类中的属于父类那部分内容会被编译器自动区分（切割）出来并拷贝给了父类对象。</span><br><span class="line">                            //所以Base base = derive;实际干了两个事情：</span><br><span class="line">                            //第一个事情：生成一个base对象</span><br><span class="line">                            //第二个事情：用derive来初始化base对象的值。</span><br><span class="line">long *pvptrbase = (long *)(&amp;base);</span><br><span class="line">long *vptrbase = (long *)(*pvptrbase); //0x00b09b34 &#123;project100.exe!void(* Base::`vftable&apos;[4])()&#125; &#123;11538847&#125;</span><br><span class="line">Func fb1 = (Func)vptrbase[0];   //0x00b0119f &#123;project100.exe!Base::f(void)&#125;</span><br><span class="line">Func fb2 = (Func)vptrbase[1];   //0x00b01177 &#123;project100.exe!Base::g(void)&#125;</span><br><span class="line">Func fb3 = (Func)vptrbase[2];   //0x00b01325 &#123;project100.exe!Base::h(void)&#125;</span><br><span class="line">Func fb4 = (Func)vptrbase[3];    //0x00000000</span><br><span class="line">Func fb5 = (Func)vptrbase[4];    //0x65736142</span><br></pre></td></tr></table></figure><p>　　可以看出，当用子类对象初始化父类对象的时候，编译器给咱们做了一个选择，显然derive的虚函数表指针值并没有覆盖base对象的虚函数表指针值。<br>　　总结：<br>　　（1）一个类只有包含虚函数才会存在虚函数表，同属于一个类的对象共享虚函数表，但是有各自的vptr（虚函数表指针），当然所指向的地址（虚函数表首地址）相同。<br>　　（2）父类中有虚函数就等于子类中有虚函数。话句话来说，父类中有虚函数表，则子类中肯定有虚函数表。因为你是继承父类的。并且只要在父类中是虚函数，那么子类中即便不写virtual，也依旧是虚函数。但如果子类只继承自一个父类，则不管是父类还是子类，它们内部都只会有一个虚函数表。<br>　　（3）如果子类中完全没有新的虚函数，则我们可以认为子类的虚函数表和父类的虚函数表内容相同。但，仅仅是内容相同，这两个虚函数表在内存中处于不同位置，换句话来说，这是内容相同的两张表。<br>　　（4）虚函数表中每一项，保存着一个虚函数的首地址，但如果子类的虚函数表某项和父类的虚函数表某项代表同一个函数（这表示子类没有覆盖父类的虚函数），则该表项所执行的该函数的地址应该相同。<br>　　（5）超出虚函数表部分的内容不可知。</p><h1 id="三、多重继承虚函数表分析"><a href="#三、多重继承虚函数表分析" class="headerlink" title="三、多重继承虚函数表分析"></a>三、多重继承虚函数表分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">//基类1</span><br><span class="line">class Base1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void f()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;base1::f()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void g()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;base1::g()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//基类2</span><br><span class="line">class Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void h()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;base2::h()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void i()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;base2::i()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//子类</span><br><span class="line">class Derived :public Base1, public Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void f() //覆盖父类1的虚函数</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;derived::f()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void i() //覆盖父类2的虚函数</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;derived::i()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如下三个我们自己的虚函数</span><br><span class="line">virtual void mh() </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;derived::mh()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual void mi()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;derived::mi()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual void mj()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;derived::mj()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sizeof(Base1) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; sizeof(Base2) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; sizeof(Derived) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Derived ins; </span><br><span class="line">Base1 &amp;b1 = ins; //多态</span><br><span class="line">Base2 &amp;b2 = ins;</span><br><span class="line">Derived &amp;d = ins;</span><br><span class="line"></span><br><span class="line">typedef void(*Func)(void);</span><br><span class="line">long *pderived1 = (long *)(&amp;ins);</span><br><span class="line">long *vptr1 = (long *)(*pderived1); //取第一个虚函数表指针。</span><br><span class="line"></span><br><span class="line">long *pderived2 = pderived1 + 1; //跳过4字。</span><br><span class="line">long *vptr2 = (long *)(*pderived2); //取第二个虚函数表指针。</span><br><span class="line"></span><br><span class="line">Func f1 = (Func)vptr1[0]; //0x00ab15d7 &#123;project100.exe!Derived::f(void)&#125;</span><br><span class="line">Func f2 = (Func)vptr1[1]; //0x00ab15f0 &#123;project100.exe!Base1::g(void)&#125;</span><br><span class="line">Func f3 = (Func)vptr1[2]; //0x00ab15cd &#123;project100.exe!Derived::mh(void)&#125;</span><br><span class="line">Func f4 = (Func)vptr1[3]; //0x00ab15ff &#123;project100.exe!Derived::mi(void)&#125;</span><br><span class="line">Func f5 = (Func)vptr1[4]; //0x00ab15eb &#123;project100.exe!Derived::mj(void)&#125;</span><br><span class="line">Func f6 = (Func)vptr1[5]; //非正常</span><br><span class="line">Func f7 = (Func)vptr1[6];</span><br><span class="line">Func f8 = (Func)vptr1[7];</span><br><span class="line"></span><br><span class="line">Func f11 = (Func)vptr2[0]; //0x00ab15af &#123;project100.exe!Base2::h(void)&#125;</span><br><span class="line">Func f22 = (Func)vptr2[1]; //0x00ab15b9 &#123;project100.exe!Derived::i(void)&#125;</span><br><span class="line">Func f33 = (Func)vptr2[2]; //非正常</span><br><span class="line">Func f44 = (Func)vptr2[3];</span><br><span class="line"></span><br><span class="line">b1.f();</span><br><span class="line">b2.i();</span><br><span class="line">d.f();</span><br><span class="line">d.i();</span><br><span class="line">d.mh();</span><br><span class="line">d.g();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;</span><br><span class="line">f1();</span><br><span class="line">f2();</span><br><span class="line">f3();</span><br><span class="line">f4();</span><br><span class="line">f5();</span><br><span class="line">cout &lt;&lt; &quot;-------------&quot; &lt;&lt; endl;</span><br><span class="line">f11();</span><br><span class="line">f22();</span><br><span class="line"></span><br><span class="line">return 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　（1）一个对象，如果它的类有多个基类则有多个虚函数表指针（注意是多个虚函数表指针，而不是多个虚函数表）。<br>　　（2）在多继承中，对应各个基类的vptr按继承顺序依次放置在类的内存空间中，且子类与第一个基类共用一个vptr(第二个基类有自己的vptr);<br>　　（3）如上程序中，子类对象ins有两个虚函数表指针，vptr1,vptr2。类Derived有两个虚函数表，因为它继承自两个基类。<br>　　（4）子类和第一个基类公用一个vptr（因为vptr指向一个虚函数表，所以也可以说子类和第一个基类共用一个虚函数表vtbl),因为我们注意到了类Derived的虚函数表1里边的5个函数，而g()正好是base1里边的函数。<br>　　（5）子类中的虚函数覆盖了父类中的同名虚函数。比如derived::f(),derived::i();</p><h1 id="四、vptr、vtbl创建时机"><a href="#四、vptr、vtbl创建时机" class="headerlink" title="四、vptr、vtbl创建时机"></a>四、vptr、vtbl创建时机</h1><p>　　（1）vptr（虚函数表指针）跟着对象走，所以对象什么时候创建出来，vptr就什么时候创建出来。即运行的时候。实际上，对于这种有虚函数的类，在编译的时候，编译器会往相关的构造函数中增加为vptr赋值的代码，这是在编译期间编译器为构造函数增加的。当程序运行的时候，遇到创建对象的代码，执行对象的构造函数，那么这个构造函数里有给对象的vptr(成员变量)赋值的语句，自然这个对象的vptr就被赋值了。<br>　　（2）虚函数表是编译器在编译期间（不是运行期间）就为每个类确定好了对应的虚函数表vtbl的内容。然后也是在编译期间在相应的类构造函数中添加给vptr赋值的代码，这样程序运行的时候，当运行到创建类对象的代码时，会调用类的构造函数，执行到类的构造函数中的给vptr赋值的代码，这样这个类对象的vptr(虚函数表指针)就有值了。</p><h1 id="五、普通类包含虚函数时引发的虚函数调用问题"><a href="#五、普通类包含虚函数时引发的虚函数调用问题" class="headerlink" title="五、普通类包含虚函数时引发的虚函数调用问题"></a>五、普通类包含虚函数时引发的虚函数调用问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">class X</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">int z;</span><br><span class="line">//X() :x(0), y(0), z(0)</span><br><span class="line">X()</span><br><span class="line">&#123;</span><br><span class="line">//编译器角度 伪码；</span><br><span class="line">//vptr = vtbl; //下边的memset会把vptr（虚函数表指针）清0</span><br><span class="line">memset(this, 0, sizeof(X));</span><br><span class="line">cout &lt;&lt; &quot;构造函数被执行&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//X(const X &amp;tm) :x(tm.x), y(tm.y), z(tm.z)</span><br><span class="line">X(const X &amp;tm)</span><br><span class="line">&#123;</span><br><span class="line">memcpy(this, &amp;tm, sizeof(X));</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数被执行&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual ~X()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数被执行&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void virfunc()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;虚函数virfunc()被执行&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void ptfunc()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;普通函数ptfunc()被执行&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//X x0;  //调用构造函数</span><br><span class="line">///*x0.x = 100;</span><br><span class="line">//x0.y = 200;</span><br><span class="line">//x0.z = 300;*/</span><br><span class="line">//x0.virfunc(); //虚函数表指针为null居然可以成功调用虚函数；</span><br><span class="line"></span><br><span class="line">//X x1(x0); //调用拷贝构造函数</span><br><span class="line">//cout &lt;&lt; &quot;x1.x=&quot; &lt;&lt; x1.x &lt;&lt; &quot; x1.y=&quot; &lt;&lt; x1.y &lt;&lt; &quot; x1.z=&quot; &lt;&lt; x1.z &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//X *px0 = new X();</span><br><span class="line">//px0-&gt;ptfunc(); //正常调用</span><br><span class="line">//px0-&gt;virfunc(); //无法正常调用</span><br><span class="line">//delete px0; //无法正常调用</span><br><span class="line">//new出来的对象，虚函数变得无法正常执行了；</span><br><span class="line"></span><br><span class="line">int i = 9;</span><br><span class="line">printf(&quot;i的地址 = %p\n&quot;, &amp;i);</span><br><span class="line">X x0;</span><br><span class="line">printf(&quot;ptfunc()的地址=%p\n&quot;, &amp;X::ptfunc); //打印正常的成员函数地址。</span><br><span class="line">//long *pvptrpar = (long *)(&amp;x0);</span><br><span class="line">//long *vptrpar = (long *)(*pvptrpar);</span><br><span class="line">//printf(&quot;virfunc的地址 = %p\n&quot;, vptrpar[1]);//虚函数virfunc地址</span><br><span class="line">x0.ptfunc();</span><br><span class="line">x0.virfunc(); //不叫多态，属于静态联编，我们推断：这个函数ptfunc()和virfunc()函数，是在编译的就确定好的；</span><br><span class="line"></span><br><span class="line">X *pX0 = new X();</span><br><span class="line">pX0-&gt;ptfunc();</span><br><span class="line">pX0-&gt;virfunc(); //通过虚函数表指针，找虚函数表，然后从虚函数表中找到virfunc虚函数的地址并调用。这就是多态</span><br><span class="line"></span><br><span class="line">//更明白：虚函数，多态，这种概念专门给指针或者引用用的；</span><br><span class="line">X &amp;xy = *pX0;</span><br><span class="line">xy.virfunc();</span><br><span class="line">X &amp;xy2 = x0;</span><br><span class="line">xy2.virfunc();</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　（1）如果一个普通类中包含了虚函数，那么在构造函数中使用如上所示的memset或者拷贝构造函数中使用如上所示的memcpy方法，那么就会出现程序崩溃的情形。<br>　　（2）某些情况下，编译器会往类内部增加一些我们看不见但真实存在的成员变量（隐藏成员变量），比如你类中增加了虚函数，系统默认往类对象中增加虚函数表指针，这个虚函数表指针就是隐藏的成员变量。有了这种变量的类，就不是普通的类了。同时，这种隐藏的成员变量的增加(使用)或者赋值的时机，往往都是在执行构造函数或者拷贝构造函数的函数体之前进行。那么你如果使用memset,memcpy，很可能把编译器给隐藏变量的值你就给清空了，要么覆盖了。<br>　　（3）静态联编是指：我们编译的时候就能确定调用哪个函数。把调用语句和被调用函数绑定到一起。动态联编是在程序运行时，根据时机情况，动态的把调用语句和被调用函数绑定到一起，动态联编一般旨有在多态和虚函数情况下才存在。<br>　　（4）对多态，虚函数，父类，子类。虚函数主要解决的问题父类指针指向子类对象这种情况。如果一个类中只有虚函数，没有继承，那么虚函数和普通函数没有区别，就算虚函数表指针被置空，仍然可通过对象正常调用，因为这是静态联编，不是多态。但是如果用new出来的对象调用，就会失败，因为虚函数表指针为空，找不到虚函数表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、虚函数表指针位置分析&quot;&gt;&lt;a href=&quot;#一、虚函数表指针位置分析&quot; class=&quot;headerlink&quot; title=&quot;一、虚函数表指针位置分析&quot;&gt;&lt;/a&gt;一、虚函数表指针位置分析&lt;/h1&gt;&lt;p&gt;　　一个类若有虚函数，这个类就会产生一个虚函数表。当类创建对
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://liuruijie87.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++对象模型" scheme="https://liuruijie87.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++对象模型（1） -- 对象</title>
    <link href="https://liuruijie87.github.io/2019/08/04/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%881%EF%BC%89/"/>
    <id>https://liuruijie87.github.io/2019/08/04/C-对象模型（1）/</id>
    <published>2019-08-04T00:05:24.676Z</published>
    <updated>2019-08-04T04:37:43.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、类对象所占用的空间"><a href="#一、类对象所占用的空间" class="headerlink" title="一、类对象所占用的空间"></a>一、类对象所占用的空间</h1><p>　　（1）一个空类所占用空间是一个字节，如果有成员变量，就是成员变量占用的内存。为什么空类还要占一个字节的内存？这是因为创建了一个对象就要占用一个字节的地址，就像买房子一样，空房子也是占面积的。<br>　　（2）类的成员函数不占用类对象的内存空间，而成员变量占用对象的内存空间。<br>　　（3）成员变量是包含在每个对象中的，是占用对象字节的，有多少个对象就有多少个成员变量。而对于成员函数，每个类只诞生一个（跟着类走），而不管你用这个类产生了多少个该类的对象。</p><h1 id="二、对象结构的发展和演化"><a href="#二、对象结构的发展和演化" class="headerlink" title="二、对象结构的发展和演化"></a>二、对象结构的发展和演化</h1><p>　　（1）非静态的成员变量(普通成员变量)跟着类对象走（存在对象内部），也就是每个类对象都有自己的成员变量。<br>　　（2）静态成员变量跟对象没有什么关系，所以肯定不会保存在对象内部，是保存在对象外面（表示所占用的内存空间和类对象无关）的，所以不计算在类对象sizeof()内。<br>　　（3）成员函数：不管静态的还是非静态，全部都保存在类对象之外。所以不管几个成员函数，不管是否是静态的成员函数，对象的sizeof的大小都是不增加的。<br>　　（4）虚函数：不管有几个虚函数，sizeof()都是多了4个字节。类里只要有一个虚函数（或者说至少有一个虚函数），这个类就会产生一个指向虚函数的指针。有两个虚函数，那么这个类就会产生两个指向虚函数的指针。而类本身指向虚函数的指针（一个或者一堆）要有地方存放，存放在一个表格里，这个表格我们就称为“虚函数表(virtual table【vtbl】)”。这个虚函数表一般是保存在可执行文件中的，在程序执行的时候载入到内存中来。<br>　　（5）虚函数表是基于类的，跟着类走的。对于类对象，这四个字节的增加，其实是因为虚函数的存在；因为有了虚函数的存在，导致系统往类对象中添加了一个指针，这个指针正好指向这个虚函数表，很多资料上把这个指针叫vptr；这个vptr的值由系统在适当的时机赋值（比如构造函数中通过增加额外的代码来给值）。<br>　　（6）如果有多个数据成员，那么为了提高访问速度，某些编译器可能会将数据成员之间的内存占用比例进行调整(内存字节对齐)。<br>　　（7）不管什么类型指针char *p,int *q;,该指针占用的内存大小是固定的。</p><h1 id="三、this指针调整：多重继承"><a href="#三、this指针调整：多重继承" class="headerlink" title="三、this指针调整：多重继承"></a>三、this指针调整：多重继承</h1><p>　　（1）派生类对象是包含基类子对象的。<br>　　（2）如果派生类只从一个基类继承的话，那么这个派生类对象的地址和基类子对象的地址相同。<br>　　（3）如果派生类对象同时继承多个基类，那么就要注意：第一个基类子对象的开始地址和派生类对象的开始地址相同。后续这些基类子对象的开始地址和派生类对象的开始地址相差多少呢？那就得把前边那些基类子对象所占用的内存空间累加。<br>　　（4）调用哪个子类的成员函数，这个this指针就会被编译器自动调整到对象内存布局中对应该子类对象的起始地址那去。</p><h1 id="四、构造函数语义"><a href="#四、构造函数语义" class="headerlink" title="四、构造函数语义"></a>四、构造函数语义</h1><p>　　传统认识认为：如果我们自己没定义任何构造函数，那么编译器就会为我们隐式自动定义一个默认的构造函数，我们称这种构造函数为：“合成的默认构造函数”。<br>　　事实是：“合成的默认构造函数”，只有在必要的时候，编译器才会为我们合成出来，而不是必然或者必须为我们合成出来。那么编译器会在哪些必要的时候帮助我们把默认的构造函数合成出来呢？<br>　　（1）该类没有任何构造函数，但包含一个类类型的成员,而该对象所属于的类有一个缺省的构造函数。这个时候，编译器就会为该类生成一个 “合成默认的构造函数”，合成的目的是为了调用类类型成员所属类里的默认构造函数。<br>　　（2）父类带缺省构造函数，子类没有任何构造函数，那因为父类这个缺省的构造函数要被调用，所以编译器会为这个子类合成出一个默认构造函数。合成的目的是为了调用这个父类的构造函数。换句话说，编译器合成了默认的构造函数，并在其中安插代码，调用其父类的默认构造函数。<br>　　（3）如果一个类含有虚函数，但没有任何构造函数时，因为虚函数的存在，编译器会给我们生成一个基于该类的虚函数表vftable。此外编译器给我们合成了一个构造函数，调用了父类的构造函数，并且在其中安插代码，把类的虚函数表地址赋给类对象的虚函数表指针（赋值语句/代码）。我们可以把虚函数表指针看成是我们表面上看不见的一个类的成员函数。<br>　　（4）当我们有自己的默认构造函数时，编译器会根据需要扩充我们自己写的构造函数代码，比如调用父类构造函数，给对象的虚函数表指针赋值。<br>　　（5）如果一个类带有虚基类，编译器也会为它合成一个默认构造函数。虚基类：通过两个直接基类（虚基类）继承同一个间接基类。所以一般是三层 ，有爷爷Grand，有两个爹A,A2，有孙子C。有虚基类结构，编译器为子类和父类都产生了“合成的默认构造函数”。</p><h1 id="五、拷贝构造函数语义"><a href="#五、拷贝构造函数语义" class="headerlink" title="五、拷贝构造函数语义"></a>五、拷贝构造函数语义</h1><p>　　传统上，大家认为：如果我们没有定义一个自己的拷贝构造函数，编译器会帮助我们合成 一个拷贝构造函数。<br>　　事实上，这个合成的拷贝构造函数，也是在必要的时候才会被编译器合成出来。那编译器在什么情况下会帮助我们合成出拷贝构造函数来呢？这个编译器合成出来的拷贝构造函数又要干什么事情呢？<br>　　（1）如果一个类A没有拷贝构造函数，但是含有一个类类型CTB的成员变量m_ctb。该类型CTB含有拷贝构造函数，那么当代码中有涉及到类A的拷贝构造时，编译器就会为类A合成一个拷贝构造函数。编译器合成的拷贝构造函数往往都是干一些特殊的事情。如果只是一些类成员变量值的拷贝这些事，编译器是不用专门合成出拷贝构造函数来干的，编译器内部就干了，即成员变量初始化手法，比如int这种简单类型，直接就按值拷贝过去,编译器不需要合成拷贝构造函数的情况下就帮助我们把这个事情办了。再如类A中有类类型ASon成员变量asubobj，也会递归似的去拷贝类ASon的每个成员变量。<br>　　（2）如果一个类CTBSon没有拷贝构造函数，但是它有一个父类CTB，父类有拷贝构造函数，当代码中有涉及到类CTBSon的拷贝构造时，编译器会为CTBSon合成一个拷贝构造函数，调用父类的拷贝构造函数。<br>　　（3）如果一个类CTBSon没有拷贝构造函数，但是该类声明了或者继承了虚函数，当代码中有涉及到类CTBSon的拷贝构造时，编译器会为CTBSon合成一个拷贝构造函数 ,往这个拷贝构造函数里插入语句。这个语句的含义是设定类对象的虚函数表指针值。<br>　　（4）如果一个类没有拷贝构造函数，但是该类含有虚基类，当代码中有涉及到类的拷贝构造时，编译器会为该类合成一个拷贝构造函数。</p><h1 id="六、程序转化语义"><a href="#六、程序转化语义" class="headerlink" title="六、程序转化语义"></a>六、程序转化语义</h1><p>　　程序转化语义主要是理解编译器如何将人类写的代码解析成编译器理解的代码。为此，从两个角度来分析。下面的代码帮助更好的理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class X</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_i;</span><br><span class="line">X(const X &amp;tmpx)</span><br><span class="line">&#123;</span><br><span class="line">m_i = tmpx.m_i;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数被调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">X()</span><br><span class="line">&#123;</span><br><span class="line">m_i = 0;</span><br><span class="line">cout &lt;&lt; &quot;构造函数被调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~X()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数被调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void functest()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;functest()被调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//参数初始化对比</span><br><span class="line">//人类角度</span><br><span class="line">void func(X tmpx)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//老编译器看func(老编译器角度)</span><br><span class="line">void func(X &amp;tmpx)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//返回值初始化对比</span><br><span class="line">//人类视角</span><br><span class="line">X func()</span><br><span class="line">&#123;</span><br><span class="line">X x0;</span><br><span class="line">//....</span><br><span class="line">return x0;   //系统产生临时对象并把x0的内容拷贝构造给了临时对象。</span><br><span class="line">&#125;</span><br><span class="line">//编译器角度的func</span><br><span class="line">void func(X &amp;extra)</span><br><span class="line">&#123;</span><br><span class="line">X x0; //从编译器角度，这行不调用X的构造函数</span><br><span class="line">//...</span><br><span class="line">//...</span><br><span class="line">extra.X::X(x0);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　我们写的代码，编译器会对代码进行拆分，拆分成编译器更容易理解和实现的代码。看一看编译器是如何解析这些代码的。<br>　　（1）定义时初始化对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//程序员视角</span><br><span class="line">X x0;</span><br><span class="line">x0.m_i = 15;</span><br><span class="line">X x1 = x0; </span><br><span class="line">X x2(x0);</span><br><span class="line">X x3 = (x0);</span><br><span class="line"></span><br><span class="line">//切换到编译器角度，编译器会拆分成两个步骤(编译器视角)</span><br><span class="line">X x100;           //步骤一：定义一个对象，为对象分配内存。从编译器视角来看，这句是不调用X类的构造函数。</span><br><span class="line">x100.X::X(x0);    //步骤二：直接调用对象的拷贝构造函数去了；</span><br></pre></td></tr></table></figure><p>　　（2）参数的初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//程序员视角/现代编译器</span><br><span class="line">func(x0);</span><br><span class="line"></span><br><span class="line">//老编译器视角</span><br><span class="line">X tmpobj; //编译器产生一个临时对象</span><br><span class="line">tmpobj.X::X(x0); //调用拷贝构造函数</span><br><span class="line">func(tmpobj); //用临时对象调用func</span><br><span class="line">tmpobj.X::~X(); //func()被调用完成后，本析构被调用。</span><br></pre></td></tr></table></figure><p>　　（3）返回值初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//程序员角度</span><br><span class="line">X my = func();</span><br><span class="line"></span><br><span class="line">//编译器对上述代码的理解(编译器角度)</span><br><span class="line">X my; //不会调用X的构造函数</span><br><span class="line">func(my);</span><br><span class="line"></span><br><span class="line">//利用返回值调用成员函数</span><br><span class="line">//人类视角</span><br><span class="line">func().functest();</span><br><span class="line"></span><br><span class="line">//切换到编译器视角</span><br><span class="line">X my; //不会调用X的构造函数</span><br><span class="line">(func(my), my).functest(); //逗号表达式：先计算表达式1，再计算表达式2，整个逗号表达式的结果是表达式2的值；</span><br><span class="line"></span><br><span class="line">//利用函数指针调用成员函数</span><br><span class="line">//程序员视角</span><br><span class="line">X(*pf)(); //定义个函数指针</span><br><span class="line">pf = func;</span><br><span class="line">pf().functest();</span><br><span class="line"></span><br><span class="line">//编译器视角</span><br><span class="line">X my; //不调用构造函数</span><br><span class="line">void (*pf)(X &amp;);</span><br><span class="line">pf = func;</span><br><span class="line">pf(my);</span><br><span class="line">my.functest();</span><br></pre></td></tr></table></figure><h1 id="七、拷贝构造续与深浅拷贝"><a href="#七、拷贝构造续与深浅拷贝" class="headerlink" title="七、拷贝构造续与深浅拷贝"></a>七、拷贝构造续与深浅拷贝</h1><p>　　（1）当编译器面临用一个类对象作为另外一个类对象初值的情况，各个编译器表现不同。但是所有编译器都为了提高效率而努力。我们也没有办法确定我们自己使用的编译器是否一定会调用拷贝构造函数。<br>　　（2）拷贝构造函数不是必须有的，如果只有一些简单的成员变量类型，int,double，你会发现你根本不需要拷贝构造函数，编译器内部本身就支持成员变量的bitwise(按位)copy，即按位拷贝。<br>　　（3）当需要处理很复杂的成员变量类型的时候。因为我们增加了自己的拷贝构造函数，导致编译器本身的bitwise拷贝能力失效，它会调用我们自己的拷贝构造函数，因此如果你增加了自己的拷贝构造函数后，就要对各个成员变量的值的初始化负责了。<br>　　（4）我们自己创建内存，把目标对象的内存内容拷贝过来，叫深拷贝，例如下面的程序。相反，上述编译器做的拷贝叫浅拷贝。（<strong>注意：</strong>涉及到指针的时候，必须用深拷贝，不能浅拷贝，否则指针所指的内存会被析构两次，导致错误）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class X</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_i;</span><br><span class="line">int *p_mi;</span><br><span class="line">X(const X&amp; tmpx)</span><br><span class="line">&#123;</span><br><span class="line">p_mi = new int(100); //自己申请内存</span><br><span class="line">memcpy(p_mi, tmpx.p_mi, sizeof(int)); //拷贝</span><br><span class="line">m_i = tmpx.m_i;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数被调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="八、初始化列表"><a href="#八、初始化列表" class="headerlink" title="八、初始化列表"></a>八、初始化列表</h1><p>　　（1）必须使用初始化列表的情况<br>　　　　（a）这个成员是个引用<br>　　　　（b）是个const类型成员<br>　　　　（c）如果这个类是继承一个基类，并且基类中有构造函数，这个构造函数里边还有参数。<br>　　　　（d）如果成员变量类型是某个类类型，而这个类的构造函数带参数时。<br>　　（2）使用初始化列表的优势。除了必须用初始化列表的场合，我们用初始化列表还有什么其他目的？ 有，就是提高程序运行效率。对于类类型成员变量放到初始化列表中能够比较明显的看到效率的提升，但是如果是个简单类型的成员变量比如int m_test,其实放在初始化列表或者放在函数体里效率差别不大。（<strong>提醒：</strong>成员变量初始化尽量放在初始化列表里，显得高端，大气上档次）<br>　　（3）初始化列表中的代码可以看作是被编译器安插到构造函数体中的，只是这些代码有些特殊。这些代码是在任何用户自己的构造函数体代码之前被执行的。所以要区分开构造函数中的<strong>用户代码</strong>和<strong>编译器插入的初始化所属的代码</strong>。<br>　　（4）初始化列表中变量的初始化顺序是变量的定义顺序，而不是在初始化列表中的顺序。不建议在初始化列表中进行两个都在初始化列表中出现的成员之间的初始化（例如：m1和m2都在初始化列表中，不建议用m1来初始化m2，或用m2初始化m1）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、类对象所占用的空间&quot;&gt;&lt;a href=&quot;#一、类对象所占用的空间&quot; class=&quot;headerlink&quot; title=&quot;一、类对象所占用的空间&quot;&gt;&lt;/a&gt;一、类对象所占用的空间&lt;/h1&gt;&lt;p&gt;　　（1）一个空类所占用空间是一个字节，如果有成员变量，就是成员变量
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://liuruijie87.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++对象模型" scheme="https://liuruijie87.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>STL源码剖析（3）</title>
    <link href="https://liuruijie87.github.io/2019/07/30/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/"/>
    <id>https://liuruijie87.github.io/2019/07/30/STL源码剖析读书笔记（3）/</id>
    <published>2019-07-30T00:58:40.224Z</published>
    <updated>2019-08-04T04:50:31.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>　　前一篇博文介绍了<strong>迭代器</strong>，接下来介绍一下STL的大部头–<strong>容器</strong>。这一篇首先介绍<strong>序列式容器</strong>。</p><h1 id="容器概览与分类"><a href="#容器概览与分类" class="headerlink" title="容器概览与分类"></a>容器概览与分类</h1><p>　　STL的容器是将运用最广的一些数据结构实现出来。众所周知，常用的数据结构不外乎 array, list, tree, stack, queue, hash table, set, map 等。根据数据在容器中的排列特性，这些数据结构分为序列式和关联式两种，因此容器也分为序列式容器和关联式容器。序列式容器有：array, vector, heap, priority-queue, list, slist, deque, stack, queue。关联式容器有：rb-tree, set, map, multiset, multimap, hashtable, hash-set, hash-map, hash-multiset, hash_multimap。<br>　　其中，heap是以vector为底层来实现的，priority-queue又是以heap为底层实现。而stack和queue都是以deque为原型通过配接器配接而来。关联式容器中的 set map multiset multimap 都是以 rb-tree 为底层实现, hash-set hash-map hash-multiset hash_multimap又都是以 hashtable 为底层实现。<br>　　需要注意的是，序列式容器都可序，但未必有序。接下来分别介绍各容器。</p><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h2 id="vector概述"><a href="#vector概述" class="headerlink" title="vector概述"></a>vector概述</h2><p>　　vector 的数据安排以及操作方式与 array 非常相似。两者唯一的差别在于空间的运用的灵活性。array 是静态空间，一旦配置了就不能改变，要换一个大（小）一点的空间，首先得配置一块新空间，然后从旧址一一搬往新址，再把原来的空间释放。vector 是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。因此使用 vector，我们再也不必因为害怕空间不足而一开始就要求一个大块头 array 了。</p><h2 id="vector的迭代器"><a href="#vector的迭代器" class="headerlink" title="vector的迭代器"></a>vector的迭代器</h2><p>　　vector 维护的是一个连续的线性空间，所以不论其元素型别为何，普通指针都可以作为 vector 的迭代器而满足所有必要条件。因此 vector 的迭代器是普通指针。vector 支持随机存取，而普通指针也正有这样的能力，所以 vector 提供的是 random access iterators。</p><h2 id="vector的数据结构"><a href="#vector的数据结构" class="headerlink" title="vector的数据结构"></a>vector的数据结构</h2><p>　　vector的数据结构比较简单，是线性连续空间。它内部维护有三个迭代器（指针）：start表示目前使用空间的头，finish表示目前使用空间的尾，end_of_storage表示目前可用空间的尾。<br>　　当我们以push_back()将新元素插入于vector尾端时，该函数首先检查是否还有备用空间，如果有就直接在备用空间上构造元素，并调整迭代器 finish，使 vector 变大。如果没有备用空间了，就扩充空间，即动态增加大小，这并不是在原空间之后接续新空间（因为无法保证原空间之后有可供配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对 vector 的任何操作，一旦引起空间重新配置，指向原 vector 的所有迭代器就都失效了。　　</p><h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><h2 id="list概述"><a href="#list概述" class="headerlink" title="list概述"></a>list概述</h2><p>　　list是一个链表，是由一个一个节点组成的，每一个节点结构内部有两个指针，分别指向前一个节点和后一个节点，还有一个数据域来存放节点数据。list的好处是每次插入或删除一个元素，就配置或释放一个元素空间。因此，list对空间的利用率很高，一点也不浪费。而且，对于任何位置的元素插入或元素移除，list永远是常数时间。</p><h2 id="list的迭代器"><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h2><p>　　list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在存储空间中连续存在。list迭代器必须有能力指向list的节点，并且有能力进行正确的递增、递减、取值、成员存取等操作。也就是说，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取用的是节点的成员。<br>　　由于STL的list是一个双向链表。迭代器必须具备前移、后移的能力，所以list提供的是bidirectional iterators。list在插入和接合操作的时候都不会造成原有的list迭代器失效，在删除操作的时候只有指向被删元素的那个迭代器失效，其他迭代器不受任何影响。</p><h2 id="list的数据结构"><a href="#list的数据结构" class="headerlink" title="list的数据结构"></a>list的数据结构</h2><p>　　list不仅是一个双向链表，而且还是一个环状双向链表，所以它只需要一个指针，便可完整表现整个链表。如果让该指针（注意：此指针并非前面所说的节点内部的指针，这里的指针是指向每个节点的指针）指向刻意置于尾端的一个空白节点，便能符合STL对于“前闭后开”区间的要求，成为list迭代器。list作为双向链表，在头部和尾部都可以插入数据。</p><h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><h2 id="deque概述"><a href="#deque概述" class="headerlink" title="deque概述"></a>deque概述</h2><p>　　deque是一种双向开口的连续线性空间。所谓双向开口，意思就是可以在头尾两端分别做元素的插入和删除操作。deque和vector的不同主要有两点：（1）vector是单向开口的空间，虽然也能在头部插入元素，但是效率极差，而deque可以在常数时间内对头部进行插入或移除操作。（2）deque没有容量的概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。而vector是因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间。<br>　　deque表面上看起来是连续空间，其实它内部是将一段一段连续空间通过中控器的操作接合起来，一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，使人们使用起来感觉像是在操作一段连续空间。它还提供了随机存取接口，避免了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器结构。<br>　　deque采用一块所谓的map作为主控，这里的map其实是一小块连续空间，其中每个元素都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的存储空间主体。通过看源码，可以发现map其实是一个指针，所指之物又是一个指针，指向另一块空间。</p><h2 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h2><p>　　deque的迭代器首先必须能够指出缓冲区在哪里，其次它必须能够判断自己是否已经处于所在缓冲区的边缘，如果是，一旦前进或后退时就必须跳跃至下一个或上一个缓冲区。因此，deque的迭代器应该包括四个指针：cur指向该迭代器所指缓冲区中的当前元素，first指向该迭代器所指缓冲区的头部，last指向该迭代器所指缓冲区的尾部，node指向管控中心，用来找到迭代器所指的缓冲区。</p><h2 id="deque的数据结构"><a href="#deque的数据结构" class="headerlink" title="deque的数据结构"></a>deque的数据结构</h2><p>　　deque除了维护一个先前说过的指向map的指针外，也维护start,finish两个迭代器，分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素的下一位置。此外，它当然也必须记住目前的map大小。因为一旦map所提供的节点不足，就必须重新配置更大的一块map。</p><h1 id="stack和queue"><a href="#stack和queue" class="headerlink" title="stack和queue"></a>stack和queue</h1><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>　　stack是一种先进后出的数据结构，它只有一个出口。stack允许新增元素、移除元素、取得顶端元素。但除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不允许有遍历行为。STL中以deque作为缺省情况下的stack底部结构。<br>　　stack所有元素的进出都必须符合先进后出的条件，只有stack顶端的元素，才有机会被外界取用。stack不提供走访功能，也不提供迭代器。另外，除了deque外，list也可以作为stack的底部容器。</p><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>　　queue是一种先进先出的数据结构。他有两个出口，允许新增元素、移除元素、从最底端加入元素、取得最顶端的元素。但是除了最底端加入、最顶端取出外，没有其他任何办法可以存取queue的其他元素。即queue不允许有遍历行为，queue也没有迭代器。STL默认将deque作为queue的底部容器，当然list也可以作为queue的底部容器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;　　前一篇博文介绍了&lt;strong&gt;迭代器&lt;/strong&gt;，接下来介绍一下STL的大部头–&lt;strong&gt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://liuruijie87.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="STL" scheme="https://liuruijie87.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL源码剖析（2）</title>
    <link href="https://liuruijie87.github.io/2019/07/28/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
    <id>https://liuruijie87.github.io/2019/07/28/STL源码剖析读书笔记（2）/</id>
    <published>2019-07-28T01:30:17.000Z</published>
    <updated>2019-08-04T04:50:55.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>　　上一篇博文写了STL的<strong>分配器</strong>，这一篇着重介绍一下<strong>迭代器</strong>。</p><h1 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h1><p>　　我们都知道，STL中将容器和算法分离开来，彼此独立设计，以达到泛化的效果，而在使用的时候又需要将这两种东西撮合到一起，实现这个撮合功能的就是迭代器。也就是说迭代器是介于容器与算法之间的一种东西，它可以把实现某个算法所需要的容器里面的信息传递给算法，从而达到一种“桥梁”的效果。<br>　　迭代器可以看作是一种“智能指针”。它是一种行为类似指针的对象，而指针的各种行为中最常见的也是最重要的便是内容提取和成员访问，因此，迭代器最重要的编程工作就是对 operator✳ 和 operator-&gt;进行重载。关于这一点，其实跟真证的智能指针（share_ptr等）没有区别。既然迭代器实现的功能和指针一样，那为什么不直接用指针来代替迭代器呢？何必还要多此一举。这是因为，指针只能在连续空间上前进和后退，而不能随意的跳转，例如在双向链表的每一个节点中，都有两个指针，分别指向前一个元素和后一个元素，除此之外每个节点中还有另外的空间来存储数据，当指针+1的时候，它只能在该节点的连续空间上移动，而当设计好相应功能的迭代器+1的时候，可以直接跳到下一个节点，也就是说，迭代器可以实现跨区域跳转，这就是它与指针之间最大的不同。</p><h1 id="迭代器的相应型别"><a href="#迭代器的相应型别" class="headerlink" title="迭代器的相应型别"></a>迭代器的相应型别</h1><p>　　我们发现，在算法中运用迭代器时，会用到迭代器的相应型别，什么是相应型别？迭代器所指之物的型别就是其中的一种。常用迭代器的相应型别有五种，分别是：value type; difference type; reference type; pointer type; iterator_category.接下来分别介绍这五种相应型别。</p><h2 id="value-type"><a href="#value-type" class="headerlink" title="value type"></a>value type</h2><p>　　所谓 value type，就是指迭代器所指对象的型别，任何一个打算与 STL 算法有完美搭配的类，都应该定义自己的 value type 内嵌型别。</p><h2 id="difference-type"><a href="#difference-type" class="headerlink" title="difference type"></a>difference type</h2><p>　　difference type 用来表示两个迭代器之间的距离，因此它也可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其最大容量，如果一个泛型算法提供计数功能，例如 STL 的 count(), 其传回值就必须使用迭代器的 difference type。</p><h2 id="reference-type"><a href="#reference-type" class="headerlink" title="reference type"></a>reference type</h2><p>　　在 C++ 中，函数要传回左值，都是以传引用的方式进行，所以当 p 是个可修改值的迭代器时，如果其 value type 是 T,那么 ✳p 的型别不应该是 T，应该是 T&amp;.同理，如果 p 是一个不可修改值的迭代器，其 value type 是 T，那么 ✳p 的型别不应该是 const T,而应该是 const T&amp;。这里讨论的 ✳p 的型别，即所谓的 reference type。</p><h2 id="pointer-type"><a href="#pointer-type" class="headerlink" title="pointer type"></a>pointer type</h2><p>　　指针和引用有着非常密切的关系。如果传回一个左值，令它代表 p 所指之物是可能的，那么传回一个左值，令它代表 p 所指之物的地址也一定可以。也就是说，我们能够传回一个指针，指向迭代器所指之物。</p><h2 id="iterator-category"><a href="#iterator-category" class="headerlink" title="iterator_category"></a>iterator_category</h2><p>　　这个型别表明了迭代器的类别。根据移动特性和施行操作，迭代器被分为五类：input iterator（只读，即这种迭代器所指的对象不允许外界改变）；output iterator（只写，即该迭代器所指的对象只能被外界改变，不能读取）；forward iterator（单向读写）；bidirectional iterator（双向读写）；random access iterator（随机读写）。<br>　　以上五种迭代器的类别，前三种支持 operator++，第四种再加上 operator–，第五种则涵盖所有指针算术能力，包括 p+n, p-n, p[n], p1-p2, p1&lt;p2。在设计算法时，应该尽量对迭代器的类型做一个明确的规定，这样才能在不同情况下提供最大的效率。假设有个算法可接受 forward iterator ,你给它传一个 random access iteator 进去，它当然也会接受，因为一个 random access iteator 必然是一个 forward iteator,但是从效率上来讲，这并不是最佳的方案。</p><h2 id="Traits编程技法"><a href="#Traits编程技法" class="headerlink" title="Traits编程技法"></a>Traits编程技法</h2><p>　　traits用来提取对象的型别，对应的模板参数不管是泛化版本还是特化版本，通通都能准确的萃取出来。如果传进来的参数 I 定义有自己的 value type，那么通过 traits,萃取出来的 value type 就是 I::value type。如果是特化版本，例如 T✳，则萃取出来的 value type 就是 T。特别注意，const T✳，萃取出来后也是 T 而非 const T,这是因为我们的本意就是声明一个临时变量，使之与迭代器的 value type 相同，而如果声明一个无法赋值的变量，没有什么作用，因此，对于 const 类型的变量，萃取出来的 value type就会变成 non-const类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;　　上一篇博文写了STL的&lt;strong&gt;分配器&lt;/strong&gt;，这一篇着重介绍一下&lt;strong&gt;迭代器
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://liuruijie87.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="STL" scheme="https://liuruijie87.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL源码剖析（1）</title>
    <link href="https://liuruijie87.github.io/2019/07/26/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <id>https://liuruijie87.github.io/2019/07/26/STL源码剖析读书笔记（1）/</id>
    <published>2019-07-26T02:57:50.591Z</published>
    <updated>2019-08-04T04:50:46.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p> 　　近段时间看了侯捷老师的《STL源码剖析》，看第一遍的时候一头雾水，反复多看几遍，似乎明白了一些。因此将学到的知识做一个记录，也算是记录自己的学习过程。本系列博客主要记录一些宏观理解性的东西，具体的代码实现还是要仔细品味原书。</p><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>　　STL即C++标准模板库，主要由六大部件组成，分别是：分配器、容器、迭代器、算法、仿函数、配接器。这六大部件之间的交互关系表现为：容器通过分配器取得数据存储空间，算法通过迭代器存取容器的内容，仿函数可以协助算法完成不同的策略变化，配接器可以修饰或套接仿函数、迭代器、容器等。<br>　　在讲述这些主要部件之前，先来了解一下面向对象编程和泛型编程，面向对象编程（Object-Oriented programming，简称OOP）企图将数据和处理数据的方法放到一起，例如，在C++的类中，一般会有成员变量和处理成员变量的成员函数，在需要使用的时候创建一个对象，然后以对象来调用它们。而泛型编程（Generic Programming,简称GP）是将数据和处理方法分离开来，这里的处理方法通常是全局函数，例如STL中的算法和容器，两者互不影响，需要的时候通过迭代器来传递信息。<br>　　好了，接下来就从这六大部件出发，了解STL的内部关系。这篇博文主要记录分配器的重点。</p><h1 id="分配器（allocators）"><a href="#分配器（allocators）" class="headerlink" title="分配器（allocators）"></a>分配器（allocators）</h1><p>　　allocator主要是用来管理存储空间，它当中的 allocate() 调用 operator new() 来分配空间，其中 operator new() 中又调用了C语言中的 malloc() 函数，而 deallocate() 则调用了operator delete(),其中，operator delete() 又调用了 free() 来释放内存。以上谈的这种分配器是标准规范下的实现方法。而SGI STL有一种默认的分配器 alloc ，它的每一个容器都已经指定其缺省的空间分配器为 alloc，例如下面的 vector 声明：<br>    template &lt;class T, class Alloc = alloc&gt;<br>    class vector{…};<br>　　这其中就是缺省使用的 alloc 为分配器。由于调用 malloc() 只会寻找整片比较大的空间，对于一些小型区块，可能造成内存浪费的问题,因此，SGI设计了双级分配器，第一级分配器直接使用 malloc() 和 free()，第二级分配器则视情况采用不同的策略：当配置区块超过128字节时，视之为 “足够大”，便调用第一级分配器    ，当分配区块小于128字节时，视之为 “过小”，为了降低额外负担（合理利用资源），就使用第二级分配器。<br>　　而第二级分配器的具体实现是以内存池管理的形式，每次配置一块大内存，然后维护对应的自由链表（可增加，也可删减），下次如果再有相同大小的内存需求，就直接从自由链表中取出，如果使用方释放了小块内存，则由分配器回收到对应的链表中。为了方便管理，SGI的第二级分配器会主动将任何小额区块的内存需求上调至8的倍数（例如使用者需要30字节，就自动调整为32字节），并维护16个自由链表，各自管理的大小分别为：8，16，24，32，40，56，64，72，80，88，96，104，112，128字节的小额区块（例如：第一个链表节点就管理空间内所有大小为8字节的小区快，第二个节点管理所有大小为16字节的小区快，以此类推）。<br>　　因此，整个的内存分配释放过程即可归纳为如下流程：分配器拥有标准接口函数 allocate()，此函数首先判断区块的大小，大于128字节就调用第一级分配器，小于128字节就检查对应的自由链表。如果自由链表内有可用的区块，就直接拿来用，如果没有可用的区块，就将区块大小上调至8的倍数，然后重新填充空间。 在释放的时候，同样由分配器的标准接口函数 deallocate() 首先判断区块大小，大于128字节就调用第一级分配器，小于128字节就找出对应的自由链表，将区块回收。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt; 　　近段时间看了侯捷老师的《STL源码剖析》，看第一遍的时候一头雾水，反复多看几遍，似乎明白了一些。因此将
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://liuruijie87.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="STL" scheme="https://liuruijie87.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="https://liuruijie87.github.io/2019/07/13/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://liuruijie87.github.io/2019/07/13/第一篇博客/</id>
    <published>2019-07-13T11:51:56.653Z</published>
    <updated>2019-07-14T13:55:28.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写博客的想法是怎么产生的"><a href="#写博客的想法是怎么产生的" class="headerlink" title="写博客的想法是怎么产生的"></a>写博客的想法是怎么产生的</h1><p>前两天在B站上偶然看见一个免费搭建个人博客的教程，于是产生了兴趣。尝试去搜索了一下，竟然发现有好多搭建博客的方法，实在是感觉自己好low，不过，总归现在发现还不算太晚（强行安慰。。）于是按照搜索的几种方法都进行了尝试，最终选择了用 hexo 配合 github 搭建了第一个属于自己的个人博客（正是此博客）。虽然现在看起来有点low，但是基本功能还算齐全，其他华丽的功能有待开发。  </p><h1 id="写博客的目的"><a href="#写博客的目的" class="headerlink" title="写博客的目的"></a>写博客的目的</h1><p>博客站点搭建好了，当然也要开始养成写博客的习惯了。之前在网上搜索一些问题的时候总是能看到各种大佬级别的博客，都写得特别好，虽然我也有过写博客的想法，但是一直没有付诸行动，这次搭建了自己的站点，再不写点就说不过去了，总不能就光秃秃的一个页面，什么内容也没有吧。所以借着这次机会，总算能治一治我的拖延症了。至于本博客的目的，就当是记录自己的生活，学习过程。如果能帮到别人，那自然是更好。</p><h1 id="博客内容"><a href="#博客内容" class="headerlink" title="博客内容"></a>博客内容</h1><p>对于博客内容，我初步打算分为以下几个类别：生活、技术、读书笔记等。生活类的文章主要谈一些我所经历过的值得记录的事情以及感想；技术方面主要就是在学习过程中的一些积累（这方面可能会写的比较多一点）。读书笔记则会在我每读完一本书的时候做一些总结，方便以后查阅（主要是指技术书籍）。当然后续还有其他有趣的版块分类，我也会加进去。</p><h1 id="期待的样子"><a href="#期待的样子" class="headerlink" title="期待的样子"></a>期待的样子</h1><p> 我所期待的博客当然是不仅能够连贯地记录自己的生活，而且能够利用自己的知识帮助更多的人。然而，道理我们都懂，一口吃不成胖子，而且万事开头难，所以要一步一步来，努力把它打造成自己喜欢的样子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写博客的想法是怎么产生的&quot;&gt;&lt;a href=&quot;#写博客的想法是怎么产生的&quot; class=&quot;headerlink&quot; title=&quot;写博客的想法是怎么产生的&quot;&gt;&lt;/a&gt;写博客的想法是怎么产生的&lt;/h1&gt;&lt;p&gt;前两天在B站上偶然看见一个免费搭建个人博客的教程，于是产生了
      
    
    </summary>
    
      <category term="生活杂谈" scheme="https://liuruijie87.github.io/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="生活杂谈" scheme="https://liuruijie87.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
